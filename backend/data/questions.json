[
  {
    "id": "q1",
    "title": "test",
    "content": "React Hooks 有两个主要的使用规则：<br><br>1. 只在最顶层使用 Hook<br>不要在循环、条件或嵌套函数中调用 Hook，确保总是在 React 函数的顶层调用 Hook。<br><br>2. 只在 React 函数中调用 Hook<br>不要在普通的 JavaScript 函数中调用 Hook。<br><br>为什么要有这些规则？<br>React 依赖于调用顺序来正确地将 Hook 和 组件关联起来。如果在条件语句或循环中使用 Hook，可能会导致状态不一致的 Bug。",
    "categoryId": "1767966254373",
    "isFrequent": true,
    "createdAt": "2025-01-09T00:00:00.000Z",
    "updatedAt": "2026-01-09T14:05:38.357Z"
  },
  {
    "id": "q2",
    "title": "useEffect 的依赖数组",
    "content": "useEffect 的第二个参数是依赖数组，它决定了 effect 何时重新执行：<br><br>1. 不传依赖数组：每次渲染后都会执行<br><code>useEffect(() => { /* effect */ })</code><br><br>2. 空数组：只在组件挂载和卸载时执行<br><code>useEffect(() => { /* effect */ }, [])</code><br><br>3. 传入依赖：依赖变化时执行<br><code>useEffect(() => { /* effect */ }, [count])</code><br><br>注意：依赖数组中的值必须是组件作用域内定义的值（props, state 等）。",
    "categoryId": "1767966254373",
    "isFrequent": true,
    "createdAt": "2025-01-09T00:00:00.000Z",
    "updatedAt": "2025-01-09T00:00:00.000Z"
  },
  {
    "id": "q3",
    "title": "TypeScript 类型断言",
    "content": "TypeScript 提供了两种类型断言语法：<br><br>1. 尖括号语法<br><code>let someValue: any = 'this is a string';<br>let strLength: number = (&lt;string&gt;someValue).length;</code><br><br>2. as 语法（推荐）<br><code>let someValue: any = 'this is a string';<br>let strLength: number = (someValue as string).length;</code><br><br>注意：类型断言不会改变变量的类型，只是告诉 TypeScript 编译器你确信这个值的类型。",
    "categoryId": "1767966254374",
    "isFrequent": false,
    "createdAt": "2025-01-09T00:00:00.000Z",
    "updatedAt": "2025-01-09T00:00:00.000Z"
  },
  {
    "id": "1767967761727",
    "title": "通过代理测试",
    "content": "代理测试内容11",
    "categoryId": "1767966254373",
    "isFrequent": false,
    "createdAt": "2026-01-09T14:09:21.727Z",
    "updatedAt": "2026-01-09T14:09:47.048Z"
  },
  {
    "id": "1767967796351",
    "title": "111",
    "content": "111",
    "categoryId": "1767966254373",
    "isFrequent": true,
    "createdAt": "2026-01-09T14:09:56.351Z",
    "updatedAt": "2026-01-09T14:09:56.351Z"
  },
  {
    "id": "1768101363841",
    "title": "*2. CSS中可继承与不可继承属性有哪些",
    "content": "### *2. CSS中可继承与不可继承属性有哪些\n\n**一、无继承性的属性**\n\n1. **display**：规定元素应该生成的框的类型\n2. **文本属性**：\n    - vertical-align：垂直文本对齐\n    - text-decoration：规定添加到文本的装饰\n    - text-shadow：文本阴影效果\n    - white-space：空白符的处理\n    - unicode-bidi：设置文本的方向\n3. **盒子模型的属性**：width、height、margin、border、padding\n4. **背景属性**：background、background-color、background-image、background-repeat、background-position、background-attachment\n5. **定位属性**：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index\n6. **生成内容属性**：content、counter-reset、counter-increment\n7. **轮廓样式属性**：outline-style、outline-width、outline-color、outline\n8. **页面样式属性**：size、page-break-before、page-break-after\n9. **声音样式属性**：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during\n\n**二、有继承性的属性**\n\n1. **字体系列属性**\n- font-family：字体系列\n- font-weight：字体的粗细\n- font-size：字体的大小\n- font-style：字体的风格\n1. **文本系列属性**\n- text-indent：文本缩进\n- text-align：文本水平对齐\n- line-height：行高\n- word-spacing：单词之间的间距\n- letter-spacing：中文或者字母之间的间距\n- text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）\n- color：文本颜色\n1. **元素可见性**\n- visibility：控制元素显示隐藏\n1. **列表布局属性**\n- list-style：列表风格，包括list-style-type、list-style-image等\n1. **光标属性**\n- cursor：光标显示为何种形态",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.841Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363842",
    "title": "*3. display的属性值及其作用",
    "content": "### *3. display的属性值及其作用\n\n| **属性值**   | **作用**                                                   |\n| ------------ | ---------------------------------------------------------- |\n| none         | 元素不显示，并且会从文档流中移除。                         |\n| block        | 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。       |\n| inline       | 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。 |\n| inline-block | 默认宽度为内容宽度，可以设置宽高，同行显示。               |\n| list-item    | 像块类型元素一样显示，并添加样式列表标记。                 |\n| table        | 此元素会作为块级表格来显示。                               |\n| inherit      | 规定应该从父元素继承display属性的值。                      |",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363843",
    "title": "*4. display的block、inline和inline-block的区别",
    "content": "### *4. display的block、inline和inline-block的区别\n\n（1）**block：**会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；\n\n（2）**inline：**元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；\n\n（3）**inline-block：**将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。\n\n对于行内元素和块级元素，其特点如下：\n\n**（1）行内元素**\n\n- 设置宽高无效；\n- 可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；\n- 不会自动换行；\n\n**（2）块级元素**\n\n- 可以设置宽高；\n- 设置margin和padding都有效；\n- 可以自动换行；\n- 多个块状，默认排列从上到下。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363844",
    "title": "*5. 隐藏元素的方法有哪些",
    "content": "### *5. 隐藏元素的方法有哪些\n\n- **display: none**：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。\n- **visibility: hidden**：元素在页面中仍占据空间，但是不会响应绑定的监听事件。\n- **opacity: 0**：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。\n- **position: absolute**：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。\n- **z-index: 负值**：来使其他元素遮盖住该元素，以此来实现隐藏。\n- **clip/clip-path** ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。\n- **transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363845",
    "title": "*6. link和@import的区别",
    "content": "### *6. link和@import的区别\n\n两者都是外部引用CSS的方式，它们的区别如下：\n\n- link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。\n- link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。\n- link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。\n- link支持使用Javascript控制DOM去改变样式；而@import不支持。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363846",
    "title": "7. transition和animation的区别",
    "content": "### 7. transition和animation的区别\n\n- **transition是过渡属性**，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。\n- **animation是动画属性**，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363847",
    "title": "*8. display:none与visibility:hidden的区别",
    "content": "### *8. display:none与visibility:hidden的区别\n\n这两个属性都是让元素隐藏，不可见。两者**区别如下：**\n\n（1）**在渲染树中**\n\n- `display:none`会让元素完全从渲染树中消失，渲染时不会占据任何空间；\n- `visibility:hidden`不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。\n\n（2）是否是**继承属性**\n\n- `display:none`是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；\n- `visibility:hidden`是继承属性，子孙节点消失是由于继承了`hidden`，通过设置`visibility:visible`可以让子孙节点显示；\n\n（3）修改常规文档流中元素的 `display` 通常会造成文档的重排，但是修改`visibility`属性只会造成本元素的重绘；\n\n（4）如果使用读屏器，设置为`display:none`的内容不会被读取，设置为`visibility:hidden`的内容会被读取。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363848",
    "title": "*9. **伪元素和伪类的区别和作用？**",
    "content": "### *9. **伪元素和伪类的区别和作用？**\n\n- 伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：\n\n```CSS\np::before {content:\"第一章：\";}\np::after {content:\"Hot!\";}\np::first-line {background:red;}\np::first-letter {font-size:30px;}\n```\n- 伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：\n\n```CSS\na:hover {color: #FF00FF}\np:first-child {color: red}\n```\n\n**总结：**伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363849",
    "title": "10. 对requestAnimationframe的理解",
    "content": "### 10. 对requestAnimationframe的理解\n\n实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是**请求动画帧**。\n\nMDN对该方法的描述：\n\nwindow.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。\n\n**语法：** `window.requestAnimationFrame(callback);`  其中，callback是**下一次重绘之前更新动画帧所调用的函数**(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于**宏任务**，所以会在执行完微任务之后再去执行。\n\n**取消动画：**使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。\n\n**优势：**\n\n- **CPU节能**：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。\n- **函数节流**：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。\n- **减少DOM操作**：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。\n\n**setTimeout执行动画的缺点**：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：\n\n- settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；\n- settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363850",
    "title": "*11. 对盒模型的理解",
    "content": "### *11. 对盒模型的理解\n\nCSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820746-e10daafa-451a-454e-9705-f8c358769d5b.png#align=left&display=inline&height=366&margin=[object)\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820555-dc6ed390-d47e-412b-942a-857bbe5f280d.png#align=left&display=inline&height=368&margin=[object)\n\n盒模型都是由四个部分组成的，分别是margin、border、padding和content。\n\n标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：\n\n- 标准盒模型的width和height属性的范围只包含了content，\n- IE盒模型的width和height属性的范围包含了border、padding和content。\n\n可以通过修改元素的box-sizing属性来改变元素的盒模型：\n\n- `box-sizing: content-box`表示标准盒模型（默认值）\n- `box-sizing: border-box`表示IE盒模型（怪异盒模型）",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363851",
    "title": "12. 为什么有时候⽤**translate**来改变位置⽽不是定位？ ",
    "content": "### 12. 为什么有时候⽤**translate**来改变位置⽽不是定位？ \n\ntranslate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363852",
    "title": "13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？",
    "content": "### 13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？\n\n浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个`<li>`放在一行，这导致`<li>`换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。\n\n**解决办法：**\n\n（1）为`<li>`设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。\n\n（2）将所有`<li>`写在同一行。不足：代码不美观。\n\n（3）将`<ul>`内的字符尺寸直接设为0，即font-size:0。不足：`<ul>`中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。\n\n（4）消除`<ul>`的字符间隔letter-spacing:-8px，不足：这也设置了`<li>`内的字符间隔，因此需要将`<li>`内的字符间隔设为默认letter-spacing:normal。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363853",
    "title": "*14. CSS3中有哪些新特性",
    "content": "### *14. CSS3中有哪些新特性\n\n- 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\n- 圆角 （border-radius:8px）\n- 多列布局 （multi-column layout）\n- 阴影和反射 （Shadoweflect）\n- 文字特效 （text-shadow）\n- 文字渲染 （Text-decoration）\n- 线性渐变 （gradient）\n- 旋转 （transform）\n- 增加了旋转,缩放,定位,倾斜,动画,多背景",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363854",
    "title": "15. 替换元素的概念及计算规则",
    "content": "### 15. 替换元素的概念及计算规则\n\n通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。\n\n替换元素除了内容可替换这一特性以外，还有以下特性：\n\n- **内容的外观不受页面上的CSS的影响**：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。\n- **有自己的尺寸**：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如\n- **在很多CSS属性上有自己的一套表现规则**：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。\n- **所有的替换元素都是内联水平元素**：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。\n\n替换元素的尺寸从内而外分为三类：\n\n- **固有尺寸：** 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。\n- **HTML尺寸：** 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。\n- **CSS尺寸：** 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。\n\n这三层结构的计算规则具体如下：\n\n（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。\n\n（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。\n\n（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。\n\n（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。\n\n（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。\n\n（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363855",
    "title": "*16. 常见的图片格式及使用场景",
    "content": "### *16. 常见的图片格式及使用场景\n\n（1）**BMP**，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。\n\n（2）**GIF**是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。\n\n（3）**JPEG**是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。\n\n（4）**PNG-8**是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。\n\n（5）**PNG-24**是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。\n\n（6）**SVG**是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。\n\n（7）**WebP**是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。\n\n- 在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；\n- 在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；\n- WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363856",
    "title": "*17. 对 CSSSprites 的理解",
    "content": "### *17. 对 CSSSprites 的理解\n\nCSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。\n\n**优点：**\n\n- 利用`CSS Sprites`能很好地减少网页的http请求，从而大大提高了页面的性能，这是`CSS Sprites`最大的优点；\n- `CSS Sprites`能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。\n\n**缺点：**\n\n- 在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；\n- `CSSSprites`在开发的时候相对来说有点麻烦，需要借助`photoshop`或其他工具来对每个背景单元测量其准确的位置。\n- 维护方面：`CSS Sprites`在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的`CSS`，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动`CSS`。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363857",
    "title": "18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？",
    "content": "### 18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？\n\n以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px & 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；\n\n而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。\n\n对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。\n\n![img](https://cdn.nlark.com/yuque/0/2020/jpeg/1500604/1605252903834-27a1d90a-7e04-49bc-822a-dadcf974c141.jpeg#align=left&display=inline&height=1478&margin=[object)\n\n当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。\n\n还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:\n\n```JavaScript\nmy-image { background: (low.png); }\n@media only screen and (min-device-pixel-ratio: 1.5) {\n  #my-image { background: (high.png); }\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363858",
    "title": "19. **margin 和 padding 的使用场景**",
    "content": "### 19. **margin 和 padding 的使用场景**\n\n- 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\n- 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363859",
    "title": "*20. 对**line-height 的理解及其赋值方式**",
    "content": "### *20. 对**line-height 的理解及其赋值方式**\n\n**（1）line-height的概念：**\n\n- line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；\n- 如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；\n- 一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；\n- 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；\n- line-height 和 height 都能撑开一个高度；\n\n**（2）line-height 的赋值方式：**\n\n- 带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高\n- 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px\n- 百分比：将计算后的值传递给后代",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363860",
    "title": "21. CSS 优化和提高性能的方法有哪些？",
    "content": "### 21. CSS 优化和提高性能的方法有哪些？\n\n**加载性能：**\n\n（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。\n\n（2）css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。\n\n（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。\n\n**选择器性能：**\n\n（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；\n\n（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。\n\n（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。\n\n（4）尽量少的去对标签进行选择，而是用class。\n\n（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。\n\n（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。\n\n**渲染性能：**\n\n（1）慎重使用高性能属性：浮动、定位。\n\n（2）尽量减少页面重排、重绘。\n\n（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。\n\n（4）属性值为0时，不加单位。\n\n（5）属性值为浮动小数0.**，可以省略小数点之前的0。\n\n（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。\n\n（7）不使用@import前缀，它会影响css的加载速度。\n\n（8）选择器优化嵌套，尽量避免层级过深。\n\n（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。\n\n（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。\n\n（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。\n\n**可维护性、健壮性：**\n\n（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。\n\n（2）样式与内容分离：将css代码定义到外部css中。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363861",
    "title": "22. CSS预处理器/后处理器是什么？为什么要使用它们？",
    "content": "### 22. CSS预处理器/后处理器是什么？为什么要使用它们？\n\n**预处理器，**如：`less`，`sass`，`stylus`，用来预编译`sass`或者`less`，增加了`css`代码的复用性。层级，`mixin`， 变量，循环， 函数等对编写以及开发UI组件都极为方便。\n\n**后处理器，** 如： `postCss`，通常是在完成的样式表中根据`css`规范处理`css`，让其更加有效。目前最常做的是给`css`属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。\n\n`css`预处理器为`css`增加一些编程特性，无需考虑浏览器的兼容问题，可以在`CSS`中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让`css`更加的简洁，增加适应性以及可读性，可维护性等。\n\n其它`css`预处理器语言：`Sass（Scss）`, `Less`, `Stylus`, `Turbine`, `Swithch css`, `CSS Cacheer`, `DT Css`。\n\n使用原因：\n\n- 结构清晰， 便于扩展\n- 可以很方便的屏蔽浏览器私有语法的差异\n- 可以轻松实现多重继承\n- 完美的兼容了`CSS`代码，可以应用到老项目中",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363862",
    "title": "23. ::before 和 :after 的双冒号和单冒号有什么区别？",
    "content": "### 23. ::before 和 :after 的双冒号和单冒号有什么区别？\n\n（1）冒号(`:`)用于`CSS3`伪类，双冒号(`::`)用于`CSS3`伪元素。\n\n（2）`::before`就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于`dom`之中，只存在在页面之中。\n\n**注意：** `:before `和 `:after` 这两个伪元素，是在`CSS2.1`里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着`Web`的进化，在`CSS3`的规范里，伪元素的语法被修改成使用双冒号，成为`::before`、`::after`。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363863",
    "title": "24. display:inline-block 什么时候会显示间隙？",
    "content": "### 24. display:inline-block 什么时候会显示间隙？\n\n- 有空格时会有间隙，可以删除空格解决；\n- `margin`正值时，可以让`margin`使用负值解决；\n- 使用`font-size`时，可通过设置`font-size:0`、`letter-spacing`、`word-spacing`解决；",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363864",
    "title": "*25. 单行、多行文本溢出隐藏",
    "content": "### *25. 单行、多行文本溢出隐藏\n\n- 单行文本溢出\n\n```CSS\noverflow: hidden;            // 溢出隐藏\ntext-overflow: ellipsis;      // 溢出用省略号显示\nwhite-space: nowrap;         // 规定段落中的文本不进行换行\n```\n- 多行文本溢出\n\n```CSS\noverflow: hidden;            // 溢出隐藏\ntext-overflow: ellipsis;     // 溢出用省略号显示\ndisplay:-webkit-box;         // 作为弹性伸缩盒子模型显示。\n-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列\n-webkit-line-clamp:3;        // 显示的行数\n```\n\n注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个`-webkit-` 来兼容一部分浏览器。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363865",
    "title": "*26. Sass、Less 是什么？为什么要使用他们？ ",
    "content": "### *26. Sass、Less 是什么？为什么要使用他们？ \n\n他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。 \n\n**为什么要使用它们？** \n\n- 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。 \n- 可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363866",
    "title": "*27. 对媒体查询的理解？",
    "content": "### *27. 对媒体查询的理解？\n\n媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。 \n\n媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。 \n\n```JavaScript\n<!-- link元素中的CSS媒体查询 --> \n<link rel=\"stylesheet\" media=\"(max-width: 800px)\" href=\"example.css\" /> \n<!-- 样式表中的CSS媒体查询 --> \n<style> \n@media (max-width: 600px) { \n  .facet_sidebar { \n    display: none; \n  } \n}\n</style>\n```\n\n简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363867",
    "title": "28. 对 CSS 工程化的理解",
    "content": "### 28. 对 CSS 工程化的理解\n\nCSS 工程化是为了解决以下问题：\n\n1. **宏观设计**：CSS 代码如何组织、如何拆分、模块结构怎样设计？\n2. **编码优化**：怎样写出更好的 CSS？\n3. **构建**：如何处理我的 CSS，才能让它的打包结果最优？\n4. **可维护性**：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？\n\n以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：\n\n- 预处理器：Less、 Sass 等；\n- 重要的工程化插件： PostCss；\n- Webpack loader 等 。\n\n基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：\n\n**（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？**\n\n预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码：\n\n![](https://secure2.wostatic.cn/static/dSL4NB5L9Trspb7S3gZJKp/2.png?auth_key=1768101109-dzLpuzPnEMdr2rZ8SjhqoM-0-d6aca97d160b2ecbb362fb00c469fd1d)\n\n那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：\n\n1. 宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；\n2. 编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；\n3. 可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。\n\n这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：\n\n- 嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；\n- 支持定义 css 变量；\n- 提供计算函数；\n- 允许对代码片段进行 extend 和 mixin；\n- 支持循环语句的使用；\n- 支持将 CSS 文件模块化，实现复用。\n\n**（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？**\n\nPostCss 仍然是一个对 CSS 进行解析和处理的工具，它会对 CSS 做这样的事情：\n\n![](https://secure2.wostatic.cn/static/egy4XuqVC3v7MH1MiGi7db/2.png?auth_key=1768101110-3dmr6bQf1UXJ7rhkcEEemZ-0-0c1a968e37bba1c6145bc99737d7931c)\n\n它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。\n\nPostCss 在业务中的使用场景非常多：\n\n- 提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；\n- 当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 [Autoprefixer](https://github.com/postcss/autoprefixer) 插件可以帮助我们自动增加浏览器前缀；\n- 允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；\n\n**（3）Webpack 能处理 CSS 吗？如何实现？**\n\nWebpack 能处理 CSS 吗：\n\n- **Webpack 在裸奔的状态下，是不能处理 CSS 的**，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；\n- Webpack 在 loader 的辅助下，是可以处理 CSS 的。\n\n如何用 Webpack 实现对 CSS 的处理：\n\n- Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader\n- 注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：\n- - css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；\n    - style-loader：创建style标签，把 CSS 内容写入标签。\n\n在实际使用中，**css-loader 的执行顺序一定要安排在 style-loader 的前面**。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363868",
    "title": "29. 如何判断元素是否到达可视区域 ",
    "content": "### 29. 如何判断元素是否到达可视区域 \n\n以图片显示为例：\n\n- `window.innerHeight` 是浏览器可视区的高度；\n- `document.body.scrollTop || document.documentElement.scrollTop` 是浏览器滚动的过的距离；\n- `imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距离）；\n- 内容达到显示区域的：`img.offsetTop < window.innerHeight + document.body.scrollTop;`\n\n![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603966605254-fe880ec0-ebd1-4f94-b662-cdd5e5396c34.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_53%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363869",
    "title": "30. z-index属性在什么情况下会失效",
    "content": "### 30. z-index属性在什么情况下会失效\n\n通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。\n\nz-index属性在下列情况下会失效：\n\n- 父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；\n- 元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；\n- 元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；\n\n## 二、页面布局",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363870",
    "title": "*1. 常见的CSS布局单位",
    "content": "### *1. 常见的CSS布局单位\n\n常用的布局单位包括像素（`px`），百分比（`%`），`em`，`rem`，`vw/vh`。\n\n**（1）像素**（`px`）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：\n\n- **CSS像素**：为web开发者提供，在CSS中使用的一个抽象单位；\n- **物理像素**：只与设备的硬件密度有关，任何设备的物理像素都是固定的。\n\n**（2）百分比**（`%`），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。\n\n**（3）em和rem**相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：**em相对于父元素，rem相对于根元素。**\n\n- **em：** 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。\n- **rem：** rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。**作用**：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。\n\n**（4）vw/vh**是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。\n\n- vw：相对于视窗的宽度，视窗宽度是100vw；\n- vh：相对于视窗的高度，视窗高度是100vh；\n- vmin：vw和vh中的较小值；\n- vmax：vw和vh中的较大值；\n\n**vw/vh** 和百分比很类似，两者的区别：\n\n- 百分比（`%`）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)\n- vw/vm：相对于视窗的尺寸",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363871",
    "title": "*2. px、em、rem的区别及使用场景",
    "content": "### *2. px、em、rem的区别及使用场景\n\n**三者的区别：**\n\n- px是固定的像素，一旦设置了就无法因为适应页面大小而改变。\n- em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。\n- em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。\n\n**使用场景：**\n\n- 对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。\n- 对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363872",
    "title": "*3. 两栏布局的实现",
    "content": "### *3. 两栏布局的实现\n\n一般两栏布局指的是**左边一栏宽度固定，右边一栏宽度自适应**，两栏布局的具体实现：\n\n- 利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。\n\n```CSS\n.outer {\n  height: 100px;\n}\n.left {\n  float: left;\n  width: 200px;\n  background: tomato;\n}\n.right {\n  margin-left: 200px;\n  width: auto;\n  background: gold;\n}\n```\n- 利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。\n\n```CSS\n.left{\n     width: 100px;\n     height: 200px;\n     background: red;\n     float: left;\n }\n .right{\n     height: 300px;\n     background: blue;\n     overflow: hidden;\n }\n```\n- 利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。\n\n```CSS\n.outer {\n  display: flex;\n  height: 100px;\n}\n.left {\n  width: 200px;\n  background: tomato;\n}\n.right {\n  flex: 1;\n  background: gold;\n}\n```\n- 利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。\n\n```CSS\n.outer {\n  position: relative;\n  height: 100px;\n}\n.left {\n  position: absolute;\n  width: 200px;\n  height: 100px;\n  background: tomato;\n}\n.right {\n  margin-left: 200px;\n  background: gold;\n}\n```\n- 利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。\n\n```CSS\n.outer {\n  position: relative;\n  height: 100px;\n}\n.left {\n  width: 200px;\n  background: tomato;\n}\n.right {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 200px;\n  background: gold;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363873",
    "title": "*4. 三栏布局的实现",
    "content": "### *4. 三栏布局的实现\n\n三栏布局一般指的是页面中一共有三栏，**左右两栏宽度固定，中间自适应的布局**，三栏布局的具体实现：\n\n- 利用**绝对定位**，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。\n\n```CSS\n.outer {\n  position: relative;\n  height: 100px;\n}\n\n.left {\n  position: absolute;\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  position: absolute;\n  top: 0;\n  right: 0;\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.center {\n  margin-left: 100px;\n  margin-right: 200px;\n  height: 100px;\n  background: lightgreen;\n}\n```\n- 利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。\n\n```CSS\n.outer {\n  display: flex;\n  height: 100px;\n}\n\n.left {\n  width: 100px;\n  background: tomato;\n}\n\n.right {\n  width: 100px;\n  background: gold;\n}\n\n.center {\n  flex: 1;\n  background: lightgreen;\n}\n```\n- 利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式**，中间一栏必须放到最后：**\n\n```CSS\n.outer {\n  height: 100px;\n}\n\n.left {\n  float: left;\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  float: right;\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.center {\n  height: 100px;\n  margin-left: 100px;\n  margin-right: 200px;\n  background: lightgreen;\n}\n```\n- 圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。\n\n```CSS\n.outer {\n  height: 100px;\n  padding-left: 100px;\n  padding-right: 200px;\n}\n\n.left {\n  position: relative;\n  left: -100px;\n\n  float: left;\n  margin-left: -100%;\n\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  position: relative;\n  left: 200px;\n\n  float: right;\n  margin-left: -200px;\n\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.center {\n  float: left;\n\n  width: 100%;\n  height: 100px;\n  background: lightgreen;\n}\n```\n- 双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。\n\n```CSS\n.outer {\n  height: 100px;\n}\n\n.left {\n  float: left;\n  margin-left: -100%;\n\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  float: left;\n  margin-left: -200px;\n\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.wrapper {\n  float: left;\n\n  width: 100%;\n  height: 100px;\n  background: lightgreen;\n}\n\n.center {\n  margin-left: 100px;\n  margin-right: 200px;\n  height: 100px;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363874",
    "title": "*5. 水平垂直居中的实现",
    "content": "### *5. 水平垂直居中的实现\n\n- 利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要**考虑浏览器兼容问题。**\n\n```CSS\n.parent {\n    position: relative;\n}\n \n.child {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%,-50%);\n}\n```\n- 利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于**盒子有宽高**的情况：\n\n```CSS\n.parent {\n    position: relative;\n}\n \n.child {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    margin: auto;\n}\n```\n- 利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于**盒子宽高已知**的情况\n\n```CSS\n.parent {\n    position: relative;\n}\n \n.child {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -50px;     /* 自身 height 的一半 */\n    margin-left: -50px;    /* 自身 width 的一半 */\n}\n```\n- 使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要**考虑兼容的问题**，该方法在移动端用的较多：\n\n```CSS\n.parent {\n    display: flex;\n    justify-content:center;\n    align-items:center;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363875",
    "title": "6. 如何根据设计稿进行移动端适配？",
    "content": "### 6. 如何根据设计稿进行移动端适配？\n\n移动端适配主要有两个维度：\n\n- **适配不同像素密度，**针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；\n- **适配不同屏幕大小，**由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。\n\n为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363876",
    "title": "*7. 对Flex布局的理解及其使用场景",
    "content": "### *7. 对Flex布局的理解及其使用场景\n\nFlex是FlexibleBox的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，**子元素的float、clear和vertical-align属性将失效**。采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称\"项目\"。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。\n\n以下6个属性设置在**容器上**：\n\n- flex-direction属性决定主轴的方向（即项目的排列方向）。\n- flex-wrap属性定义，如果一条轴线排不下，如何换行。\n- flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n- justify-content属性定义了项目在主轴上的对齐方式。\n- align-items属性定义项目在交叉轴上如何对齐。\n- align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n以下6个属性设置在**项目上**：\n\n- order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n- flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n- flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n- flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n- flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。\n- align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n**简单来说：**\n\nflex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363877",
    "title": "*8. flex:1 表示什么",
    "content": "### *8. flex:1 表示什么\n\nflex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。flex:1 表示 flex: 1 1 0%**：**\n\n- 第一个参数表示: **flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大；**\n- 第二个参数表示: **flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小；**\n- 第三个参数表示: **flex-basis给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小。**",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363878",
    "title": "9. 响应式设计的概念及基本原理",
    "content": "### 9. 响应式设计的概念及基本原理\n\n响应式网站设计`（Responsive Web design`）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。\n\n关于原理： 基本原理是通过媒体查询`（@media）`查询检测不同的设备屏幕尺寸做处理。\n\n关于兼容： 页面头部必须有mate声明的`viewport`。\n\n```HTML\n<meta name=\"’viewport’\" content=\"”width=device-width,\" initial-scale=\"1.\" maximum-scale=\"1,user-scalable=no”\"/>\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363879",
    "title": "10. 实现“品” 字布局",
    "content": "### 10. 实现“品” 字布局\n\n品字布局就像下图这样：\n\n![](https://secure2.wostatic.cn/static/qNUJV3D2LJoesNEtijsLdY/2.png?auth_key=1768101118-wj7FMWqYgJTjjaQg2moKf-0-f0e1fdf2050c9c925762ba7c67c63377)\n\n**（1）浮动实现**\n\n我们可以使用定位实现，对于上面的1，使用magin属性让他水平居中；下面的两个使用浮动即可实现，其HTML结构如下：\n\n```HTML\n<div class=\"div1\">1</div>\n<div class=\"div2\">2</div>\n<div class=\"div3\">3</div>\n```\n\nCSS代码如下：\n\n```CSS\ndiv{ \n  width:100px; \n  height:100px; \n  font-size:40px; \n  line-height:100px; \n  color:#fff; \n  text-align:center;\n}\n\n.div1{ \n  background:red; \n  margin:0 auto;\n}\n\n.div2{ \n  background: green; \n  float:left; \n  margin-left: 50%;\n}\n\n.div3{ \n  background: blue; \n  float:left; \n  margin-left: -200px;\n}\n```\n\n该方法是在在三个盒子的宽高都知道的情况下才能实现的。\n\n**（2）inline-block实现**\n\nHTML结构如下：\n\n```CSS\n<div class=\"div1\">1</div>\n<div class=\"div2\">2</div>\n<div class=\"div3\">3</div>\n```\n\n这里将div设置为了inline-block，实际上和上面的float的作用是一眼的，就是让下面的两个块不换行。使用CSS样式如下：\n\n```CSS\ndiv{ \n  width:100px; \n  height:100px; \n  font-size:40px; \n  line-height:100px; \n  color:#fff; \n  text-align:center;\n}\n\n.div1{ \n  background:red; \n  margin:0 auto;\n}\n\n.div2{ \n  background: green; \n  display: inline-block;\n  margin-left: 50%;\n}\n\n.div3{ \n  background: blue; \n  display: inline-block;\n  margin-left: -200px;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363880",
    "title": "11. 实现九宫格布局",
    "content": "### 11. 实现九宫格布局\n\n实现效果如下：\n\n![](https://secure2.wostatic.cn/static/sqoWDdP76D4C18pRffzdJa/2.png?auth_key=1768101120-5KuoXzC7TPiUBdNnYyX7VM-0-f64d684e0b1d85efa9b06d17921e4efb)\n\n首先，定义好通用的HTML结构：\n\n```HTML\n<div class=\"box\">\n  <ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n    <li>6</li>\n    <li>7</li>\n    <li>8</li>\n    <li>9</li>\n  </ul>\n</div>\n```\n\n公共样式：\n\n```HTML\nul {\n  padding: 0;\n}\n\nli { \n  list-style: none;\n  text-align: center;\n  border-radius: 5px;\n  background: skyblue;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363881",
    "title": "# （1）flex实现",
    "content": "#### （1）flex实现\n\n对于九宫格布局，我首先想到的就是flex布局，flex布局实现九宫格很简单，需要设置一个flex-wrap: wrap;使得盒子在该换行的时候进行换行。\n\n由于我们给每个元素设置了下边距和右边距，所以最后同一列（3、6、9）的右边距和最后一行（7、8、9）的下边距撑大了ul，所以这里使用类型选择器来消除他们的影响。最终的实现代码如下：\n\n```CSS\nul {\n  display: flex;\n  flex-wrap: wrap;\n  width: 100%;\n  height: 100%;\n}\n\nli {\n  width: 30%;\n  height: 30%;\n  margin-right: 5%;\n  margin-bottom: 5%;\n}\n\nli:nth-of-type(3n){ \n  margin-right: 0;\n}\n\nli:nth-of-type(n+7){ \n  margin-bottom: 0;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363882",
    "title": "# （2）grid实现",
    "content": "#### （2）grid实现\n\ngrid布局相对于flex布局来说，实现九宫格就更加容易了，只需要设置几个属性即可：\n\n```CSS\nul {\n  width: 100%;\n  height: 100%;\n  display: grid;\n  grid-template-columns: 30% 30% 30%; \n  grid-template-rows: 30% 30% 30%; \n  grid-gap: 5%; \n}\n```\n\n其中grid-template-columns属性用来设置每一行中单个元素的宽度，grid-template-rows属性用来设置每一列中单个元素的高度，grid-gap属性用来设置盒子之间的间距。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363883",
    "title": "# （3）float实现",
    "content": "#### （3）float实现\n\n这里首先需要给父元素的div设置一个宽度，宽度值为：**盒子宽 * 3 + 间距 * 2；**然后给每个盒子设置固定的宽高，为了让他换行，可以使用float来实现，由于子元素的浮动，形成了BFC，所以父元素ul使用overflow:hidden；来消除浮动带来的影响。最终的实现代码如下：\n\n```CSS\nul {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n\nli {\n  float: left;\n  width: 30%;\n  height: 30%;\n  margin-right: 5%;\n  margin-bottom: 5%;\n}\n\nli:nth-of-type(3n){ \n  margin-right: 0;\n}\n\nli:nth-of-type(n+7){ \n  margin-bottom: 0;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363884",
    "title": "# （4）inline-block实现",
    "content": "#### （4）inline-block实现\n\n其实inline-block的作用和上面float的作用是一样的，都是用来让元素换行的，实现代码如下：\n\n```CSS\nul {\n  width: 100%;\n  height: 100%;\n  letter-spacing: -10px;\n}\n\nli {\n  width: 30%;\n  height: 30%;\n  display: inline-block;\n  margin-right: 5%;\n  margin-bottom: 5%;\n}\n\nli:nth-of-type(3n){ \n  margin-right: 0;\n}\n\nli:nth-of-type(n+7){ \n  margin-bottom: 0;\n}\n```\n\n需要注意的是，设置为inline-block的元素之间可能会出现间隙，就可能出现下面这种情况：\n\n![](https://secure2.wostatic.cn/static/cofmpLkWBYzrEBP43Qw7Mm/2.png?auth_key=1768101123-vv1AiP9Jmfufo5nQ3i2g8s-0-08cfcdd6580a76b27a6221628234f436)\n\n这里使用了letter-spacing属性来消除这种影响，该属性可以用来增加或减少字符间的空白（字符间距）。使用之后就正常了，出现了预期的效果。也可以给ul设置font-size: 0;来消除盒子之间的字符间距：\n\n```CSS\nul {\n  font-size: 0;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363885",
    "title": "# （5）table实现",
    "content": "#### （5）table实现\n\nHTML结构：\n\n```HTML\n<ul class=\"table\">\n  <li>\n    <div>1</div>\n    <div>2</div>\n    <div>3</div>\n  </li>\n  <li>\n    <div>4</div>\n    <div>5</div>\n    <div>6</div>\n  </li>\n  <li>\n    <div>7</div>\n    <div>8</div>\n    <div>9</div>\n  </li>\n</ul>\n```\n\ntable布局也不算太难，首先给父元素设置为table布局，然后使用border-spacing设置单元格之间的间距，最后将li设置为表格行，将div设置为表格单元格，CSS样式如下：\n\n```CSS\n.table {\n  width: 100%;\n  height: 100%;\n  display: table;\n  border-spacing: 10px;\n}\n\nli {\n  display: table-row; \n}\n\ndiv {\n  width: 30%;\n  height: 30%;\n  display: table-cell;\n  text-align: center;\n  border-radius: 5px;\n  background: skyblue;\n}\n```\n\n## 三、定位与浮动",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363886",
    "title": "*1. 为什么需要清除浮动？清除浮动的方式",
    "content": "### *1. 为什么需要清除浮动？清除浮动的方式\n\n**浮动的定义：** 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。\n\n**浮动的工作原理：**\n\n- 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）\n- 浮动元素碰到包含它的边框或者其他浮动元素的边框停留\n\n浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。\n\n**浮动元素引起的问题？**\n\n- 父元素的高度无法被撑开，影响与父元素同级的元素\n- 与浮动元素同级的非浮动元素会跟随其后\n- 若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构\n\n**清除浮动的方式如下：**\n\n- 给父级div定义`height`属性\n- 最后一个浮动元素之后添加一个空的div标签，并添加`clear:both`样式\n- 包含浮动元素的父级标签添加`overflow:hidden`或者`overflow:auto`\n- 使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**\n\n```CSS\n.clearfix:after{\n    content: \"\\200B\";\n    display: table; \n    height: 0;\n    clear: both;\n  }\n  .clearfix{\n    *zoom: 1;\n  }\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363887",
    "title": "2. 使用 clear 属性清除浮动的原理？",
    "content": "### 2. 使用 clear 属性清除浮动的原理？\n\n使用clear属性清除浮动，其语法如下：\n\n```CSS\nclear:none|left|right|both\n```\n\n如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。\n\n官方对clear属性解释：“**元素盒子的边不能和前面的浮动元素相邻**”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。\n\n还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“**前面的**”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。\n\n一般使用伪元素的方式清除浮动：\n\n```CSS\n.clear::after{\n  content:'';\n  display: block; \n  clear:both;\n}\n```\n\nclear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363888",
    "title": "*3. 对BFC的理解，如何创建BFC",
    "content": "### *3. 对BFC的理解，如何创建BFC\n\n先来看两个相关的概念：\n\n- Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。 \n- Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。 \n\n块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。\n\n通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。\n\n**创建BFC的条件：**\n\n- 根元素：body；\n- 元素设置浮动：float 除 none 以外的值；\n- 元素设置绝对定位：position (absolute、fixed)；\n- display 值为：inline-block、table-cell、table-caption、flex等；\n- overflow 值为：hidden、auto、scroll；\n\n**BFC的特点：**\n\n- 垂直方向上，自上而下排列，和文档流的排列方式一致。\n- 在BFC中上下相邻的两个容器的margin会重叠\n- 计算BFC的高度时，需要计算浮动元素的高度\n- BFC区域不会与浮动的容器发生重叠\n- BFC是独立的容器，容器内部元素不会影响外部元素\n- 每个元素的左margin值和容器的左border相接触\n\n**BFC的作用：**\n\n- **解决margin的重叠问题**：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。\n- **解决高度塌陷的问题**：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置`overflow:hidden`。\n- **创建自适应两栏布局**：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。\n\n```CSS\n.left{\n     width: 100px;\n     height: 200px;\n     background: red;\n     float: left;\n }\n .right{\n     height: 300px;\n     background: blue;\n     overflow: hidden;\n }\n \n<div class=\"left\"></div>\n<div class=\"right\"></div>\n```\n\n左侧设置`float:left`，右侧设置`overflow: hidden`。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363889",
    "title": "*4. 什么是margin重叠问题？如何解决？",
    "content": "### *4. 什么是margin重叠问题？如何解决？\n\n**问题描述：**\n\n两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，**浮动的元素和绝对定位**这种脱离文档流的元素的外边距不会折叠。重叠只会出现在**垂直方向**。\n\n**计算原则：**\n\n折叠合并后外边距的计算原则如下：\n\n- 如果两者都是正数，那么就去最大者\n- 如果是一正一负，就会正值减去负值的绝对值\n- 两个都是负值时，用0减去两个中绝对值大的那个\n\n**解决办法：**\n\n对于折叠的情况，主要有两种：**兄弟之间重叠**和**父子之间重叠**\n\n（1）兄弟之间重叠\n\n- 底部元素变为行内盒子：`display: inline-block`\n- 底部元素设置浮动：`float`\n- 底部元素的position的值为`absolute/fixed`\n\n（2）父子之间重叠\n\n- 父元素加入：`overflow: hidden`\n- 父元素添加透明边框：`border:1px solid transparent`\n- 子元素变为行内盒子：`display: inline-block`\n- 子元素加入浮动属性或定位",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363890",
    "title": "5. 元素的层叠顺序",
    "content": "### 5. 元素的层叠顺序\n\n层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603553952688-ad155942-9d1d-4e4b-86a7-0f7dca46e6d1.png#align=left&display=inline&height=360&margin=[object)\n\n对于上图，由上到下分别是：\n\n（1）背景和边框：建立当前层叠上下文元素的背景和边框。\n\n（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。\n\n（3）块级盒：文档流内非行内级非定位后代元素。\n\n（4）浮动盒：非定位浮动元素。\n\n（5）行内盒：文档流内行内级非定位后代元素。\n\n（6）z-index:0：层叠级数为0的定位元素。\n\n（7）正z-index：z-index属性值为正的定位元素。\n\n**注意:** 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363891",
    "title": "*6. position的属性有哪些，区别是什么",
    "content": "### *6. position的属性有哪些，区别是什么\n\nposition有以下属性值：\n\n| 属性值   | 概述                                                         |\n| -------- | ------------------------------------------------------------ |\n| absolute | 生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。 |\n| relative | 生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。 |\n| fixed    | 生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。 |\n| static   | 默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。 |\n| inherit  | 规定从父元素继承position属性的值                             |\n\n\n前面三者的定位方式如下：\n\n- **relative：**元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694939-58dfe7f7-2fc9-45e5-9961-a953f95496a7.png#align=left&display=inline&height=105&margin=[object)\n\n- **fixed：**元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694841-89472ba9-b236-4098-802f-c3c26ff49466.png#align=left&display=inline&height=117&margin=[object)\n\n- **absolute：**元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了`position:relative/absolute/fixed`的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694882-589670e0-cd52-41d4-a3ed-4ebbdfc88f32.png#align=left&display=inline&height=142&margin=[object)\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694842-2764d9ed-d5fe-45f4-8ede-34a73d237f94.png#align=left&display=inline&height=118&margin=[object)",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363892",
    "title": "*7. **display、float、position的关系**",
    "content": "### *7. **display、float、position的关系**\n\n（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。\n\n（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。\n\n（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。\n\n（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。\n\n总的来说，可以把它看作是一个类似优先级的机制，\"position:absolute\"和\"position:fixed\"优先级最高，有它存在的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是\"none\"的时候或者它是根元素的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363893",
    "title": "8. absolute与fixed共同点与不同点",
    "content": "### 8. absolute与fixed共同点与不同点\n\n**共同点：**\n\n- 改变行内元素的呈现方式，将display置为inline-block \n- 使元素脱离普通文档流，不再占据文档物理空间\n- 覆盖非定位文档元素\n\n**不同点：**\n\n- absolute与fixed的根元素不同，absolute的根元素可以设置，fixed根元素是浏览器。\n- 在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363894",
    "title": "9. 对 sticky 定位的理解",
    "content": "### 9. 对 sticky 定位的理解\n\nsticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：**position: sticky;** 基于用户的滚动位置来定位。\n\n粘性定位的元素是依赖于用户的滚动，在 **position:relative** 与 **position:fixed** 定位之间切换。它的行为就像 **position:relative;** 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n\n## 四、场景应用",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363895",
    "title": "*1. 实现一个三角形",
    "content": "### *1. 实现一个三角形\n\nCSS绘制三角形主要用到的是border属性，也就是边框。\n\n平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：\n\n```CSS\ndiv {\n    width: 0;\n    height: 0;\n    border: 100px solid;\n    border-color: orange blue red green;\n}\n```\n\n将元素的长宽都设置为0，显示出来的效果是这样的：\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245125-d60dca78-0577-4aa1-8809-f1d38594889a.png#align=left&display=inline&height=298&margin=[object)\n\n所以可以根据border这个特性来绘制三角形：\n\n**（1）三角1**\n\n```CSS\ndiv {\n    width: 0;\n    height: 0;\n    border-top: 50px solid red;\n    border-right: 50px solid transparent;\n    border-left: 50px solid transparent;\n}\n\n\n```\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245420-28c28277-5074-4725-9386-ffc955cf950a.png#align=left&display=inline&height=132&margin=[object)\n\n**（2）三角2**\n\n```CSS\ndiv {\n    width: 0;\n    height: 0;\n    border-bottom: 50px solid red;\n    border-right: 50px solid transparent;\n    border-left: 50px solid transparent;\n}\n\n\n```\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245172-36f955bd-075b-442a-b88b-6c084c66ed25.png#align=left&display=inline&height=133&margin=[object)\n\n**（3）三角3**\n\n```CSS\ndiv {\n    width: 0;\n    height: 0;\n    border-left: 50px solid red;\n    border-top: 50px solid transparent;\n    border-bottom: 50px solid transparent;\n}\n\n\n```\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245082-84a06746-dfc7-4782-a0d4-27d521aecac7.png#align=left&display=inline&height=195&margin=[object)\n\n**（4）三角4**\n\n```CSS\ndiv {\n    width: 0;\n    height: 0;\n    border-right: 50px solid red;\n    border-top: 50px solid transparent;\n    border-bottom: 50px solid transparent;\n}\n\n\n```\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245064-ecd01197-99fc-476e-897f-a4165b55792a.png#align=left&display=inline&height=191&margin=[object)\n\n**（5）三角5**\n\n```CSS\ndiv {\n    width: 0;\n    height: 0;\n    border-top: 100px solid red;\n    border-right: 100px solid transparent;\n}\n\n\n```\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245095-5b40d585-7e68-4bb0-aaef-6c8fce7d36b8.png#align=left&display=inline&height=177&margin=[object)\n\n还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363896",
    "title": "*2. 实现一个扇形",
    "content": "### *2. 实现一个扇形\n\n用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：\n\n```CSS\ndiv{\n    border: 100px solid transparent;\n    width: 0;\n    height: 0;\n    border-radius: 100px;\n    border-top-color: red;\n}\n\n\n```\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636444767-26da7bbe-5479-44e2-9088-50c9211d6c0d.png#align=left&display=inline&height=190&margin=[object)",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363897",
    "title": "3. 实现一个圆和半圆",
    "content": "### 3. 实现一个圆和半圆\n\n**（1）实现圆：**\n\n```CSS\ndiv {\n  background-color: red;\n  height: 100px;\n  width: 100px;\n  border-radius: 50%;\n}\n```\n\n**注意：**在使用border-radius时，使用50%和100%都可以得到一个圆，那这两个值到底有什么区别呢：border-radius的值是百分比的话，就相当于盒子的宽度和高度的百分比。如一个50px 150px的方形，如果border-radius设置为100%，则等价于：\n\n```CSS\nborder-radius: 50px/150px; 1\n```\n\n而border-radius又是由border-top-left-radius、border-top-right-radius、border-bottom-left-radius、border-bottom-right-radius组成，所有上面border-radius：100%又等价于：\n\n```CSS\nborder-top-left-radius: 100%; \nborder-top-right-radius: 100%; \nborder-bottom-left-radius: 100%; \nborder-bottom-right-radius: 100%;\n```\n\n或\n\n```CSS\nborder-top-left-radius: 50px 150px; \nborder-top-right-radius: 50px 150px; \nborder-bottom-left-radius: 50px 150px; \nborder-bottom-right-radius: 50px 150px; \n```\n\n为什么border-radius设置成100%和50%都能画成圆呢？因为，在W3C中对重合曲线做了规定：如果两个相邻的半径和超过了对应的盒子的边的长度，那么浏览器要重新计算以保证它们不重合。也就是说，如果相邻圆角的半径都设置成大于50%，那么浏览器会根据图形的实际情况做一些计算。因此，为了避免不必要的计算，建议使用border-radius: 50%。\n\n**（2）实现半圆：**\n\n```CSS\ndiv {\n  background-color: red;\n  width: 100px;\n  height: 50px;\n  border-radius: 0px 0px 100px 100px;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363898",
    "title": "*4. 实现一个宽高自适应的正方形",
    "content": "### *4. 实现一个宽高自适应的正方形\n\n- 利用vw来实现：\n\n```CSS\n.square {\n  width: 10%;\n  height: 10vw;\n  background: tomato;\n}\n```\n- 利用元素的margin/padding百分比是相对父元素width的性质来实现：\n\n```CSS\n.square {\n  width: 20%;\n  height: 0;\n  padding-top: 20%;\n  background: orange;\n}\n```\n- 利用子元素的margin-top的值来实现：\n\n```CSS\n.square {\n  width: 30%;\n  overflow: hidden;\n  background: yellow;\n}\n.square::after {\n  content: '';\n  display: block;\n  margin-top: 100%;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363899",
    "title": "*4. 画一个梯形",
    "content": "### *4. 画一个梯形\n\n```JavaScript\n<div class=\"trapezoid\"></div>\n```\n\n（1）实现一个直角梯形：\n\n```CSS\n.trapezoid {\n    height: 0;\n    width: 100px;\n    border-bottom: 100px solid red;\n    border-right: 40px solid transparent;\n}\n```\n\n效果：\n\n![](https://secure2.wostatic.cn/static/bF5z5QZty2xMtzFJ7cJmmb/image.png?auth_key=1768101140-hSjFRSv3ok3TjV6CqJ9irJ-0-3c75321b0bf1e24d74c00318627c780f)\n\n（2）实现一个等腰梯形\n\n```CSS\n.trapezoid {\n  height:0;\n  width:100px;\n  border-width:0 40px 100px 40px;\n  border-style:none solid solid;\n  border-color:transparent transparent red;\n}\n```\n\n效果：\n\n![](https://secure2.wostatic.cn/static/b4jXpoJLrVTQ4hhueMejit/image.png?auth_key=1768101141-2zjvD7ejKqSgZwPayZTQ8j-0-f86893a45717625e5d594b187e05d41e)",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363900",
    "title": "*5. 画一条0.5px的线",
    "content": "### *5. 画一条0.5px的线\n\n- **采用transform: scale()的方式**，该方法用来定义元素的2D 缩放转换：\n\n```CSS\ntransform: scale(0.5,0.5);\n```\n- **采用meta viewport的方式**\n\n```CSS\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5\"/>\n```\n\n这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363901",
    "title": "6. 设置小于12px的字体",
    "content": "### 6. 设置小于12px的字体\n\n在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。\n\n**解决办法：**\n\n- 使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。\n- 使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/...；\n- 使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363902",
    "title": "7. 如何解决 1px 问题？",
    "content": "### 7. 如何解决 1px 问题？\n\n1px 问题指的是：在一些 `Retina屏幕` 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：\n\n```HTML\nwindow.devicePixelRatio = 设备的物理像素 / CSS像素。\n```\n\n打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 `devicePixelRatio` 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2：\n\n![](https://secure2.wostatic.cn/static/fUhQQ19QxadSknV4aSTm5H/image.png?auth_key=1768101144-acUdSV43bG36Qii5XWo76p-0-6b06668db304ebf3b982192696d869be)\n\n这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。\n\n解决**1px 问题的三种思路：**",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363903",
    "title": "# 思路一：直接写 0.5px",
    "content": "#### 思路一：直接写 0.5px\n\n如果之前 1px 的样式这样写：\n\n```CSS\nborder:1px solid #333\n```\n\n可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：\n\n```JavaScript\n<div id=\"container\" data-device={{window.devicePixelRatio}}></div>\n```\n\n然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：\n\n```CSS\n#container[data-device=\"2\"] {\n  border:0.5px solid #333\n}\n```\n\n直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363904",
    "title": "# 思路二：伪元素先放大后缩小",
    "content": "#### 思路二：伪元素先放大后缩小\n\n这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。\n\n思路是**先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的**宽和高都设置为目标元素的两倍，border值设为 1px。**接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一**，间接地实现了 0.5px 的效果。\n\n代码如下：\n\n```CSS\n#container[data-device=\"2\"] {\n    position: relative;\n}\n#container[data-device=\"2\"]::after{\n      position:absolute;\n      top: 0;\n      left: 0;\n      width: 200%;\n      height: 200%;\n      content:\"\";\n      transform: scale(0.5);\n      transform-origin: left top;\n      box-sizing: border-box;\n      border: 1px solid #333;\n    }\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363905",
    "title": "# 思路三：viewport 缩放来解决",
    "content": "#### 思路三：viewport 缩放来解决\n\n这个思路就是对 meta 标签里几个关键属性下手：\n\n```HTML\n<meta name=\"viewport\" content=\"initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no\">\n```\n\n这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：\n\n```JavaScript\nconst scale = 1 / window.devicePixelRatio;\n// 这里 metaEl 指的是 meta 标签对应的 Dom\nmetaEl.setAttribute('content', `width=device-width,user-scalable=no,initial-scale=${scale},maximum-scale=${scale},minimum-scale=${scale}`);\n```\n\n这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768102144328",
    "title": "src和href的区别",
    "content": "<p><strong>回答：</strong></p>\n<p>**src 用于替换当前元素，href 建立链接（指向外部资源，不替换当前元素）**🍇</p>\n<p>（1）src</p>\n<pre><code class=\"language-HTML\">&lt;script src=\"”js.js”\"&gt;&lt;/script&gt;\n\n</code></pre>\n<p>src会阻塞浏览器后续资源的加载和解析，必须等它加载完才能继续（所以JS脚本通常放在页面底部，避免阻塞渲染）</p>\n<p>(2) href</p>\n<p>href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果在文档中添加</p>\n<pre><code class=\"language-HTML\">&lt;link href=”common.css” rel=”stylesheet”/&gt;\n</code></pre>\n<p>会并行下载资源,不阻塞当前文档的处理（所以CSS用link标签加载，不会影响页面渲染）</p>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:29:04.328Z",
    "updatedAt": "2026-01-11T03:29:04.328Z"
  },
  {
    "id": "1768102171094",
    "title": "对HTML语义化的理解",
    "content": "<p><strong>回答：</strong></p>\n<p>语义化是指<strong>用正确的标签做正确的事，根据内容结构选合适的标签</strong>。</p>\n<p>语义化的优点如下：</p>\n<ul>\n<li>对机器友好，搜索引擎能更好地抓取信息（有利于SEO），读屏软件也能正确识别；</li>\n<li>对开发者友好，代码结构清晰，维护起来方便</li>\n</ul>\n<p>常见的语义化标签：</p>\n<pre>&lt;header&gt;&lt;/header&gt;  头部<br>&lt;nav&gt;&lt;/nav&gt;  导航栏<br>&lt;section&gt;&lt;/section&gt;  区块（有语义化的div）<br>&lt;main&gt;&lt;/main&gt;  主要区域<br>&lt;article&gt;&lt;/article&gt;  主要内容<br>&lt;aside&gt;&lt;/aside&gt;  侧边栏<br>&lt;footer&gt;&lt;/footer&gt;  底部</pre>\n\n\n\n\n\n",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:29:31.094Z",
    "updatedAt": "2026-01-11T03:29:31.094Z"
  },
  {
    "id": "1768102201302",
    "title": "DOCTYPE(⽂档类型) 的作⽤",
    "content": "<p><strong>回答：</strong></p>\n<p>DOCTYPE是HTML文档第一行的声明，作用是告诉浏览器用什么规则解析网页。 它会影响浏览器的渲染模式：如果有正确的DOCTYPE，浏览器用“标准模式”（按W3C标准解析）；如果没有或写错了，可能会用“怪异模式”（兼容旧网页的松散规则）。</p>\n<p><strong>解析：</strong></p>\n<p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义<strong>来解析文档</strong>，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p>\n<p>浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p>\n<ul>\n<li><strong>CSS1Compat：标准模式（Strick mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li>\n<li><strong>BackCompat：怪异模式(混杂模式)(Quick mode)</strong>，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:30:01.303Z",
    "updatedAt": "2026-01-11T03:30:01.303Z"
  },
  {
    "id": "1768102255352",
    "title": "script标签中defer和async的区别",
    "content": "<p><strong>回答：</strong></p>\n<p>script标签的defer和async都是用来异步加载JS脚本的，不会阻塞HTML解析。 它们的区别主要在执行顺序和时机：</p>\n<ol>\n<li>执行顺序 ：async脚本谁先加载完谁先执行，没有固定顺序；defer脚本严格按HTML中的顺序执行。</li>\n<li>执行时机 ：async脚本加载完成后立即执行（可能打断HTML解析）；defer脚本等HTML完全解析完才执行。 比如统计代码适合用async，因为它不依赖其他脚本；而依赖jQuery的插件适合用defer，因为需要保证jQuery先加载执行。</li>\n</ol>\n<p><strong>解析：</strong></p>\n<p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p>\n<p>下图可以直观的看出三者之间的区别:</p><p><div>\n          <div class=\"image-wrapper relative inline-block\" data-id=\"img-1768102252180\">\n            <img src=\"/api/images/1768102252173_o3diu7.png\" alt=\"上传的图片\" style=\"max-width: 100%; height: auto;\">\n          </div>\n        </div><br></p>\n<p><img src=\"https://secure2.wostatic.cn/static/pDxTtgxUjNyhp3qBV3aAcY/image.png?auth_key=1768101425-aX29hbuz2r2AZX5MRR44Xo-0-d9e8040c0eafad75cea439b98ffc835f\" alt=\"\"></p>\n<p>其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。</p>\n<p><strong>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p>\n<ul>\n<li>**执行顺序：**多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li>\n<li><strong>脚本是否并行执行：async属性，表示</strong>后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:30:55.352Z",
    "updatedAt": "2026-01-11T03:30:55.352Z"
  },
  {
    "id": "1768102319079",
    "title": "常⽤的meta标签有哪些",
    "content": "<p>meta标签是HTML里用来描述网页属性的辅助标签，在里，不显示在页面上。 常用的有这几个：</p>\n<ol>\n<li>charset ：设置编码为UTF-8，避免乱码；</li>\n<li>keywords/description ：给搜索引擎看的关键词和简介，帮助SEO；</li>\n<li>viewport ：移动端适配必须加，让页面占满屏幕；</li>\n<li>refresh ：设置自动刷新或跳转页面；</li>\n<li>robots ：控制搜索引擎爬虫是否索引页面。</li>\n</ol>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:31:59.079Z",
    "updatedAt": "2026-01-11T03:31:59.079Z"
  },
  {
    "id": "1768102353830",
    "title": "HTML5有哪些更新",
    "content": "<p>HTML5的更新主要有这几个方面：</p>\n<ol>\n<li>语义化标签 ：新增header、nav、footer、article等，让HTML结构更清晰，对SEO友好；</li>\n<li>多媒体支持 ：audio、video标签原生播放音视频，告别Flash；</li>\n<li>表单增强 ：新的输入类型（email、date、color等）和属性（placeholder、required等），减少JS验证；</li>\n<li>客户端存储 ：localStorage和sessionStorage，比Cookie容量大、更安全；</li>\n<li>新API ：Canvas绘图、Geolocation定位、Web Worker后台线程、WebSocket实时通信等；</li>\n<li>移除过时元素 ：比如font、center、frameset这些纯表现或过时的标签。</li>\n</ol>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:32:33.830Z",
    "updatedAt": "2026-01-11T03:32:33.830Z"
  },
  {
    "id": "1768102379475",
    "title": "img的srcset属性的作⽤？",
    "content": "<p><strong>回答：</strong></p>\n<p>img的srcset属性是用来实现响应式图片的，让浏览器根据不同屏幕条件自动选图片。 主要解决两个问题：小屏幕加载大图片浪费流量，大屏幕加载小图片显示模糊。</p>\n<p><strong>解析：</strong></p>\n<p>响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：</p>\n<pre><code class=\"language-HTML\">&lt;img src=\"image-128.png\" srcset=\"image-256.png 2x\" /&gt;\n</code></pre>\n<p>使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。</p>\n<p>按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：</p>\n<pre><code class=\"language-HTML\">&lt;img src=\"image-128.png\"\n\n  srcset=\"image-128.png 128w, image-256.png 256w, image-512.png 512w\"\n\n  sizes=\"(max-width: 360px) 340px, 128px\" /&gt;\n</code></pre>\n<p>其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。</p>\n<p>sizes语法如下：</p>\n<p>sizes=\"[media query] [length], [media query] [length] ... \"</p>\n<p>sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。</p>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:32:59.475Z",
    "updatedAt": "2026-01-11T03:32:59.475Z"
  },
  {
    "id": "1768102401986",
    "title": "行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？",
    "content": "<ul>\n<li>行内元素有：<code>a b span img input select strong</code>；</li>\n<li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li>\n</ul>\n<p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p>\n<ul>\n<li>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li>\n<li>鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:33:21.986Z",
    "updatedAt": "2026-01-11T03:33:21.986Z"
  },
  {
    "id": "1768102421290",
    "title": "对 web worker 的理解",
    "content": "<p><strong>回答：</strong></p>\n<p>Web Worker是HTML5的后台线程技术，主要用来解决JS单线程阻塞的问题。</p>\n<p>它的特点是：运行在主线程之外，不影响页面响应；通过postMessage和onmessage与主线程通信；不能访问DOM/BOM，只能做计算。</p>\n<p><strong>解析：</strong></p>\n<p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>\n<p>如何创建 web worker：</p>\n<ol>\n<li>检测浏览器对于 web worker 的支持性</li>\n<li>创建 web worker 文件（js，回传函数等）</li>\n<li>创建 web worker 对象</li>\n</ol>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:33:41.290Z",
    "updatedAt": "2026-01-11T03:33:41.290Z"
  },
  {
    "id": "1768102449114",
    "title": "HTML5的离线储存怎么使用，它的工作原理是什么",
    "content": "<p><strong>回答：</strong></p>\n<p>HTML5离线存储是让网页断网也能访问的缓存机制，基于.appcache文件实现。</p>\n<p>工作原理：浏览器解析.appcache清单，缓存指定资源，离线时自动从本地加载。</p>\n<p><strong>解析：</strong></p>\n<p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>\n<p>**原理：**HTML5的离线存储是基于一个新建的 <code>.appcache</code> 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>\n<p><strong>使用方法：</strong></p>\n<p>（1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p>\n<pre><code class=\"language-HTML\">&lt;html lang=\"en\" manifest=\"index.manifest\"&gt;\n</code></pre>\n<p>（2）在 <code>cache.manifest</code> 文件中编写需要离线存储的资源：</p>\n<p>CACHE MANIFEST</p>\n<pre><code>#v0.11\n\nCACHE:\n\njs/app.js\n\ncss/style.css\n\nNETWORK:\n\nresourse/logo.png\n\nFALLBACK:\n\n/ /offline.html\n</code></pre>\n<ul>\n<li><strong>CACHE</strong>: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li>\n<li><strong>NETWORK</strong>: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li>\n<li><strong>FALLBACK</strong>: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li>\n</ul>\n<p>（3）在离线状态时，操作 <code>window.applicationCache</code> 进行离线缓存的操作。</p>\n<p><strong>如何更新缓存：</strong></p>\n<p>（1）更新 manifest 文件</p>\n<p>（2）通过 javascript 操作</p>\n<p>（3）清除浏览器缓存</p>\n<p><strong>注意事项：</strong></p>\n<p>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p>\n<p>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</p>\n<p>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</p>\n<p>（4）FALLBACK 中的资源必须和 manifest 文件同源。</p>\n<p>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</p>\n<p>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</p>\n<p>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:34:09.114Z",
    "updatedAt": "2026-01-11T03:34:09.114Z"
  },
  {
    "id": "1768102467001",
    "title": "浏览器是如何对 HTML5 的离线储存资源进行管理和加载？",
    "content": "<ul>\n<li><strong>在线的情况下</strong>，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</li>\n<li><strong>离线的情况下</strong>，浏览器会直接使用离线存储的资源。</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:34:27.001Z",
    "updatedAt": "2026-01-11T03:34:27.001Z"
  },
  {
    "id": "1768102479687",
    "title": " title与h1的区别、b与strong的区别、i与em的区别？",
    "content": "<ul>\n<li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</li>\n<li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li>\n<li><strong>i内容展示为斜体，em表示强调的文本</strong></li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:34:39.687Z",
    "updatedAt": "2026-01-11T03:34:39.687Z"
  },
  {
    "id": "1768102506000",
    "title": "iframe 有那些优点和缺点？",
    "content": "<p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>用来加载速度较慢的内容（如广告）</li>\n<li>可以使脚本可以并行下载</li>\n<li>支持跨域通信</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>iframe 会阻塞主页面的 onload 事件</li>\n<li>无法被一些搜索引擎索识别</li>\n<li>会产生很多页面，不容易管理</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:35:06.000Z",
    "updatedAt": "2026-01-11T03:35:06.000Z"
  },
  {
    "id": "1768102529198",
    "title": "label 的作用是什么？如何使用？",
    "content": "<p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p>\n<ul>\n<li>使用方法1：</li>\n</ul>\n<pre><code class=\"language-HTML\">&lt;label for=\"mobile\"&gt;Number:&lt;/label&gt;\n\n&lt;input type=\"text\" id=\"mobile\"/&gt;\n</code></pre>\n<ul>\n<li>使用方法2：</li>\n</ul>\n<pre><code class=\"language-HTML\">&lt;label&gt;Date:&lt;input type=\"text\"/&gt;&lt;/label&gt;\n</code></pre>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:35:29.198Z",
    "updatedAt": "2026-01-11T03:35:29.198Z"
  },
  {
    "id": "1768102548154",
    "title": "Canvas和SVG的区别",
    "content": "<p><strong>（1）SVG：</strong></p>\n<p>SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p>\n<p>其特点如下：</p>\n<ul>\n<li>不依赖分辨率</li>\n<li>支持事件处理器</li>\n<li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>\n<li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>\n<li>不适合游戏应用</li>\n</ul>\n<p><strong>（2）Canvas：</strong></p>\n<p>Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p>\n<p>其特点如下：</p>\n<ul>\n<li>依赖分辨率</li>\n<li>不支持事件处理器</li>\n<li>弱的文本渲染能力</li>\n<li>能够以 .png 或 .jpg 格式保存结果图像</li>\n<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>\n</ul>\n<p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:35:48.154Z",
    "updatedAt": "2026-01-11T03:35:48.154Z"
  },
  {
    "id": "1768102569520",
    "title": " head 标签有什么作用，其中什么标签必不可少？",
    "content": "<p><strong>回答：</strong></p>\n<p>定义文档头部，包含文档的元信息、样式、脚本等非内容数据</p>\n<ul>\n<li><strong>必需标签</strong>：<code>&lt;title&gt;</code>（定义文档标题，浏览器标签栏显示）</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>&lt;head&gt; 标签用于定义文档的头部，它是所有头部元素的容器。&lt;head&gt; 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p>\n<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>\n<p>下面这些标签可用在 head 部分：&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;。</p>\n<p>其中 &lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。</p>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:36:09.520Z",
    "updatedAt": "2026-01-11T03:36:09.520Z"
  },
  {
    "id": "1768102602575",
    "title": "文档声明（Doctype）和<!Doctype html>有何作用? 严格模式与混杂模式如何区分？它们有何意义?",
    "content": "<p><strong>回答：</strong></p>\n<p><strong>DOCTYPE作用</strong>：告诉浏览器HTML文档的版本，指导正确解析</p>\n<ul>\n<li><strong>&lt;!doctype html&gt;作用</strong>：触发浏览器进入标准模式，使用HTML5标准解析页面</li>\n<li><strong>严格模式</strong>：按W3C标准解析，保证跨浏览器一致性</li>\n<li><strong>混杂模式</strong>：浏览器用旧版方式解析，兼容老网站</li>\n<li><strong>区分</strong>：看DOCTYPE是否存在且正确，HTML5无严格/混杂之分</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>**文档声明的作用：**文档声明是为了告诉浏览器，当前<code>HTML</code>文档使用什么版本的<code>HTML</code>来写的，这样浏览器才能按照声明的版本来正确的解析。</p>\n<p><strong>&lt;!Doctype html&gt;的作用：</strong><code>&lt;!doctype html&gt;</code> 的作用就是让浏览器进入标准模式，使用最新的 <code>HTML5</code> 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。</p>\n<p><strong>严格模式与混杂模式的区分：</strong></p>\n<ul>\n<li><strong>严格模式</strong>： 又称为标准模式，指浏览器按照<code>W3C</code>标准解析代码；</li>\n<li><strong>混杂模式</strong>： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；</li>\n</ul>\n<p><strong>区分</strong>：网页中的<code>DTD</code>，直接影响到使用的是严格模式还是浏览模式，可以说<code>DTD</code>的使用与这两种方式的区别息息相关。</p>\n<ul>\n<li>如果文档包含严格的<code>DOCTYPE</code> ，那么它一般以严格模式呈现（<strong>严格 DTD ——严格模式</strong>）；</li>\n<li>包含过渡 <code>DTD</code> 和 <code>URI</code> 的 <code>DOCTYPE</code> ，也以严格模式呈现，但有过渡 <code>DTD</code> 而没有 <code>URI</code> （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（<strong>有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式</strong>）；</li>\n<li><code>DOCTYPE</code> 不存在或形式不正确会导致文档以混杂模式呈现（<strong>DTD不存在或者格式不正确——混杂模式</strong>）；</li>\n<li><code>HTML5</code> 没有 <code>DTD</code> ，因此也就没有严格模式与混杂模式的区别，<code>HTML5</code> 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(<strong>HTML5 没有严格和混杂之分</strong>)。</li>\n</ul>\n<p>总之，<strong>严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。</strong></p>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:36:42.575Z",
    "updatedAt": "2026-01-11T03:36:42.575Z"
  },
  {
    "id": "1768102634257",
    "title": "浏览器乱码的原因是什么？如何解决？",
    "content": "<p><strong>回答：</strong></p>\n<p><strong>原因</strong>：编码不一致（如页面用gbk，内容用utf-8）</p>\n<ul>\n<li><strong>解决方法</strong>：统一使用UTF-8编码（设置<code>&lt;meta charset=\"UTF-8\"&gt;</code>）</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p><strong>产生乱码的原因：</strong></p>\n<ul>\n<li>网页源代码是<code>gbk</code>的编码，而内容中的中文字是<code>utf-8</code>编码的，这样浏览器打开即会出现<code>html</code>乱码，反之也会出现乱码；</li>\n<li><code>html</code>网页编码是<code>gbk</code>，而程序从数据库中调出呈现是<code>utf-8</code>编码的内容也会造成编码乱码；</li>\n<li>浏览器不能自动检测网页编码，造成网页乱码。</li>\n</ul>\n<p><strong>解决办法：</strong></p>\n<ul>\n<li>使用软件编辑HTML网页内容；</li>\n<li>如果网页设置编码是<code>gbk</code>，而数据库储存数据编码格式是<code>UTF-8</code>，此时需要程序查询数据库数据显示数据前进程序转码；</li>\n<li>如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:37:14.257Z",
    "updatedAt": "2026-01-11T03:37:14.257Z"
  },
  {
    "id": "1768102651880",
    "title": "渐进增强和优雅降级之间的区别",
    "content": "<p><strong>回答：</strong></p>\n<p><strong>渐进增强</strong>：从基础功能开始，逐步为高级浏览器添加增强效果</p>\n<ul>\n<li><strong>优雅降级</strong>：先实现完整功能，再为旧浏览器添加兼容性处理</li>\n<li><strong>区别</strong>：渐进增强向前看（基础功能优先），优雅降级向后看（完整功能优先）</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p><strong>（1）渐进增强（progressive enhancement）</strong>：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。</p>\n<p><strong>（2）优雅降级 graceful degradation</strong>： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p>\n<p><strong>两者区别：</strong></p>\n<ul>\n<li>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；</li>\n<li>降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。</li>\n</ul>\n<p>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p>\n<p>“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:37:31.880Z",
    "updatedAt": "2026-01-11T03:37:31.880Z"
  },
  {
    "id": "1768102668156",
    "title": "说一下 HTML5 drag API",
    "content": "<p><strong>回答：</strong></p>\n<p>提供元素拖放功能的事件接口</p>\n<ul>\n<li>主要事件：dragstart（开始拖放）、dragover（拖放移动中）、drop（完成放置）</li>\n<li>作用：实现自定义拖放交互效果</li>\n</ul>\n<p><strong>解析：</strong></p>\n<ul>\n<li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</li>\n<li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</li>\n<li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</li>\n<li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</li>\n<li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li>\n<li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li>\n<li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:37:48.156Z",
    "updatedAt": "2026-01-11T03:37:48.156Z"
  },
  {
    "id": 1768103122903,
    "title": "JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。",
    "content": "其中 Symbol 和 BigInt 是ES6 中新增的数据类型：<br><br>  - Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。<br>  - BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。<br><br>  这些数据可以分为原始数据类型和引用数据类型：<br><br>  - 栈：原始数据类型（Undefined、Null、Boolean、Number、String）<br>  - 堆：引用数据类型（对象、数组和函数）<br><br>  两种类型的区别在于<strong>存储位置的不同：</strong><br><br>  - 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br>  - 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。<br><br>  堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：<br><br>  - 在数据结构中，栈中数据的存取方式为先进后出。<br>  - 堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。<br><br>  在操作系统中，内存被分为栈区和堆区：<br><br>  - 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>  - 堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122904,
    "title": "数据类型检测的方式有哪些",
    "content": "<strong>回答：</strong>检测的方法typeof，instanceof，<br><br>  <strong>（1）typeof</strong><br><br>  console.log(typeof 2);               // number<br><br>  console.log(typeof true);            // boolean<br><br>  console.log(typeof 'str');           // string<br><br>  console.log(typeof []);              // object<br><br>  console.log(typeof function(){});    // function<br><br>  console.log(typeof {});              // object<br><br>  console.log(typeof undefined);       // undefined<br><br>  console.log(typeof null);            // object<br><br>  其中数组、对象、null都会被判断为object，其他判断都正确。<br><br>  <strong>（2）instanceof</strong><br><br>  <code>instanceof</code>可以正确判断对象的类型，其内部运行机制是<strong>判断在其原型链中能否找到该类型的原型</strong>。<br><br>  console.log(2 instanceof Number);                    // false<br><br>  console.log(true instanceof Boolean);                // false<br><br>  console.log('str' instanceof String);                // false<br><br>  console.log([] instanceof Array);                    // true<br><br>  console.log(function(){} instanceof Function);       // true<br><br>  console.log({} instanceof Object);                   // true<br><br>  可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。<br><br>  <strong>（3） constructor</strong><br><br>  console.log((2).constructor === Number); // true<br><br>  console.log((true).constructor === Boolean); // true<br><br>  console.log(('str').constructor === String); // true<br><br>  console.log(([]).constructor === Array); // true<br><br>  console.log((function() {}).constructor === Function); // true<br><br>  console.log(({}).constructor === Object); // true<br><br>  <code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：<br><br>  function Fn(){};<br><br>  Fn.prototype = new Array();<br><br>  var f = new Fn();<br><br>  console.log(f.constructor===Fn);    // false<br><br>  console.log(f.constructor===Array); // true<br><br>  <strong>（4）Object.prototype.toString.call()</strong><br><br>  <code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：<br><br>  var a = Object.prototype.toString;<br><br>  console.log(a.call(2));<br><br>  console.log(a.call(true));<br><br>  console.log(a.call('str'));<br><br>  console.log(a.call([]));<br><br>  console.log(a.call(function(){}));<br><br>  console.log(a.call({}));<br><br>  console.log(a.call(undefined));<br><br>  console.log(a.call(null));<br><br>  同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？<br><br>  这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122905,
    "title": "判断数组的方式有哪些",
    "content": "<strong>回答：</strong>Array.isArray()<br><br>  - 通过Object.prototype.toString.call()做判断<br><br>    Object.prototype.toString.call(obj).slice(8,-1) === 'Array';<br><br>  - 通过原型链做判断<br><br>    obj.<strong>proto</strong> === Array.prototype;<br><br>  - 通过ES6的Array.isArray()做判断<br><br>    Array.isArrray(obj);<br><br>  - 通过instanceof做判断<br><br>    obj instanceof Array<br><br>  - 通过Array.prototype.isPrototypeOf<br><br>    Array.prototype.isPrototypeOf(obj)",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122906,
    "title": "null和undefined区别",
    "content": "<strong>回答：</strong><br><br>  Undefined 与 Null 都是单值基本类型，分别表示“未定义”和“空对象”；未赋值的变量默认 undefined，可能返回对象的变量可初始化为 null。undefined 不是保留字。typeof null 返回 \"object\"，双等判等 true，三等判等 false。<br><br>  <strong>解析：</strong><br><br>  首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。<br><br>  undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。<br><br>  undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。<br><br>  当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122907,
    "title": "typeof null 的结果是什么，为什么？",
    "content": "typeof null 的结果是Object。<br><br>  在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：<br><br>  000: object   - 当前存储的数据指向一个对象。<br><br>  <pre><code class=\"language-\">  1: int      - 当前存储的数据是一个 31 位的有符号整数。<br>  </code></pre><br><br>  010: double   - 当前存储的数据指向一个双精度的浮点数。<br><br>  100: string   - 当前存储的数据指向一个字符串。<br><br>  110: boolean  - 当前存储的数据是布尔值。<br><br>  如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。<br><br>  有两种特殊数据类型：<br><br>  - undefined的值是 (-2)30(一个超出整数范围的数字)；<br>  - null 的值是机器码 NULL 指针(null 指针的值全是 0)<br><br>  那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122908,
    "title": "intanceof 操作符的实现原理及实现",
    "content": "instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。<br><br>  <pre><code class=\"language-JavaScript\">  function myInstanceof(left, right) {<br>    // 获取对象的原型<br>    let proto = Object.getPrototypeOf(left)<br>    // 获取构造函数的 prototype 对象<br>    let prototype = right.prototype; <br>    // 判断构造函数的 prototype 对象是否在对象的原型链上<br>    while (true) {<br>      if (!proto) return false;<br>      if (proto === prototype) return true;<br>      // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型<br>      proto = Object.getPrototypeOf(proto);<br>    }<br>  }<br>  </code></pre>",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122909,
    "title": "为什么0.1+0.2 ! == 0.3，如何让其相等",
    "content": "<strong>回答：</strong><br><br>  0.1、0.2 在 IEEE 754 双精度浮点里都是无限循环二进制，被截断后两者相加比 0.3 大了一点，所以严格相等失败。<br><br>  在开发过程中遇到类似这样的问题：<br><br>  <pre><code class=\"language-JavaScript\">  let n1 = 0.1, n2 = 0.2<br>  <br>  console.log(n1 + n2)  // 0.30000000000000004<br>  </code></pre><br><br>  这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：<br><br>  (n1 + n2).toFixed(2) // 注意，toFixed为四舍五入<br><br>  <code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？<br><br>  计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？<br><br>  一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。<br><br>  根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。<br><br>  下面看一下<strong>双精度数是如何保存</strong>的：<br><br>  ![img](https://secure2.wostatic.cn/static/pCGRc9PjpLgeq5omzhNHCS/2.png?auth_key=1768101739-d9NKEsjJoVkfM8XffF7Zjp-0-e590195345b18d627242749b5d47ec2d)<br><br>  - 第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位<br>  - 第二部分（绿色）：用来存储指数（exponent），占用11位<br>  - 第三部分（红色）：用来存储小数（fraction），占用52位<br><br>  对于0.1，它的二进制为：<br><br>  <pre><code class=\"language-JavaScript\">  0.00011001100110011001100110011001100110011001100110011001 10011...<br>  </code></pre><br><br>  转为科学计数法（科学计数法的结果就是浮点数）：<br><br>  <pre><code class=\"language-JavaScript\">  1.1001100110011001100110011001100110011001100110011001<em>2^-4<br>  </code></pre><br><br>  可以看出0.1的符号位为0，指数位为-4，小数位为：<br><br>  <pre><code class=\"language-JavaScript\">  1001100110011001100110011001100110011001100110011001<br>  </code></pre><br><br>  那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？<br><br>  IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。<br><br>  - 当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。<br>  - 当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。<br>  - 当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。<br><br>  对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.<br><br>  所以，0.1表示为：<br><br>  <pre><code class=\"language-JavaScript\">  0 1111111011 1001100110011001100110011001100110011001100110011001<br>  </code></pre><br><br>  说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？<br><br>  对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3<br><br>  <pre><code class=\"language-JavaScript\">  function numberepsilon(arg1,arg2){                   <br>    return Math.abs(arg1 - arg2) < Number.EPSILON;        <br>  }        <br>  <br>  console.log(numberepsilon(0.1 + 0.2, 0.3)); // true<br>  </code></pre><br><br>  在开发过程中遇到类似这样的问题：<br><br>  <pre><code class=\"language-JavaScript\">  let n1 = 0.1, n2 = 0.2<br>  <br>  console.log(n1 + n2)  // 0.30000000000000004<br>  </code></pre><br><br>  这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：<br><br>  (n1 + n2).toFixed(2) // 注意，toFixed为四舍五入<br><br>  <code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？<br><br>  计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？<br><br>  一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。<br><br>  根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。<br><br>  下面看一下<strong>双精度数是如何保存</strong>的：<br><br>  ![img](https://secure2.wostatic.cn/static/pCGRc9PjpLgeq5omzhNHCS/2.png?auth_key=1768101739-f5wjWyMF1D2EqrYuc5vek3-0-158fa760c99770de48bb8db9d8616ee4)<br><br>  - 第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位<br>  - 第二部分（绿色）：用来存储指数（exponent），占用11位<br>  - 第三部分（红色）：用来存储小数（fraction），占用52位<br><br>  对于0.1，它的二进制为：<br><br>  <pre><code class=\"language-JavaScript\">  0.00011001100110011001100110011001100110011001100110011001 10011...<br>  </code></pre><br><br>  转为科学计数法（科学计数法的结果就是浮点数）：<br><br>  <pre><code class=\"language-JavaScript\">  1.1001100110011001100110011001100110011001100110011001</em>2^-4<br>  </code></pre><br><br>  可以看出0.1的符号位为0，指数位为-4，小数位为：<br><br>  <pre><code class=\"language-JavaScript\">  1001100110011001100110011001100110011001100110011001<br>  </code></pre><br><br>  那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？<br><br>  IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。<br><br>  - 当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。<br>  - 当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。<br>  - 当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。<br><br>  对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.<br><br>  所以，0.1表示为：<br><br>  <pre><code class=\"language-JavaScript\">  0 1111111011 1001100110011001100110011001100110011001100110011001<br>  </code></pre><br><br>  说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？<br><br>  对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3<br><br>  <pre><code class=\"language-JavaScript\">  function numberepsilon(arg1,arg2){                   <br>    return Math.abs(arg1 - arg2) < Number.EPSILON;        <br>  }        <br>  <br>  console.log(numberepsilon(0.1 + 0.2, 0.3)); // true<br>  </code></pre>",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122910,
    "title": "如何获取安全的 undefined 值？",
    "content": "<strong>回答：</strong>undefined 不是保留字，可被重新赋值导致判断失效；<code>void <任意表达式></code> 永远返回“原装”undefined，故用 <code>void 0</code> 即可安全获取真 undefined。<br><br>  因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122911,
    "title": "typeof NaN 的结果是什么？number",
    "content": "NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。<br><br>  typeof NaN; // \"number\"<br><br>  NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122912,
    "title": "isNaN 和 Number.isNaN 函数的区别？",
    "content": "<li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li><br>  - 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122913,
    "title": "其他值到字符串的转换规则？",
    "content": "<li>Null 和 Undefined 类型 ，null 转换为 \"null\"，undefined 转换为 \"undefined\"，</li><br>  - Boolean 类型，true 转换为 \"true\"，false 转换为 \"false\"。<br>  - Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。<br>  - Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。<br>  - 对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如\"[object Object]\"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122914,
    "title": "其他值到数字值的转换规则？",
    "content": "<li>Undefined 类型的值转换为 NaN。</li><br>  - Null 类型的值转换为 0。<br>  - Boolean 类型的值，true 转换为 1，false 转换为 0。<br>  - String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。<br>  - Symbol 类型的值不能转换为数字，会报错。<br>  - 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。<br><br>  为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。<br><br>  如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122915,
    "title": "其他值到布尔类型的值的转换规则？",
    "content": "以下这些是假值：<br><br>  • undefined<br><br>  • null<br><br>  • false<br><br>  • +0、-0 和 NaN<br><br>  • \"\"<br><br>  假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122916,
    "title": "|| 和 && 操作符的返回值？",
    "content": "|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。<br><br>  - 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。<br>  - && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。<br><br>  || 和 && 返回它们其中一个操作数的值，而非条件判断的结果",
    "categoryId": "1768000001003",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122917,
    "title": "[Object.is](http://Object.is)() 与比较操作符 “===”、“==” 的区别？",
    "content": "<li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li><br>  - 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。<br>  - 使用 [Object.is](http://Object.is) 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122918,
    "title": "什么是 JavaScript 中的包装类型？",
    "content": "就是通过toUpperCase属性将小写的字母转化成大写的<br><br>  在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：<br><br>  <pre><code class=\"language-JavaScript\">  const a = \"abc\";<br>  a.length; // 3<br>  a.toUpperCase(); // \"ABC\"<br>  </code></pre><br><br>  在访问<code>'abc'.length</code>时，JavaScript 将<code>'abc'</code>在后台转换成<code>String('abc')</code>，然后再访问其<code>length</code>属性。<br><br>  JavaScript也可以使用<code>Object</code>函数显式地将基本类型转换为包装类型：<br><br>  <pre><code class=\"language-JavaScript\">  var a = 'abc'<br>  Object(a) // String {\"abc\"}<br>  </code></pre><br><br>  也可以使用<code>valueOf</code>方法将包装类型倒转成基本类型：<br><br>  <pre><code class=\"language-JavaScript\">  var a = 'abc'<br>  var b = Object(a)<br>  var c = b.valueOf() // 'abc'<br>  </code></pre><br><br>  看看如下代码会打印出什么：<br><br>  <pre><code class=\"language-JavaScript\">  var a = new Boolean( false );<br>  if (!a) {<br>    console.log( \"Oops\" ); // never runs<br>  }<br>  </code></pre><br><br>  答案是什么都不会打印，因为虽然包裹的基本类型是<code>false</code>，但是<code>false</code>被包裹成包装类型后就成了对象，所以其非值为<code>false</code>，所以循环体中的内容不会运行。",
    "categoryId": "1768000001003",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122919,
    "title": "JavaScript 中如何进行隐式类型转换？",
    "content": "首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：<br><br>  <pre><code class=\"language-JavaScript\">  /*<em><br>  - @obj 需要转换的对象<br>  - @type 期望的结果类型<br>  </em>/<br>  <br>  ToPrimitive(obj,type)<br>  </code></pre><br><br>  <code>type</code>的值为<code>number</code>或者<code>string</code>。<br><br>  <strong>（1）当</strong><code>type</code><strong>为</strong><code>number</code><strong>时规则如下：</strong><br><br>  - 调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；<br>  - 调用<code>obj</code>的<code>toString</code>方法，后续同上；<br>  - 抛出<code>TypeError</code> 异常。<br><br>  <strong>（2）当</strong><code>type</code><strong>为</strong><code>string</code><strong>时规则如下：</strong><br><br>  - 调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；<br>  - 调用<code>obj</code>的<code>valueOf</code>方法，后续同上；<br>  - 抛出<code>TypeError</code> 异常。<br><br>  可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：<br><br>  - 如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；<br>  - 其他情况下，<code>type</code>默认为<code>number</code>。<br><br>  总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：<br><br>  <pre><code class=\"language-JavaScript\">  var objToNumber = value => Number(value.valueOf().toString())<br>  objToNumber([]) === 0<br>  objToNumber({}) === NaN<br>  </code></pre><br><br>  而 JavaScript 中的隐式类型转换主要发生在<code>+、-、<em>、/</code>以及<code>==、>、<</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。<br><br>  以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：<br><br>  1. <code>+</code><strong>操作符</strong><code>+</code>操作符的两边有至少一个<code>string</code>类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。<br><br>  <pre><code class=\"language-JavaScript\">  1 + '23' // '123'<br>  <br>  1 + false // 1 <br>  <br>  1 + Symbol() // Uncaught TypeError: Cannot convert a Symbol value to a number<br>  <br>  '1' + false // '1false'<br>  <br>  false + true // 1<br>  </code></pre><br><br>  1. <code>-</code><strong>、</strong><code></em></code><strong>、</strong><code>/</code><strong>操作符</strong><code>NaN</code>也是一个数字<br><br>  <pre><code class=\"language-JavaScript\">  1 <em> '23' // 23<br>  <br>  1 </em> false // 0<br>  <br>  1 / 'aa' // NaN<br>  </code></pre><br><br>  1. <strong>对于</strong><code>==</code><strong>操作符</strong><br><br>     操作符两边的值都尽量转成<code>number</code>：<br><br>  <pre><code class=\"language-JavaScript\">  3 == true // false, 3 转为number为3，true转为number为1<br>  <br>  '0' == false //true, '0'转为number为0，false转为number为0<br>  <br>  '0' == 0 // '0'转为number为0<br>  </code></pre><br><br>  1. <strong>对于</strong><code><</code><strong>和</strong><code>></code><strong>比较符</strong><br><br>     如果两边都是字符串，则比较字母表顺序：<br><br>  <pre><code class=\"language-JavaScript\">  'ca' < 'bd' // false<br>  'a' < 'b' // true<br>  '12' < 13 // true<br>  false > -1 // true<br>  var a = {}<br>  a > 2 // false<br>  a.valueOf() // {}, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步<br>  a.toString() // \"[object Object]\"，现在是一个字符串了<br>  Number(a.toString()) // NaN，根据上面 < 和 > 操作符的规则，要转换成数字<br>  NaN > 2 //false，得出比较结果<br>  var a = {name:'Jack'}<br>  var b = {age: 18}<br>  a + b // \"[object Object][object Object]\"<br>  a.valueOf() // {}，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步<br>  a.toString() // \"[object Object]\"<br>  b.valueOf() // 同理<br>  b.toString() // \"[object Object]\"<br>  a + b // \"[object Object][object Object]\"<br>  </code></pre>",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122920,
    "title": "`+` 操作符什么时候用于字符串的拼接？",
    "content": "根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。<br><br>  简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。<br><br>  那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。",
    "categoryId": "1768000001003",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122922,
    "title": "为什么会有**BigInt**的提案？",
    "content": "JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122923,
    "title": "object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别",
    "content": "<pre><code class=\"language-JavaScript\">  // 扩展运算符：<br>  let outObj = {<br>    inObj: {a: 1, b: 2}<br>  }<br>  <br>  let newObj = {...outObj}<br>  <br>  newObj.inObj.a = 2<br>  <br>  console.log(outObj) // {inObj: {a: 2, b: 2}}<br>  // Object.assign():<br>  <br>  let outObj = {<br>    inObj: {a: 1, b: 2}<br>  }<br>  <br>  let newObj = Object.assign({}, outObj)<br>  <br>  newObj.inObj.a = 2<br>  <br>  console.log(outObj) // {inObj: {a: 2, b: 2}}<br>  </code></pre><br><br>  可以看到，两者都是浅拷贝。<br><br>  - Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。<br>  - 扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122924,
    "title": "如何判断一个对象是空对象",
    "content": "通过Object.keys判断长度即可<br><br>  - 使用JSON自带的.stringify方法来判断：<br><br>  <pre><code class=\"language-JavaScript\">  if(Json.stringify(Obj) == '{}' ){<br>    console.log('空对象');<br>   }<br>  </code></pre><br><br>  - 使用ES6新增的方法Object.keys()来判断：<br><br>  <pre><code class=\"language-JavaScript\">  if(Object.keys(Obj).length < 0){<br>    console.log('空对象');<br>  }<br>  </code></pre><br><br>  运算过程如下：<br><br>  又比如：<br><br>  其对比过程如下：<br><br>  以上说的是基本类型的隐式转换，而对象会被<code>ToPrimitive</code>转换为基本类型再进行转换：<br><br>  其他情况下，转换为数字再比较：",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": "1768103310582",
    "title": "1. 反问环节提问？",
    "content": "<ul>\n<li>我的直接上级他们的上级都是什么样的管理风格？</li>\n<li>您期望我在最初的一个月 / 三个月能够完成什么？</li>\n<li>您对在这里工作最满意的地方是？</li>\n<li>公司常用的技术栈是什么？</li>\n<li>是否会使用静态代码分析呢？</li>\n<li>公司是否有技术分享交流活动？有的话，多久一次呢？</li>\n<li>公司有标准的开发环境吗？是强制的吗？</li>\n<li>业务需求有没有文档记录？是如何记录的？</li>\n<li>公司技术团队的架构和人员组成？</li>\n<li>公司目前招人的原因是？（因为产品发展 or 新产品 or人员波动？)</li>\n<li>绩效评估流程是怎样的？</li>\n<li>您上一次注意到有人成长是什么时候？他们在哪方面成长了？</li>\n</ul>",
    "categoryId": "1768000001013",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:30.582Z",
    "updatedAt": "2026-01-11T03:48:30.582Z"
  },
  {
    "id": 1768103319816,
    "title": "1*. new操作符的实现原理",
    "content": "<strong>new操作符的执行过程：</strong><br><br>（1）首先创建了一个新的空对象<br><br>（2）设置原型，将对象的原型设置为函数的 prototype 对象。<br><br>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br><br>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。<br><br>具体实现：<br><br><pre><code class=\"language-JavaScript\">function objectFactory() {<br>  let newObject = null;<br>  let constructor = Array.prototype.shift.call(arguments);<br>  let result = null;<br>  // 判断参数是否是一个函数<br>  if (typeof constructor !== \"function\") {<br>    console.error(\"type error\");<br>    return;<br>  }<br>  // 新建一个空对象，对象的原型为构造函数的 prototype 对象<br>  newObject = Object.create(constructor.prototype);<br>  // 将 this 指向新建对象，并执行函数<br>  result = constructor.apply(newObject, arguments);<br>  // 判断返回对象<br>  let flag = result && (typeof result === \"object\" || typeof result === \"function\");<br>  // 判断返回结果<br>  return flag ? result : newObject;<br>}<br>// 使用方法<br>objectFactory(构造函数, 初始化参数);<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319817,
    "title": "map和Object的区别",
    "content": "<strong>Map和Object的核心区别：</strong>Map是ES6新增的数据结构，键可以是任意类型（对象、函数等），保持插入顺序，频繁添加删除操作性能更好，没有原型链污染，直接通过size属性获取大小；Object是传统对象，键主要是字符串或Symbol，不保证顺序，可直接JSON序列化，有原型链，需要通过Object.keys().length计算大小。<br><br>|          | Map                                                          | Object                                                       |<br>| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |<br>| 意外的键 | Map默认情况不包含任何键，只包含显式插入的键。                | Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。 |<br>| 键的类型 | Map的键可以是任意值，包括函数、对象或任意基本类型。          | Object 的键必须是 String 或是Symbol。                        |<br>| 键的顺序 | Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。 | Object 的键是无序的                                          |<br>| Size     | Map 的键值对个数可以轻易地通过size 属性获取                  | Object 的键值对个数只能手动计算                              |<br>| 迭代     | Map 是 iterable 的，所以可以直接被迭代。                     | 迭代Object需要以某种方式获取它的键然后才能迭代。             |<br>| 性能     | 在频繁增删键值对的场景下表现更好。                           | 在频繁添加和删除键值对的场景下未作出优化。                   |",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319818,
    "title": "map和weakMap的区别",
    "content": "<strong>Map和WeakMap的核心区别：</strong>Map的键可以是任意类型（对象、函数、基本类型），使用强引用阻止垃圾回收，可遍历，有size属性和clear方法，适合通用数据存储但需手动清理避免内存泄漏；WeakMap的键只能是对象，使用弱引用不阻止垃圾回收，不可遍历，无size属性和clear方法，能自动清理避免内存泄漏。<br><br><strong>（1）Map</strong><br><br>map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。<br><br>实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：<br><br><pre><code class=\"language-JavaScript\">const map = [<br>     [\"name\",\"张三\"],<br>     [\"age\",18],<br>]<br></code></pre><br><br>Map数据结构有以下操作方法：<br><br><li><strong>size</strong>： <code>map.size</code> 返回Map结构的成员总数。</li><br><li><strong>set(key,value)</strong>：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li><br><li><strong>get(key)</strong>：该方法读取key对应的键值，如果找不到key，返回undefined。</li><br><li><strong>has(key)</strong>：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li><br><li><strong>delete(key)</strong>：该方法删除某个键，返回true，如果删除失败，返回false。</li><br><li><strong>clear()</strong>：map.clear()清除所有成员，没有返回值。</li><br><br>Map结构原生提供是三个遍历器生成函数和一个遍历方法<br><br><li>keys()：返回键名的遍历器。</li><br><li>values()：返回键值的遍历器。</li><br><li>entries()：返回所有成员的遍历器。</li><br><li>forEach()：遍历Map的所有成员。</li><br><br><pre><code class=\"language-JavaScript\">const map = new Map([<br>     [\"foo\",1],<br>     [\"bar\",2],<br>])<br>for(let key of map.keys()){<br>    console.log(key);  // foo bar<br>}<br>for(let value of map.values()){<br>     console.log(value); // 1 2<br>}<br>for(let items of map.entries()){<br>    console.log(items);  // [\"foo\",1]  [\"bar\",2]<br>}<br>map.forEach( (value,key,map) => {<br>     console.log(key,value); // foo 1    bar 2<br>})<br></code></pre><br><br><strong>（2）WeakMap</strong><br><br>WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。<strong>其键必须是对象</strong>，原始数据类型不能作为key值，而值可以是任意的。<br><br>该对象也有以下几种方法：<br><br><li><strong>set(key,value)</strong>：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li><br><li><strong>get(key)</strong>：该方法读取key对应的键值，如果找不到key，返回undefined。</li><br><li><strong>has(key)</strong>：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li><br><li><strong>delete(key)</strong>：该方法删除某个键，返回true，如果删除失败，返回false。</li><br><br>其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。<br><br>WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。<br><br>而WeakMap的<strong>键名所引用的对象都是弱引用</strong>，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的<strong>键名对象和所对应的键值对会自动消失，不用手动删除引用</strong>。<br><br><strong>总结：</strong><br><br><li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><br><li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319819,
    "title": "JavaScript有哪些内置对象",
    "content": "全局的对象（ global objects ）或称标准内置对象，不要和 \"全局对象（global object）\" 混淆。这里说的全局的对象是说在<br><br>全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。<br><br><strong>标准内置对象的分类：</strong><br><br>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。<br><br>例如 Infinity、NaN、undefined、null 字面量<br><br>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。<br><br>例如 eval()、parseFloat()、parseInt() 等<br><br>（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。<br><br>例如 Object、Function、Boolean、Symbol、Error 等<br><br>（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。<br><br>例如 Number、Math、Date<br><br>（5）字符串，用来表示和操作字符串的对象。<br><br>例如 String、RegExp<br><br>（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array<br><br>（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。<br><br>例如 Map、Set、WeakMap、WeakSet<br><br>（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。<br><br>例如 SIMD 等<br><br>（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。<br><br>例如 JSON 等<br><br>（10）控制抽象对象<br><br>例如 Promise、Generator 等<br><br>（11）反射<br><br>例如 Reflect、Proxy<br><br>（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。<br><br>例如 Intl、Intl.Collator 等<br><br>（13）WebAssembly<br><br>（14）其他<br><br>例如 arguments<br><br><strong>总结：</strong><br><br>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319820,
    "title": "常用的正则表达式有哪些？",
    "content": "<pre><code class=\"language-JavaScript\">// （1）匹配 16 进制颜色值<br>var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;<br><br>// （2）匹配日期，如 yyyy-mm-dd 格式<br>var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;<br><br>// （3）匹配 qq 号<br>var regex = /^[1-9][0-9]{4,10}$/g;<br><br>// （4）手机号码正则<br>var regex = /^1[34578]\\d{9}$/g;<br><br>// （5）用户名正则<br>var regex = /^[a-zA-Z\\$][a-zA-Z0-9_\\$]{4,16}$/;<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319821,
    "title": "对JSON的理解",
    "content": "<strong>回答：</strong><br><br>JSON 是一种轻量级跨语言数据交换格式，常用于前后端数据传递。虽然JSON语法基于JavaScript，但两者不同：JSON格式更严格，属性值不能是函数或NaN等。<br><br>JavaScript提供了两种转换的方法：<br><br><li>JSON.stringify() ：将JS对象序列化为JSON字符串，用于发送数据到后端</li><br><li>JSON.parse() ：将JSON字符串解析为JS对象，用于接收后端数据</li><br><br><strong>解析：</strong><br><br>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。<br><br>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为<br><br>JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。<br><br>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。<br><br>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，<br><br><li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li><br><li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319822,
    "title": "7*. JavaScript脚本延迟加载的方式有哪些？",
    "content": "JavaScript延迟加载的方式有async属性，setTimeout延迟方法<br><br>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。<br><br>一般有以下几种方式：<br><br><li><strong>defer 属性：</strong> 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li><br><li><strong>async 属性：</strong> 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li><br><li><strong>动态创建 DOM 方式：</strong> 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li><br><li><strong>使用 setTimeout 延迟方法：</strong> 设置一个定时器来延迟加载js脚本文件</li><br><li><strong>让 JS 最后加载：</strong> 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319823,
    "title": "JavaScript 类数组对象的定义？",
    "content": "<strong>回答：</strong><br><br>类数组对象是指具有数字索引和length属性但不是Array实例的对象，类数组对象可以通过索引访问元素并获取长度，但不能直接使用push、map等数组方法，需要通过Array.from()、展开运算符或Array.prototype.slice.call()等方法转换为真正的数组后才能使用完整的数组方法。<br><br>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。<br><br>常见的类数组转换为数组的方法有这样几种：<br><br>（1）通过 call 调用数组的 slice 方法来实现转换<br><br><pre><code class=\"language-JavaScript\">Array.prototype.slice.call(arrayLike);<br></code></pre><br><br>（2）通过 call 调用数组的 splice 方法来实现转换<br><br><pre><code class=\"language-JavaScript\">Array.prototype.splice.call(arrayLike, 0);<br></code></pre><br><br>（3）通过 apply 调用数组的 concat 方法来实现转换<br><br><pre><code class=\"language-JavaScript\">Array.prototype.concat.apply([], arrayLike);<br></code></pre><br><br>（4）通过 Array.from 方法来实现转换<br><br><pre><code class=\"language-JavaScript\">Array.from(arrayLike);<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319824,
    "title": "数组有哪些原生方法？",
    "content": "<li>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li><br><li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li><br><li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li><br><li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li><br><li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li><br><li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li><br><li>数组归并方法 reduce() 和 reduceRight() 方法</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319825,
    "title": "*Unicode、UTF-8、UTF-16、UTF-32的区别？**",
    "content": "<h4>（1）Unicode</h4><br><br>在说<code>Unicode</code>之前需要先了解一下<code>ASCII</code>码：ASCII 码（<code>American Standard Code for Information Interchange</code>）称为美国标准信息交换码。<br><br><li>它是基于拉丁字母的一套电脑编码系统。</li><br><li>它定义了一个用于代表常见字符的字典。</li><br><li>它包含了\"A-Z\"(包含大小写)，数据\"0-9\" 以及一些常见的符号。</li><br><li>它是专门为英语而设计的，有128个编码，对其他语言无能为力</li><br><br><code>ASCII</code>码可以表示的编码有限，要想表示其他语言的编码，还是要使用<code>Unicode</code>来表示，可以说<code>Unicode</code>是<code>ASCII</code> 的超集。<br><br><code>Unicode</code>全称 <code>Unicode Translation Format</code>，又叫做统一码、万国码、单一码。<code>Unicode</code> 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。<br><br><code>Unicode</code>的实现方式（也就是编码方式）有很多种，常见的是<strong>UTF-8</strong>、<strong>UTF-16</strong>、<strong>UTF-32</strong>和<strong>USC-2</strong>。<br><br><h4>（2）UTF-8</h4><br><br><code>UTF-8</code>是使用最广泛的<code>Unicode</code>编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容<code>ASCII</code>码的128个字符。<br><br><strong>注意：</strong> <code>UTF-8</code> 是一种编码方式，<code>Unicode</code>是一个字符集合。<br><br><code>UTF-8</code>的编码规则：<br><br><li>对于<strong>单字节</strong>的符号，字节的第一位为0，后面的7位为这个字符的<code>Unicode</code>编码，因此对于英文字母，它的<code>Unicode</code>编码和<code>ACSII</code>编码一样。</li><br><li>对于<strong>n字节</strong>的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的<code>Unicode</code>码 。</li><br><br>来看一下具体的<code>Unicode</code>编号范围与对应的<code>UTF-8</code>二进制格式 ：<br><br>| 编码范围（编号对应的十进制数）  | 二进制格式                          |<br>| ------------------------------- | ----------------------------------- |<br>| 0x00—0x7F （0-127）             | 0xxxxxxx                            |<br>| 0x80—0x7FF （128-2047）         | 110xxxxx 10xxxxxx                   |<br>| 0x800—0xFFFF  （2048-65535）    | 1110xxxx 10xxxxxx 10xxxxxx          |<br>| 0x10000—0x10FFFF  （65536以上） | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |<br><br>那该如何通过具体的<code>Unicode</code>编码，进行具体的<code>UTF-8</code>编码呢？<strong>步骤如下：</strong><br><br><li>找到该<code>Unicode</code>编码的所在的编号范围，进而找到与之对应的二进制格式</li><br><li>将<code>Unicode</code>编码转换为二进制数（去掉最高位的0）</li><br><li>将二进制数从右往左一次填入二进制格式的<code>X</code>中，如果有<code>X</code>未填，就设为0</li><br><br>来看一个实际的例子：<br><br>“<strong>马</strong>” 字的<code>Unicode</code>编码是：<code>0x9A6C</code>，整数编号是<code>39532</code><br><br>（1）首选确定了该字符在第三个范围内，它的格式是 <code>1110xxxx 10xxxxxx 10xxxxxx</code><br><br>（2）39532对应的二进制数为<code>1001 1010 0110 1100</code><br><br>（3）将二进制数填入X中，结果是：<code>11101001 10101001 10101100</code><br><br><h4>（3）UTF-16</h4><br><br><strong>1. 平面的概念</strong><br><br>在了解<code>UTF-16</code>之前，先看一下<strong>平面</strong>的概念：<br><br><code>Unicode</code>编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放<strong>65536</strong>（216）个字符，这称为一个<strong>平面</strong>，目前总共有17 个平面。<br><br>最前面的一个平面称为<strong>基本平面</strong>，它的码点从<strong>0 — 216</strong>-1，写成16进制就是<code>U+0000 — U+FFFF</code>，那剩下的16个平面就是<strong>辅助平面</strong>，码点范围是 <code>U+10000—U+10FFFF</code>。<br><br><strong>2. UTF-16 概念：</strong><br><br><code>UTF-16</code>也是<code>Unicode</code>编码集的一种编码形式，把<code>Unicode</code>字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。<code>Unicode</code>字符的码位需要1个或者2个16位长的码元来表示，因此<code>UTF-16</code>也是用变长字节表示的。<br><br><strong>3. UTF-16 编码规则：</strong><br><br><li>编号在 <code>U+0000—U+FFFF</code> 的字符（常用字符集），直接用两个字节表示。</li><br><li>编号在 <code>U+10000—U+10FFFF</code> 之间的字符，需要用四个字节表示。</li><br><br><strong>4. 编码识别</strong><br><br>那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？<br><br><code>UTF-16</code> 编码肯定也考虑到了这个问题，在基本平面内，从 <code>U+D800 — U+DFFF</code> 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。<br><br>辅助平面共有 <strong>220</strong> 个字符位，因此表示这些字符至少需要 20 个二进制位。<code>UTF-16</code> 将这 20 个二进制位分成两半，前 10 位映射在 <code>U+D800 — U+DBFF</code>，称为<strong>高位</strong>（H），后 10 位映射在 <code>U+DC00 — U+DFFF</code>，称为<strong>低位</strong>（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。<br><br>因此，当遇到两个字节时，发现它的码点在 <code>U+D800 —U+DBFF</code>之间，就可以知道，它后面的两个字节的码点应该在 <code>U+DC00 — U+DFFF</code> 之间，这四个字节必须放在一起进行解读。<br><br><strong>5. 举例说明</strong><br><br>以 \"<strong>𡠀</strong>\" 字为例，它的 <code>Unicode</code> 码点为 <code>0x21800</code>，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：<br><br><li>首先计算超出部分的结果：<code>0x21800 - 0x10000</code></li><br><li>将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：<code>0001000110 0000000000</code></li><br><li>将得到的两个10位二进制数分别对应到两个区间中</li><br><li><code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>， 将<code>0001000110</code>填充在它的后10 个二进制位，得到 <code>1101100001000110</code>，转成 16 进制数为 <code>0xD846</code>。同理，低位为 <code>0xDC00</code>，所以这个字的<code>UTF-16</code> 编码为 <code>0xD846 0xDC00</code></li><br><br><h4>（4） UTF-32</h4><br><br><code>UTF-32</code> 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。<br><br>比如“<strong>马</strong>” 字的Unicode编号是：<code>U+9A6C</code>，整数编号是<code>39532</code>，直接转化为二进制：<code>1001 1010 0110 1100</code>，这就是它的UTF-32编码。<br><br><h4>（5）总结</h4><br><br><strong>Unicode、UTF-8、UTF-16、UTF-32有什么区别？</strong><br><br><li><code>Unicode</code> 是编码字符集（字符集），而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是字符集编码（编码规则）；</li><br><li><code>UTF-16</code> 使用变长码元序列的编码方式，相较于定长码元序列的<code>UTF-32</code>算法更复杂，甚至比同样是变长码元序列的<code>UTF-8</code>也更为复杂，因为其引入了独特的<strong>代理对</strong>这样的代理机制；</li><br><li><code>UTF-8</code>需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而<code>UTF-16</code>不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；</li><br><li>如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用<code>UTF-8</code>就比<code>UTF-16</code>节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么<code>UTF-16</code>就占优势了，可以节省很多空间；</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319826,
    "title": "常见的位运算符有哪些？其计算规则是什么？",
    "content": "现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。<br><br>常见的位运算有以下几种：<br><br>| 运算符 | 描述 | 运算规则                                                 | 两个位都为0时，结果才为0 |<br>| ------ | ---- | -------------------------------------------------------- | ------------------------ |<br>| <code>&</code>    | 与   | 两个位都为1时，结果才为1                                 |                          |<br>| <code>      | </code>    | 或                                                       |                          |<br>| <code>^</code>    | 异或 | 两个位相同为0，相异为1                                   |                          |<br>| <code>~</code>    | 取反 | 0变1，1变0                                               |                          |<br>| <code><<</code>   | 左移 | 各二进制位全部左移若干位，高位丢弃，低位补0              |                          |<br>| <code>>></code>   | 右移 | 各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃 |                          |<br><br><h4>1. 按位与运算符（&）</h4><br><br><strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。<br><br><strong>运算规则：</strong><br><br><pre><code class=\"language-JavaScript\">0 & 0 = 0  <br>0 & 1 = 0  <br>1 & 0 = 0  <br>1 & 1 = 1<br></code></pre><br><br>总结：两位同时为1，结果才为1，否则结果为0。<br><br>例如：3&5 即：<br><br><pre><code class=\"language-JavaScript\">0000 0011 <br>   0000 0101 <br> = 0000 0001<br></code></pre><br><br>因此 3&5 的值为1。<br><br>注意：负数按补码形式参加按位与运算。<br><br><strong>用途：</strong><br><br><strong>（1）判断奇偶</strong><br><br>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i & 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。<br><br><strong>（2）清零</strong><br><br>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。<br><br><h4>2. 按位或运算符（|）</h4><br><br><strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。<br><br><strong>运算规则：</strong><br><br><pre><code class=\"language-JavaScript\">0 | 0 = 0<br>0 | 1 = 1  <br>1 | 0 = 1  <br>1 | 1 = 1<br></code></pre><br><br>总结：参加运算的两个对象只要有一个为1，其值为1。<br><br>例如：3|5即：<br><br><pre><code class=\"language-JavaScript\">0000 0011<br>  0000 0101 <br>= 0000 0111<br></code></pre><br><br>因此，3|5的值为7。<br><br>注意：负数按补码形式参加按位或运算。<br><br><h4>3. 异或运算符（^）</h4><br><br><strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。<br><br><strong>运算规则：</strong><br><br><pre><code class=\"language-JavaScript\">0 ^ 0 = 0  <br>0 ^ 1 = 1  <br>1 ^ 0 = 1  <br>1 ^ 1 = 0<br></code></pre><br><br>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。<br><br>例如：3|5即：<br><br><pre><code class=\"language-JavaScript\">0000 0011<br>  0000 0101 <br>= 0000 0110<br></code></pre><br><br>因此，3^5的值为6。<br><br>异或运算的性质:<br><br><li>交换律：<code>(a^b)^c == a^(b^c)</code></li><br><li>结合律：<code>(a + b)^c == a^b + b^c</code></li><br><li>对于任何数x，都有 <code>x^x=0，x^0=x</code></li><br><li>自反性: <code>a^b^b=a^0=a</code>;</li><br><br><h4>4. 取反运算符 (~)</h4><br><br><strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。<br><br>运算规则：<br><br><pre><code class=\"language-JavaScript\">~ 1 = 0<br>~ 0 = 1<br></code></pre><br><br>总结：对一个二进制数按位取反，即将0变1，1变0。<br><br>例如：~6 即：<br><br><pre><code class=\"language-JavaScript\">0000 0110<br>= 1111 1001<br></code></pre><br><br>在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。<br><br>当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：<br><br><pre><code class=\"language-JavaScript\">0000 0110<br>   = 1111 1001<br>反码：1000 0110<br>补码：1000 0111<br></code></pre><br><br>因此，~6的值为-7。<br><br><h4>5. 左移运算符（<<）</h4><br><br><strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。<br><br>设 a=1010 1110，a = a<< 2 将a的二进制位左移2位、右补0，即得a=1011 1000。<br><br>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。<br><br><h4>6. 右移运算符（>>）</h4><br><br><strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。<br><br>例如：a=a>>2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。<br><br>操作数每右移一位，相当于该数除以2。<br><br><h4>7. 原码、补码、反码</h4><br><br>上面提到了补码、反码等知识，这里就补充一下。<br><br>计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。<br><br><strong>（1）原码</strong><br><br>原码就是一个数的二进制数。<br><br>例如：10的原码为0000 1010<br><br><strong>（2）反码</strong><br><br><li>正数的反码与原码相同，如：10 反码为 0000 1010</li><br><li>负数的反码为除符号位，按位取反，即0变1，1变0。</li><br><br>例如：-10<br><br><pre><code class=\"language-JavaScript\">原码：1000 1010<br>反码：1111 0101<br></code></pre><br><br><strong>（3）补码</strong><br><br><li>正数的补码与原码相同，如：10 补码为 0000 1010</li><br><li>负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li><br><br>例如：-10<br><br><pre><code class=\"language-JavaScript\">原码：1000 1010<br>反码：1111 0101<br>补码：1111 0110<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319828,
    "title": "为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?",
    "content": "<code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。<br><br>要遍历类数组，有三个方法：<br><br>（1）将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：<br><br><pre><code class=\"language-JavaScript\">function foo(){ <br>  Array.prototype.forEach.call(arguments, a => console.log(a))<br>}<br></code></pre><br><br>（2）使用Array.from方法将类数组转化成数组：‌<br><br><pre><code class=\"language-JavaScript\">function foo(){ <br>  const arrArgs = Array.from(arguments) <br>  arrArgs.forEach(a => console.log(a))<br>}<br></code></pre><br><br>（3）使用展开运算符将类数组转化成数组<br><br><pre><code class=\"language-JavaScript\">function foo(){ <br>    const arrArgs = [...arguments] <br>    arrArgs.forEach(a => console.log(a)) <br>}<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319829,
    "title": "13*. 什么是 DOM 和 BOM？",
    "content": "<strong>回答：</strong><br><br>DOM（文档对象模型）是浏览器将 HTML 文档转换为 JavaScript 可操作的对象树结构，用于操作网页内容如文字、图片、按钮等元素；BOM（浏览器对象模型）是浏览器提供的与浏览器窗口交互的对象集合，用于操作浏览器本身如窗口、历史记录、弹窗等功能。简单来说，DOM 负责操作网页内容，BOM 负责操作浏览器功能，两者的根对象分别是 document 和 window。<br><br><li>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li><br><li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319830,
    "title": "对类数组对象的理解，如何转化为数组",
    "content": "一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。<br><br>常见的类数组转换为数组的方法有这样几种：<br><br><li>通过 call 调用数组的 slice 方法来实现转换</li><br><br><pre><code class=\"language-JavaScript\">Array.prototype.slice.call(arrayLike);<br></code></pre><br><br><li>通过 call 调用数组的 splice 方法来实现转换</li><br><br><pre><code class=\"language-JavaScript\">Array.prototype.splice.call(arrayLike, 0);<br></code></pre><br><br><li>通过 apply 调用数组的 concat 方法来实现转换</li><br><br><pre><code class=\"language-JavaScript\">Array.prototype.concat.apply([], arrayLike);<br></code></pre><br><br><li>通过 Array.from 方法来实现转换</li><br><br><pre><code class=\"language-JavaScript\">Array.from(arrayLike);<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319831,
    "title": "escape、encodeURI、encodeURIComponent 的区别",
    "content": "<li>encodeURI</li><br>  - <code>encodeURI</code> 用于对整个 URI 进行编码。它会将除了 URI 安全字符之外的所有字符编码。URI 安全字符包括字母、数字、连字符 <code>-</code>、下划线 <code>_</code>、波浪号 <code>~</code> 以及点 <code>.</code>。<code>encodeURI</code> 不会对 URI 中的保留字符进行编码，这些<strong>保留字符</strong>包括 <code>;</code>, <code>/</code>, <code>?</code>, <code>:</code>, <code>@</code>, <code>&</code>, <code>=</code>, <code>+</code>, <code>$</code>, <code>,</code>, <code>#</code>。<br>  - 代码示例：<br><br><pre><code class=\"language-JavaScript\">const uri = \"http://example.com/path/to/page?name=value&another=value\";<br>console.log(encodeURI(uri)); <br>// 输出: \"http://example.com/path/to/page?name=value&another=value\"<br></code></pre><br><br><li>encodeURIComponent</li><br>  - <code>encodeURIComponent</code> 用于对 URI 的各个<strong>组成部分</strong>进行编码，例如查询参数或片段标识符。它会将除了 <code>-</code>, <code>_</code>, <code>.</code>, <code>~</code> 之外的所有非字母数字字符进行编码。<code>encodeURIComponent</code> 会对所有保留字符进行编码，因此它非常适合用于编码 URL 的各个组成部分。。<br>  - 代码示例：<br><br><pre><code class=\"language-JavaScript\">const query = \"name=value&another=value\";<br>console.log(encodeURIComponent(query)); <br>// 输出: \"name%3Dvalue%26another%3Dvalue\"<br></code></pre><br><br><li>escape</li><br>  - <code>escape</code> 是一个较旧的函数，用于将字符串编码为适用于 URL 的格式。然而，<code>它已经被废弃</code>，并且不推荐在现代浏览器中使用。它的主要问题是它不能正确地处理 Unicode 字符，并且它的编码规则与现代 URL 编码标准不符。<br>  - 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319832,
    "title": "16*. 对AJAX的理解，实现一个AJAX请求",
    "content": "AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。<br><br>创建AJAX请求的步骤：<br><br><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><br><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><br><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><br><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li><br><br><pre><code class=\"language-JavaScript\">const SERVER_URL = \"/server\";<br>let xhr = new XMLHttpRequest();<br>// 创建 Http 请求<br>xhr.open(\"GET\", url, true);<br>// 设置状态监听函数<br>xhr.onreadystatechange = function() {<br>  if (this.readyState !== 4) return;<br>  // 当请求成功时<br>  if (this.status === 200) {<br>    handle(this.response);<br>  } else {<br>    console.error(this.statusText);<br>  }<br>};<br>// 设置请求失败时的监听函数<br>xhr.onerror = function() {<br>  console.error(this.statusText);<br>};<br>// 设置请求头信息<br>xhr.responseType = \"json\";<br>xhr.setRequestHeader(\"Accept\", \"application/json\");<br>// 发送 Http 请求<br>xhr.send(null);<br></code></pre><br><br>使用Promise封装AJAX：<br><br><pre><code class=\"language-JavaScript\">// promise 封装实现：<br>function getJSON(url) {<br>  // 创建一个 promise 对象<br>  let promise = new Promise(function(resolve, reject) {<br>    let xhr = new XMLHttpRequest();<br>    // 新建一个 http 请求<br>    xhr.open(\"GET\", url, true);<br>    // 设置状态的监听函数<br>    xhr.onreadystatechange = function() {<br>      if (this.readyState !== 4) return;<br>      // 当请求成功或失败时，改变 promise 的状态<br>      if (this.status === 200) {<br>        resolve(this.response);<br>      } else {<br>        reject(new Error(this.statusText));<br>      }<br>    };<br>    // 设置错误监听函数<br>    xhr.onerror = function() {<br>      reject(new Error(this.statusText));<br>    };<br>    // 设置响应的数据类型<br>    xhr.responseType = \"json\";<br>    // 设置请求头信息<br>    xhr.setRequestHeader(\"Accept\", \"application/json\");<br>    // 发送 http 请求<br>    xhr.send(null);<br>  });<br>  return promise;<br>}<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319833,
    "title": "JavaScript为什么要进行变量提升，它导致了什么问题？",
    "content": "<strong>回答：</strong><br><br>JavaScript 变量提升是编译器将变量和函数声明移动到作用域顶部的机制，其历史原因是为了简化早期编译器实现并允许在声明前调用函数，但这种机制导致声明与赋值分离造成理解困难、变量覆盖、函数声明优先级混乱、循环变量泄漏、全局污染和调试困难等问题，现代 JavaScript 推荐使用 let 和 const 替代 var，它们虽然也有提升但会进入暂时性死区（TDZ）在声明前访问会报错而非 undefined，配合严格模式、在作用域顶部声明变量、使用函数表达式等最佳实践可以有效避免变量提升带来的问题。<br><br>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。<br><br>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。<br><br>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。<br><br><li><strong>在解析阶段</strong>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</li><br><li><strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</li><br><br>那为什么会进行变量提升呢？主要有以下两个原因：<br><br><li>提高性能</li><br><li>容错性更好</li><br><br><strong>（1）提高性能</strong><br><br>在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。<br><br>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。<br><br><strong>（2）容错性更好</strong><br><br>变量提升可以在一定程度上提高JS的容错性，看下面的代码：<br><br><pre><code class=\"language-JavaScript\">a = 1;<br>var a;<br>console.log(a);<br></code></pre><br><br>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。<br><br>虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。<br><br><strong>总结：</strong><br><br><li>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li><br><li>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li><br><br>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：<br><br><pre><code class=\"language-JavaScript\">var tmp = new Date();<br><br>function fn(){<br>  console.log(tmp);<br>  if(false){<br>    var tmp = 'hello world';<br>  }<br>}<br><br>fn();  // undefined<br></code></pre><br><br>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。<br><br><pre><code class=\"language-JavaScript\">var tmp = 'hello world';<br><br>for (var i = 0; i < tmp.length; i++) {<br>  console.log(tmp[i]);<br>}<br><br>console.log(i); // 11<br></code></pre><br><br>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319834,
    "title": "什么是尾调用，使用尾调用有什么好处？",
    "content": "尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319835,
    "title": "*ES6**模块与**CommonJS**模块有什么异同？",
    "content": "<strong>回答：</strong><br><br>ES6模块与CommonJS模块都解决了JavaScript模块化问题并避免全局污染，但核心差异在于加载机制：CommonJS采用运行时加载和值拷贝，支持动态导入但无法静态分析和tree-shaking，语法为require/exports；<br><br>ES6模块采用编译时加载和动态绑定，支持静态分析和tree-shaking优化，语法为import/export，this指向undefined而非CommonJS的{}<br><br>ES6 Module和CommonJS模块的区别：<br><br><li>CommonJS</li><br>  - 使用 <code>require</code> 函数来加载模块，使用 <code>module.exports</code> 或 <code>exports</code> 对象来导出模块中的变量、函数或类，没有默认导出的概念，所有导出都是显式的。<br>  - 是动态加载的，依赖关系<strong>在运行时确定</strong>；不支持树摇，必须加载整个模块才能使用其中的一个导出；可以在严格模式或非严格模式下执行。<br>  - 是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；<br><li>ES6 模块</li><br>  - 使用 <code>import</code> 语句导入模块中的导出；使用 <code>export</code> 语句导出模块中的变量、函数或类；可以使用 <code>export default</code> 来导出一个默认的导出项。<br>  - 是<strong>静态分析</strong>的，这意味着在执行代码之前就已经确定了模块的依赖关系；<strong>支持树摇</strong>（Tree Shaking），可以排除未使用的导出；使用严格模式（strict mode）执行。<br>  - import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。<br><br>ES6 Module和CommonJS模块的共同点：<br><br><li>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319836,
    "title": "常见的DOM操作有哪些",
    "content": "<h4>1）DOM 节点的获取</h4><br><br>DOM 节点的获取的API及使用：<br><br><pre><code class=\"language-JavaScript\">getElementById // 按照 id 查询<br>getElementsByTagName // 按照标签名查询<br>getElementsByClassName // 按照类名查询<br>querySelectorAll // 按照 css 选择器查询<br><br>// 按照 id 查询<br>var imooc = document.getElementById('imooc') // 查询到 id 为 imooc 的元素<br>// 按照标签名查询<br>var pList = document.getElementsByTagName('p')  // 查询到标签为 p 的集合<br>console.log(divList.length)<br>console.log(divList[0])<br>// 按照类名查询<br>var moocList = document.getElementsByClassName('mooc') // 查询到类名为 mooc 的集合<br>// 按照 css 选择器查询<br>var pList = document.querySelectorAll('.mooc') // 查询到类名为 mooc 的集合<br></code></pre><br><br><h4>2）DOM 节点的创建</h4><br><br><strong>创建一个新节点，并把它添加到指定节点的后面。</strong> 已知的 HTML 结构如下：<br><br><pre><code class=\"language-HTML\"><html><br>  <head><br>    <title>DEMO</title><br>  </head><br>  <body><br>    <div id=\"container\"> <br>      <h1 id=\"title\">我是标题</h1><br>    </div>   <br>  </body><br></html><br></code></pre><br><br>要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：<br><br><pre><code class=\"language-JavaScript\">// 首先获取父节点<br>var container = document.getElementById('container')<br>// 创建新节点<br>var targetSpan = document.createElement('span')<br>// 设置 span 节点的内容<br>targetSpan.innerHTML = 'hello world'<br>// 把新创建的元素塞进父节点里去<br>container.appendChild(targetSpan)<br></code></pre><br><br><h4>3）DOM 节点的删除</h4><br><br><strong>删除指定的 DOM 节点，</strong> 已知的 HTML 结构如下：<br><br><pre><code class=\"language-JavaScript\"><html><br>  <head><br>    <title>DEMO</title><br>  </head><br>  <body><br>    <div id=\"container\"> <br>      <h1 id=\"title\">我是标题</h1><br>    </div>   <br>  </body><br></html><br></code></pre><br><br>需要删除 id 为 title 的元素，做法是：<br><br><pre><code class=\"language-JavaScript\">// 获取目标元素的父元素<br>var container = document.getElementById('container')<br>// 获取目标元素<br>var targetNode = document.getElementById('title')<br>// 删除目标元素<br>container.removeChild(targetNode)<br></code></pre><br><br>或者通过子节点数组来完成删除：<br><br><pre><code class=\"language-JavaScript\">// 获取目标元素的父元素<br>var container = document.getElementById('container')<br>// 获取目标元素<br>var targetNode = container.childNodes[1]<br>// 删除目标元素<br>container.removeChild(targetNode)<br></code></pre><br><br><h4>4）修改 DOM 元素</h4><br><br>修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。<br><br><strong>将指定的两个 DOM 元素交换位置，</strong> 已知的 HTML 结构如下：<br><br><pre><code class=\"language-JavaScript\"><html><br>  <head><br>    <title>DEMO</title><br>  </head><br>  <body><br>    <div id=\"container\"> <br>      <h1 id=\"title\">我是标题</h1><br>      <p id=\"content\">我是内容</p><br>    </div>   <br>  </body><br></html><br></code></pre><br><br>现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：<br><br><pre><code class=\"language-JavaScript\">// 获取父元素<br>var container = document.getElementById('container')   <br> <br>// 获取两个需要被交换的元素<br>var title = document.getElementById('title')<br>var content = document.getElementById('content')<br>// 交换两个元素，把 content 置于 title 前面<br>container.insertBefore(content, title)<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319837,
    "title": "use strict是什么意思 ? 使用它区别是什么？",
    "content": "use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：<br><br><li>消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;</li><br><li>消除代码运行的不安全之处，保证代码运行的安全；</li><br><li>提高编译器效率，增加运行速度；</li><br><li>为未来新版本的 Javascript 做好铺垫。</li><br><br>区别：<br><br><li>禁止使用 with 语句。</li><br><li>禁止 this 关键字指向全局对象。</li><br><li>对象不能有重名的属性。</li>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319838,
    "title": "如何判断一个对象是否属于某个类？",
    "content": "<li>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li><br><li>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li><br><li>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319839,
    "title": "强类型语言和弱类型语言的区别",
    "content": "<li><strong>强类型语言</strong>：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。</li><br><li><strong>弱类型语言</strong>：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串'12'和整数3进行连接得到字符串'123'，在相加的时候会进行强制类型转换。</li><br><br>两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319840,
    "title": "解释性语言和编译型语言的区别",
    "content": "（1）解释型语言<br><br>使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下<br><br><li>解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</li><br><li>只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</li><br><li>JavaScript、Python等属于解释型语言。</li><br><br>（2）编译型语言<br><br>使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：<br><br><li>一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li><br><li>与特定平台相关，一般无法移植到其他平台；</li><br><li>C、C++等属于编译型语言。</li><br><br><strong>两者主要区别在于：</strong> 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319841,
    "title": "25*. for...in和for...of的区别",
    "content": "for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下<br><br><li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li><br><li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319842,
    "title": "如何使用for...of遍历对象",
    "content": "for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。<br><br>如果需要遍历的对象是类数组对象，用Array.from转成数组即可。<br><br><pre><code class=\"language-JavaScript\">var obj = {<br>    0:'one',<br>    1:'two',<br>    length: 2<br>};<br>obj = Array.from(obj);<br>for(var k of obj){<br>    console.log(k)<br>}<br></code></pre><br><br>如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。<br><br><pre><code class=\"language-JavaScript\">//方法一：<br>var obj = {<br>    a:1,<br>    b:2,<br>    c:3<br>};<br><br>obj[Symbol.iterator] = function(){<br>  var keys = Object.keys(this);<br>  var count = 0;<br>  return {<br>    next(){<br>      if(count<keys.length){<br>        return {value: obj[keys[count++]],done:false};<br>      }else{<br>        return {value:undefined,done:true};<br>      }<br>    }<br>  }<br>};<br><br>for(var k of obj){<br>  console.log(k);<br>}<br><br>// 方法二<br>var obj = {<br>    a:1,<br>    b:2,<br>    c:3<br>};<br>obj[Symbol.iterator] = function*(){<br>    var keys = Object.keys(obj);<br>    for(var k of keys){<br>        yield [k,obj[k]]<br>    }<br>};<br><br>for(var [k,v] of obj){<br>    console.log(k,v);<br>}<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319843,
    "title": "ajax、axios、fetch的区别",
    "content": "<strong>（1）AJAX</strong><br><br>Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式[网页](https://link.zhihu.com/?target=https://baike.baidu.com/item/网页)应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：<br><br><li>本身是针对MVC编程，不符合前端MVVM的浪潮</li><br><li>基于原生XHR开发，XHR本身的架构不清晰</li><br><li>不符合关注分离（Separation of Concerns）的原则</li><br><li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li><br><br><strong>（2）Fetch</strong><br><br>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。<strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。<br><br>fetch的优点：<br><br><li>语法简洁，更加语义化</li><br><li>基于标准 Promise 实现，支持 async/await</li><br><li>更加底层，提供的API丰富（request, response）</li><br><li>脱离了XHR，是ES规范里新的实现方式</li><br><br>fetch的缺点：<br><br><li>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li><br><li>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})</li><br><li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li><br><li>fetch没有办法原生监测请求的进度，而XHR可以</li><br><br><strong>（3）Axios</strong><br><br>Axios 是一种基于Promise封装的HTTP客户端，其特点如下：<br><br><li>浏览器端发起XMLHttpRequests请求</li><br><li>node端发起http请求</li><br><li>支持Promise API</li><br><li>监听请求和返回</li><br><li>对请求和返回进行转化</li><br><li>取消请求</li><br><li>自动转换json数据</li><br><li>客户端支持抵御XSRF攻击</li>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319844,
    "title": "数组的遍历方法有哪些",
    "content": "总结：forEach，map，filter，for...of，find<br><br>| ***<em><strong>方法</strong>              | </em>**<em><strong>是否改变原数组</strong> | </em>***<strong>特点</strong>                                                 |<br>| ------------------------- | ---------------------- | ------------------------------------------------------------ |<br>| forEach()                 | 是                     | 数组方法，会改变原数组，没有返回值                           |<br>| map()                     | 否                     | 数组方法，不改变原数组，有返回值，可链式调用                 |<br>| filter()                  | 否                     | 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用 |<br>| for...of                  | 否                     | for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环 |<br>| every() 和 some()         | 否                     | 数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false. |<br>| find() 和 findIndex()     | 否                     | 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值 |<br>| reduce() 和 reduceRight() | 否                     | 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作 |",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319845,
    "title": "forEach和map方法有什么区别",
    "content": "这方法都是用来遍历数组的，两者区别如下：<br><br><li>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li><br><li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319846,
    "title": "addEventListener()方法的参数和使用",
    "content": "<strong>EventTarget.addEventListener()</strong> 方法将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 事件目标可以是一个文档上的元素 Element，Document和Window或者任何其他支持事件的对象。<br><br>addEventListener()的工作原理是将实现EventListener的函数或对象添加到调用它的EventTarget上的指定事件类型的事件侦听器列表中。<br><br>它的使用语法如下：<br><br><pre><code class=\"language-JavaScript\">target.addEventListener(type, listener, options);<br>target.addEventListener(type, listener, useCapture);<br>target.addEventListener(type, listener, useCapture, wantsUntrusted);  <br></code></pre><br><br>其中参数如下：<br><br><strong>（1）type</strong><br><br>表示监听事件类型的字符串。<br><br><strong>（2）listener</strong><br><br>当所监听的事件类型触发时，会接收到一个事件通知（实现了 Event 接口的对象）对象。listener 必须是一个实现了 EventListener 接口的对象，或者是一个函数。<br><br><strong>（3）options 可选</strong><br><br>一个指定有关 listener 属性的可选参数<strong>对象</strong>。可用的选项如下：<br><br><li>capture:  Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。</li><br><li>once:  Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。</li><br><li>passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。</li><br><li>signal：AbortSignal，该 AbortSignal 的 abort() 方法被调用时，监听器会被移除。</li><br><br><strong>（4）useCapture</strong>  <strong>可选</strong><br><br>Boolean，在DOM树中，注册了listener的元素， 是否要先于它下面的EventTarget，调用该listener。 当useCapture(设为true) 时，沿着DOM树向上冒泡的事件，不会触发listener。当一个元素嵌套了另一个元素，并且两个元素都对同一事件注册了一个处理函数时，所发生的事件冒泡和事件捕获是两种不同的事件传播方式。事件传播模式决定了元素以哪个顺序接收事件。如果没有指定， useCapture 默认为 false 。<br><br><strong>（5）wantsUntrusted</strong><br><br>如果为 true , 则事件处理程序会接收网页自定义的事件。此参数只适用于 Gecko（chrome的默认值为true，其他常规网页的默认值为false），主要用于附加组件的代码和浏览器本身。",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103590262,
    "title": "let、const、var的区别",
    "content": "<strong>回答：</strong><br><br>1. let和const具有块级作用域而var是函数作用域<br>2. let和const不存在变量提升而var存在变量提升<br>3. let和const不能重复声明而var可以<br>4. const声明后不能重新赋值而let和var可以<br>5. var全局声明会挂载到window对象而let和const不会<br><br><strong>解析：</strong><br><br><strong>（1）块级作用域：</strong>块作用域由 <code>{ }</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：<br><br><li>内层变量可能覆盖外层变量</li><br><li>用来计数的循环变量泄露为全局变量</li><br><br><strong>（2）变量提升：</strong>var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。<br><br><strong>（3）给全局添加属性：</strong>浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。<br><br><strong>（4）重复声明：</strong>var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。<br><br><strong>（5）暂时性死区：在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为</strong>暂时性死区。使用var声明的变量不存在暂时性死区。<br><br><strong>（6）初始值设置：</strong>在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。<br><br><strong>（7）指针指向：</strong>let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。<br><br>| <strong>区别</strong>           | <strong>var</strong> | <strong>let</strong> | <strong>const</strong> |<br>| ------------------ | ------- | ------- | --------- |<br>| 是否有块级作用域   | ×       | ✔️       | ✔️         |<br>| 是否存在变量提升   | ✔️       | ×       | ×         |<br>| 是否添加全局属性   | ✔️       | ×       | ×         |<br>| 能否重复声明变量   | ✔️       | ×       | ×         |<br>| 是否存在暂时性死区 | ×       | ✔️       | ✔️         |<br>| 是否必须设置初始值 | ×       | ×       | ✔️         |<br>| 能否改变指针指向   | ✔️       | ✔️       | ×         |",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590263,
    "title": "const对象的属性可以修改吗",
    "content": "<strong>回答：</strong><br><br>const对象的属性可以修改，因为const保证的是变量指向的内存地址不变而不是对象内容不变，所以可以修改、新增或删除对象的属性，但不能重新赋值整个对象<br><br>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。<br><br>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590264,
    "title": "如果new一个箭头函数的会怎么样",
    "content": "<strong>回答：</strong><br><br>new一个箭头函数会报错，因为箭头函数没有自己的this而是捕获外层作用域的this，没有prototype属性，不能用作构造函数，所以禁止使用new关键字调用，箭头函数设计初衷是作为回调函数使用而非构造函数。<br><br>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。<br><br>new操作符的实现步骤如下：<br><br>1. 创建一个对象<br>2. 将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）<br>3. 指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）<br>4. 返回新的对象<br><br>所以，上面的第二、三步，箭头函数都是没有办法执行的。",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590265,
    "title": "箭头函数与普通函数的区别",
    "content": "<strong>回答：</strong><br><br>箭头函数与普通函数的主要区别在于：<br><br>箭头函数没有自己的this而是继承外层作用域的this且无法通过call/apply/bind改变，没有prototype属性不能用作构造函数，没有arguments对象需用剩余参数代替，不能用new调用，不能用作Generator函数，不能使用yield关键字，没有自己的super关键字，语法更简洁适合回调函数，而普通函数this指向调用者可改变、有prototype可作为构造函数、有arguments对象、可用new创建实例、可使用super关键字，适用于需要this绑定、作为构造函数或需要arguments对象的场景。<br><br><strong>（1）箭头函数比普通函数更加简洁</strong><br><br><li>如果没有参数，就直接写一个空括号即可</li><br><li>如果只有一个参数，可以省去参数的括号</li><br><li>如果有多个参数，用逗号分割</li><br><li>如果函数体的返回值只有一句，可以省略大括号</li><br><li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li><br><br><pre><code class=\"language-JavaScript\">let fn = () => void doesNotReturn();<br></code></pre><br><br><strong>（2）箭头函数没有自己的this</strong><br><br>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。<br><br><strong>（3）箭头函数继承来的this指向永远不会改变</strong><br><br><pre><code class=\"language-JavaScript\">var id = 'GLOBAL';<br>var obj = {<br>  id: 'OBJ',<br>  a: function(){<br>    console.log(this.id);<br>  },<br>  b: () => {<br>    console.log(this.id);<br>  }<br>};<br>obj.a();    // 'OBJ'<br>obj.b();    // 'GLOBAL'<br>new obj.a()  // undefined<br>new obj.b()  // Uncaught TypeError: obj.b is not a constructor<br></code></pre><br><br>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<code>{}</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。<br><br><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong><br><br><pre><code class=\"language-JavaScript\">var id = 'Global';<br>let fun1 = () => {<br>    console.log(this.id)<br>};<br>fun1();                     // 'Global'<br>fun1.call({id: 'Obj'});     // 'Global'<br>fun1.apply({id: 'Obj'});    // 'Global'<br>fun1.bind({id: 'Obj'})();   // 'Global'<br></code></pre><br><br><strong>（5）箭头函数不能作为构造函数使用</strong><br><br>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。<br><br><strong>（6）箭头函数没有自己的arguments</strong><br><br>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。<br><br><strong>（7）箭头函数没有prototype</strong><br><br><strong>（8）箭头函数不能用作Generator函数，不能使用yeild关键字</strong>",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590266,
    "title": "箭头函数的**this**指向哪⾥？",
    "content": "箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。<br><br>可以⽤Babel理解⼀下箭头函数:<br><br><pre><code class=\"language-JavaScript\">// ES6 <br>const obj = { <br>  getArrow() { <br>    return () => { <br>      console.log(this === obj); <br>    }; <br>  } <br>}<br></code></pre><br><br>转化后：<br><br><pre><code class=\"language-JavaScript\">// ES5，由 Babel 转译<br>var obj = { <br>   getArrow: function getArrow() { <br>     var _this = this; <br>     return function () { <br>        console.log(_this === obj); <br>     }; <br>   } <br>};<br></code></pre>",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590267,
    "title": "扩展运算符的作用及使用场景",
    "content": "<strong>（1）对象扩展运算符</strong><br><br>对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。<br><br><pre><code class=\"language-JavaScript\">let bar = { a: 1, b: 2 };<br>let baz = { ...bar }; // { a: 1, b: 2 }<br></code></pre><br><br>上述方法实际上等价于:<br><br><pre><code class=\"language-JavaScript\">let bar = { a: 1, b: 2 };<br>let baz = Object.assign({}, bar); // { a: 1, b: 2 }<br></code></pre><br><br><code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。<br><br>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。<br><br><pre><code class=\"language-JavaScript\">let bar = {a: 1, b: 2};<br>let baz = {...bar, ...{a:2, b: 4}};  // {a: 2, b: 4}<br></code></pre><br><br>利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。<br><br>需要注意：扩展运算符对<strong>对象实例的拷贝属于浅拷贝</strong>。<br><br><strong>（2）数组扩展运算符</strong><br><br>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。<br><br><pre><code class=\"language-JavaScript\">console.log(...[1, 2, 3])<br>// 1 2 3<br>console.log(...[1, [2, 3, 4], 5])<br>// 1 [2, 3, 4] 5<br></code></pre><br><br>下面是数组的扩展运算符的应用：<br><br><li><strong>将数组转换为参数序列</strong></li><br><br><pre><code class=\"language-JavaScript\">function add(x, y) {<br>  return x + y;<br>}<br>const numbers = [1, 2];<br>add(...numbers) // 3<br></code></pre><br><br><li><strong>复制数组</strong></li><br><br><pre><code class=\"language-JavaScript\">const arr1 = [1, 2];<br>const arr2 = [...arr1];<br></code></pre><br><br>要记住：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。<br><br><li><strong>合并数组</strong></li><br><br>如果想在数组内合并数组，可以这样：<br><br><pre><code class=\"language-JavaScript\">const arr1 = ['two', 'three'];<br>const arr2 = ['one', ...arr1, 'four', 'five'];<br>// [\"one\", \"two\", \"three\", \"four\", \"five\"]<br></code></pre><br><br><li><strong>扩展运算符与解构赋值结合起来，用于生成数组</strong></li><br><br><pre><code class=\"language-JavaScript\">const [first, ...rest] = [1, 2, 3, 4, 5];<br>first // 1<br>rest  // [2, 3, 4, 5]<br></code></pre><br><br>需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong><br><br><pre><code class=\"language-JavaScript\">const [...rest, last] = [1, 2, 3, 4, 5];         // 报错<br>const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错<br></code></pre><br><br><li><strong>将字符串转为真正的数组</strong></li><br><br><pre><code class=\"language-JavaScript\">[...'hello']    // [ \"h\", \"e\", \"l\", \"l\", \"o\" ]<br></code></pre><br><br><li><strong>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</strong></li><br><br>比较常见的应用是可以将某些数据结构转为数组：<br><br><pre><code class=\"language-JavaScript\">// arguments对象<br>function foo() {<br>  const args = [...arguments];<br>}<br></code></pre><br><br>用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。<br><br><li><strong>使用</strong><code><strong>Math</strong></code><strong>函数获取数组中特定的值</strong></li><br><br><pre><code class=\"language-JavaScript\">const numbers = [9, 4, 7, 1];<br>Math.min(...numbers); // 1<br>Math.max(...numbers); // 9<br></code></pre>",
    "categoryId": "1768000001005",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590268,
    "title": "对对象与数组的解构的理解",
    "content": "解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。<br><br><strong>1）数组的解构</strong><br><br>在解构数组时，以元素的位置为匹配条件来提取想要的数据的：<br><br><pre><code class=\"language-JavaScript\">const [a, b, c] = [1, 2, 3]<br></code></pre><br><br>最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：<br><br>![img](https://secure2.wostatic.cn/static/qLe5MFqx2XRQAqtJDWd7oa/image.png?auth_key=1768103476-fu7mWciZ6ob6ERNkeHkas4-0-cb1a38b72770cfc62cc83a4e9bc6af7b)<br><br>数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：<br><br><pre><code class=\"language-JavaScript\">const [a,,c] = [1,2,3]<br></code></pre><br><br>通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量：<br><br>![img](https://secure2.wostatic.cn/static/vDcrxGKrQhCeTsr3U3q3kX/image.png?auth_key=1768103476-mrgyGc58k7ZTBKXBmCBLoV-0-baf74d9fabbb8a62aad64c748ba7efdf)<br><br><strong>2）对象的解构</strong><br><br>对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：<br><br><pre><code class=\"language-JavaScript\">const stu = {<br>  name: 'Bob',<br>  age: 24<br>}<br></code></pre><br><br>假如想要解构它的两个自有属性，可以这样：<br><br><pre><code class=\"language-JavaScript\">const { name, age } = stu<br></code></pre><br><br>这样就得到了 name 和 age 两个和 stu 平级的变量：<br><br>![img](https://secure2.wostatic.cn/static/rqYLfzHrRVUskHjg4xDaia/image.png?auth_key=1768103477-4Ex5K66AWgpy4QHNAZh3dX-0-4fddc0504a1a99b25096dc128422d6f5)<br><br>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：<br><br><pre><code class=\"language-JavaScript\">const { age, name } = stu<br></code></pre>",
    "categoryId": "1768000001005",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590269,
    "title": "*如何提取高度嵌套的对象里的指定属性？**",
    "content": "有时会遇到一些嵌套程度非常深的对象：<br><br><pre><code class=\"language-JavaScript\">const school = {<br>   classes: {<br>      stu: {<br>         name: 'Bob',<br>         age: 24,<br>      }<br>   }<br>}<br></code></pre><br><br>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：<br><br><pre><code class=\"language-JavaScript\">const { name } = school<br></code></pre><br><br>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：<br><br><pre><code class=\"language-JavaScript\">const { classes } = school<br>const { stu } = classes<br>const { name } = stu<br>name // 'Bob'<br></code></pre><br><br>但是还有一种更标准的做法，可以用一行代码来解决这个问题：<br><br><pre><code class=\"language-JavaScript\">const { classes: { stu: { name } }} = school<br>       <br>console.log(name)  // 'Bob'<br></code></pre><br><br>可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590270,
    "title": "对 rest 参数的理解",
    "content": "扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：<br><br><pre><code class=\"language-JavaScript\">function mutiple(...args) {<br>  let result = 1;<br>  for (var val of args) {<br>    result *= val;<br>  }<br>  return result;<br>}<br>mutiple(1, 2, 3, 4) // 24<br></code></pre><br><br>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：<br><br><pre><code class=\"language-JavaScript\">function mutiple(...args) {<br>  console.log(args)<br>}<br>mutiple(1, 2, 3, 4) // [1, 2, 3, 4]<br></code></pre><br><br>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong>",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590271,
    "title": "ES6中模板语法与字符串处理",
    "content": "ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：<br><br><pre><code class=\"language-JavaScript\">var name = 'css'   <br>var career = 'coder' <br>var hobby = ['coding', 'writing']<br>var finalString = 'my name is ' + name + ', I work as a ' + career + ', I love ' + hobby[0] + ' and ' + hobby[1]<br></code></pre><br><br>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：<br><br><pre><code class=\"language-JavaScript\">var name = 'css'   <br>var career = 'coder' <br>var hobby = ['coding', 'writing']<br>var finalString = <code>my name is ${name}, I work as a ${career} I love ${hobby[0]} and ${hobby[1]}</code><br></code></pre><br><br>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：<br><br><li>在模板字符串中，空格、缩进、换行都会被保留</li><br><li>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li><br><br>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：<br><br><pre><code class=\"language-JavaScript\">let list = <code><br>  <ul><br>    <li>列表项1</li><br>    <li>列表项2</li><br>  </ul><br></code>;<br>console.log(message); // 正确输出，不存在报错<br></code></pre><br><br>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：<br><br><pre><code class=\"language-JavaScript\">function add(a, b) {<br>  const finalString = <code>${a} + ${b} = ${a+b}</code><br>  console.log(finalString)<br>}<br>add(1, 2) // 输出 '1 + 2 = 3'<br></code></pre><br><br>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：<br><br><li><strong>存在性判定</strong>：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf > -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</li><br><li>- <strong>includes</strong>：判断字符串与子串的包含关系：</li><br><br><pre><code class=\"language-JavaScript\">const son = 'haha' <br>const father = 'xixi haha hehe'<br>father.includes(son) // true<br></code></pre><br><br><li>- <strong>startsWith</strong>：判断字符串是否以某个/某串字符开头：</li><br><br><pre><code class=\"language-JavaScript\">const father = 'xixi haha hehe'<br>father.startsWith('haha') // false<br>father.startsWith('xixi') // true<br></code></pre><br><br><li>- <strong>endsWith</strong>：判断字符串是否以某个/某串字符结尾：</li><br><br><pre><code class=\"language-JavaScript\">const father = 'xixi haha hehe'<br>  father.endsWith('hehe') // true<br></code></pre><br><br><li><strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</li><br><br><pre><code class=\"language-JavaScript\">const sourceCode = 'repeat for 3 times;'<br>const repeated = sourceCode.repeat(3) <br>console.log(repeated) // repeat for 3 times;repeat for 3 times;repeat for 3 times;<br></code></pre>",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  }
]