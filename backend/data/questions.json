[
  {
    "id": "q1",
    "title": "test",
    "content": "React Hooks 有两个主要的使用规则：<br><br>1. 只在最顶层使用 Hook<br>不要在循环、条件或嵌套函数中调用 Hook，确保总是在 React 函数的顶层调用 Hook。<br><br>2. 只在 React 函数中调用 Hook<br>不要在普通的 JavaScript 函数中调用 Hook。<br><br>为什么要有这些规则？<br>React 依赖于调用顺序来正确地将 Hook 和 组件关联起来。如果在条件语句或循环中使用 Hook，可能会导致状态不一致的 Bug。",
    "categoryId": "1767966254373",
    "isFrequent": true,
    "createdAt": "2025-01-09T00:00:00.000Z",
    "updatedAt": "2026-01-09T14:05:38.357Z"
  },
  {
    "id": "q2",
    "title": "useEffect 的依赖数组",
    "content": "useEffect 的第二个参数是依赖数组，它决定了 effect 何时重新执行：<br><br>1. 不传依赖数组：每次渲染后都会执行<br><code>useEffect(() => { /* effect */ })</code><br><br>2. 空数组：只在组件挂载和卸载时执行<br><code>useEffect(() => { /* effect */ }, [])</code><br><br>3. 传入依赖：依赖变化时执行<br><code>useEffect(() => { /* effect */ }, [count])</code><br><br>注意：依赖数组中的值必须是组件作用域内定义的值（props, state 等）。",
    "categoryId": "1767966254373",
    "isFrequent": true,
    "createdAt": "2025-01-09T00:00:00.000Z",
    "updatedAt": "2025-01-09T00:00:00.000Z"
  },
  {
    "id": "q3",
    "title": "TypeScript 类型断言",
    "content": "TypeScript 提供了两种类型断言语法：<br><br>1. 尖括号语法<br><code>let someValue: any = 'this is a string';<br>let strLength: number = (&lt;string&gt;someValue).length;</code><br><br>2. as 语法（推荐）<br><code>let someValue: any = 'this is a string';<br>let strLength: number = (someValue as string).length;</code><br><br>注意：类型断言不会改变变量的类型，只是告诉 TypeScript 编译器你确信这个值的类型。",
    "categoryId": "1767966254374",
    "isFrequent": false,
    "createdAt": "2025-01-09T00:00:00.000Z",
    "updatedAt": "2025-01-09T00:00:00.000Z"
  },
  {
    "id": "1767967761727",
    "title": "通过代理测试",
    "content": "代理测试内容11",
    "categoryId": "1767966254373",
    "isFrequent": false,
    "createdAt": "2026-01-09T14:09:21.727Z",
    "updatedAt": "2026-01-09T14:09:47.048Z"
  },
  {
    "id": "1767967796351",
    "title": "111",
    "content": "111",
    "categoryId": "1767966254373",
    "isFrequent": true,
    "createdAt": "2026-01-09T14:09:56.351Z",
    "updatedAt": "2026-01-09T14:09:56.351Z"
  },
  {
    "id": "1768101363841",
    "title": "*2. CSS中可继承与不可继承属性有哪些",
    "content": "### *2. CSS中可继承与不可继承属性有哪些\n\n**一、无继承性的属性**\n\n1. **display**：规定元素应该生成的框的类型\n2. **文本属性**：\n    - vertical-align：垂直文本对齐\n    - text-decoration：规定添加到文本的装饰\n    - text-shadow：文本阴影效果\n    - white-space：空白符的处理\n    - unicode-bidi：设置文本的方向\n3. **盒子模型的属性**：width、height、margin、border、padding\n4. **背景属性**：background、background-color、background-image、background-repeat、background-position、background-attachment\n5. **定位属性**：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index\n6. **生成内容属性**：content、counter-reset、counter-increment\n7. **轮廓样式属性**：outline-style、outline-width、outline-color、outline\n8. **页面样式属性**：size、page-break-before、page-break-after\n9. **声音样式属性**：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during\n\n**二、有继承性的属性**\n\n1. **字体系列属性**\n- font-family：字体系列\n- font-weight：字体的粗细\n- font-size：字体的大小\n- font-style：字体的风格\n1. **文本系列属性**\n- text-indent：文本缩进\n- text-align：文本水平对齐\n- line-height：行高\n- word-spacing：单词之间的间距\n- letter-spacing：中文或者字母之间的间距\n- text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）\n- color：文本颜色\n1. **元素可见性**\n- visibility：控制元素显示隐藏\n1. **列表布局属性**\n- list-style：列表风格，包括list-style-type、list-style-image等\n1. **光标属性**\n- cursor：光标显示为何种形态",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.841Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363842",
    "title": "*3. display的属性值及其作用",
    "content": "### *3. display的属性值及其作用\n\n| **属性值**   | **作用**                                                   |\n| ------------ | ---------------------------------------------------------- |\n| none         | 元素不显示，并且会从文档流中移除。                         |\n| block        | 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。       |\n| inline       | 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。 |\n| inline-block | 默认宽度为内容宽度，可以设置宽高，同行显示。               |\n| list-item    | 像块类型元素一样显示，并添加样式列表标记。                 |\n| table        | 此元素会作为块级表格来显示。                               |\n| inherit      | 规定应该从父元素继承display属性的值。                      |",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363843",
    "title": "*4. display的block、inline和inline-block的区别",
    "content": "### *4. display的block、inline和inline-block的区别\n\n（1）**block：**会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；\n\n（2）**inline：**元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；\n\n（3）**inline-block：**将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。\n\n对于行内元素和块级元素，其特点如下：\n\n**（1）行内元素**\n\n- 设置宽高无效；\n- 可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；\n- 不会自动换行；\n\n**（2）块级元素**\n\n- 可以设置宽高；\n- 设置margin和padding都有效；\n- 可以自动换行；\n- 多个块状，默认排列从上到下。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363844",
    "title": "*5. 隐藏元素的方法有哪些",
    "content": "### *5. 隐藏元素的方法有哪些\n\n- **display: none**：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。\n- **visibility: hidden**：元素在页面中仍占据空间，但是不会响应绑定的监听事件。\n- **opacity: 0**：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。\n- **position: absolute**：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。\n- **z-index: 负值**：来使其他元素遮盖住该元素，以此来实现隐藏。\n- **clip/clip-path** ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。\n- **transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363845",
    "title": "*6. link和@import的区别",
    "content": "### *6. link和@import的区别\n\n两者都是外部引用CSS的方式，它们的区别如下：\n\n- link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。\n- link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。\n- link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。\n- link支持使用Javascript控制DOM去改变样式；而@import不支持。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363846",
    "title": "7. transition和animation的区别",
    "content": "### 7. transition和animation的区别\n\n- **transition是过渡属性**，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。\n- **animation是动画属性**，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363847",
    "title": "*8. display:none与visibility:hidden的区别",
    "content": "### *8. display:none与visibility:hidden的区别\n\n这两个属性都是让元素隐藏，不可见。两者**区别如下：**\n\n（1）**在渲染树中**\n\n- `display:none`会让元素完全从渲染树中消失，渲染时不会占据任何空间；\n- `visibility:hidden`不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。\n\n（2）是否是**继承属性**\n\n- `display:none`是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；\n- `visibility:hidden`是继承属性，子孙节点消失是由于继承了`hidden`，通过设置`visibility:visible`可以让子孙节点显示；\n\n（3）修改常规文档流中元素的 `display` 通常会造成文档的重排，但是修改`visibility`属性只会造成本元素的重绘；\n\n（4）如果使用读屏器，设置为`display:none`的内容不会被读取，设置为`visibility:hidden`的内容会被读取。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363848",
    "title": "*9. **伪元素和伪类的区别和作用？**",
    "content": "### *9. **伪元素和伪类的区别和作用？**\n\n- 伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：\n\n```CSS\np::before {content:\"第一章：\";}\np::after {content:\"Hot!\";}\np::first-line {background:red;}\np::first-letter {font-size:30px;}\n```\n- 伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：\n\n```CSS\na:hover {color: #FF00FF}\np:first-child {color: red}\n```\n\n**总结：**伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363849",
    "title": "10. 对requestAnimationframe的理解",
    "content": "### 10. 对requestAnimationframe的理解\n\n实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是**请求动画帧**。\n\nMDN对该方法的描述：\n\nwindow.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。\n\n**语法：** `window.requestAnimationFrame(callback);`  其中，callback是**下一次重绘之前更新动画帧所调用的函数**(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于**宏任务**，所以会在执行完微任务之后再去执行。\n\n**取消动画：**使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。\n\n**优势：**\n\n- **CPU节能**：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。\n- **函数节流**：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。\n- **减少DOM操作**：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。\n\n**setTimeout执行动画的缺点**：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：\n\n- settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；\n- settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363850",
    "title": "*11. 对盒模型的理解",
    "content": "### *11. 对盒模型的理解\n\nCSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820746-e10daafa-451a-454e-9705-f8c358769d5b.png#align=left&display=inline&height=366&margin=[object)\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820555-dc6ed390-d47e-412b-942a-857bbe5f280d.png#align=left&display=inline&height=368&margin=[object)\n\n盒模型都是由四个部分组成的，分别是margin、border、padding和content。\n\n标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：\n\n- 标准盒模型的width和height属性的范围只包含了content，\n- IE盒模型的width和height属性的范围包含了border、padding和content。\n\n可以通过修改元素的box-sizing属性来改变元素的盒模型：\n\n- `box-sizing: content-box`表示标准盒模型（默认值）\n- `box-sizing: border-box`表示IE盒模型（怪异盒模型）",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363851",
    "title": "12. 为什么有时候⽤**translate**来改变位置⽽不是定位？ ",
    "content": "### 12. 为什么有时候⽤**translate**来改变位置⽽不是定位？ \n\ntranslate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363852",
    "title": "13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？",
    "content": "### 13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？\n\n浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个`<li>`放在一行，这导致`<li>`换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。\n\n**解决办法：**\n\n（1）为`<li>`设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。\n\n（2）将所有`<li>`写在同一行。不足：代码不美观。\n\n（3）将`<ul>`内的字符尺寸直接设为0，即font-size:0。不足：`<ul>`中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。\n\n（4）消除`<ul>`的字符间隔letter-spacing:-8px，不足：这也设置了`<li>`内的字符间隔，因此需要将`<li>`内的字符间隔设为默认letter-spacing:normal。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363853",
    "title": "*14. CSS3中有哪些新特性",
    "content": "### *14. CSS3中有哪些新特性\n\n- 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\n- 圆角 （border-radius:8px）\n- 多列布局 （multi-column layout）\n- 阴影和反射 （Shadoweflect）\n- 文字特效 （text-shadow）\n- 文字渲染 （Text-decoration）\n- 线性渐变 （gradient）\n- 旋转 （transform）\n- 增加了旋转,缩放,定位,倾斜,动画,多背景",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363854",
    "title": "15. 替换元素的概念及计算规则",
    "content": "### 15. 替换元素的概念及计算规则\n\n通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。\n\n替换元素除了内容可替换这一特性以外，还有以下特性：\n\n- **内容的外观不受页面上的CSS的影响**：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。\n- **有自己的尺寸**：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如\n- **在很多CSS属性上有自己的一套表现规则**：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。\n- **所有的替换元素都是内联水平元素**：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。\n\n替换元素的尺寸从内而外分为三类：\n\n- **固有尺寸：** 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。\n- **HTML尺寸：** 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。\n- **CSS尺寸：** 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。\n\n这三层结构的计算规则具体如下：\n\n（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。\n\n（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。\n\n（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。\n\n（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。\n\n（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。\n\n（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363855",
    "title": "*16. 常见的图片格式及使用场景",
    "content": "### *16. 常见的图片格式及使用场景\n\n（1）**BMP**，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。\n\n（2）**GIF**是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。\n\n（3）**JPEG**是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。\n\n（4）**PNG-8**是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。\n\n（5）**PNG-24**是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。\n\n（6）**SVG**是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。\n\n（7）**WebP**是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。\n\n- 在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；\n- 在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；\n- WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363856",
    "title": "*17. 对 CSSSprites 的理解",
    "content": "### *17. 对 CSSSprites 的理解\n\nCSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。\n\n**优点：**\n\n- 利用`CSS Sprites`能很好地减少网页的http请求，从而大大提高了页面的性能，这是`CSS Sprites`最大的优点；\n- `CSS Sprites`能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。\n\n**缺点：**\n\n- 在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；\n- `CSSSprites`在开发的时候相对来说有点麻烦，需要借助`photoshop`或其他工具来对每个背景单元测量其准确的位置。\n- 维护方面：`CSS Sprites`在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的`CSS`，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动`CSS`。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363857",
    "title": "18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？",
    "content": "### 18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？\n\n以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px & 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；\n\n而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。\n\n对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。\n\n![img](https://cdn.nlark.com/yuque/0/2020/jpeg/1500604/1605252903834-27a1d90a-7e04-49bc-822a-dadcf974c141.jpeg#align=left&display=inline&height=1478&margin=[object)\n\n当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。\n\n还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:\n\n```JavaScript\nmy-image { background: (low.png); }\n@media only screen and (min-device-pixel-ratio: 1.5) {\n  #my-image { background: (high.png); }\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363858",
    "title": "19. **margin 和 padding 的使用场景**",
    "content": "### 19. **margin 和 padding 的使用场景**\n\n- 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\n- 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363859",
    "title": "*20. 对**line-height 的理解及其赋值方式**",
    "content": "### *20. 对**line-height 的理解及其赋值方式**\n\n**（1）line-height的概念：**\n\n- line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；\n- 如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；\n- 一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；\n- 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；\n- line-height 和 height 都能撑开一个高度；\n\n**（2）line-height 的赋值方式：**\n\n- 带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高\n- 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px\n- 百分比：将计算后的值传递给后代",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363860",
    "title": "21. CSS 优化和提高性能的方法有哪些？",
    "content": "### 21. CSS 优化和提高性能的方法有哪些？\n\n**加载性能：**\n\n（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。\n\n（2）css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。\n\n（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。\n\n**选择器性能：**\n\n（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；\n\n（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。\n\n（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。\n\n（4）尽量少的去对标签进行选择，而是用class。\n\n（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。\n\n（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。\n\n**渲染性能：**\n\n（1）慎重使用高性能属性：浮动、定位。\n\n（2）尽量减少页面重排、重绘。\n\n（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。\n\n（4）属性值为0时，不加单位。\n\n（5）属性值为浮动小数0.**，可以省略小数点之前的0。\n\n（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。\n\n（7）不使用@import前缀，它会影响css的加载速度。\n\n（8）选择器优化嵌套，尽量避免层级过深。\n\n（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。\n\n（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。\n\n（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。\n\n**可维护性、健壮性：**\n\n（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。\n\n（2）样式与内容分离：将css代码定义到外部css中。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363861",
    "title": "22. CSS预处理器/后处理器是什么？为什么要使用它们？",
    "content": "### 22. CSS预处理器/后处理器是什么？为什么要使用它们？\n\n**预处理器，**如：`less`，`sass`，`stylus`，用来预编译`sass`或者`less`，增加了`css`代码的复用性。层级，`mixin`， 变量，循环， 函数等对编写以及开发UI组件都极为方便。\n\n**后处理器，** 如： `postCss`，通常是在完成的样式表中根据`css`规范处理`css`，让其更加有效。目前最常做的是给`css`属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。\n\n`css`预处理器为`css`增加一些编程特性，无需考虑浏览器的兼容问题，可以在`CSS`中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让`css`更加的简洁，增加适应性以及可读性，可维护性等。\n\n其它`css`预处理器语言：`Sass（Scss）`, `Less`, `Stylus`, `Turbine`, `Swithch css`, `CSS Cacheer`, `DT Css`。\n\n使用原因：\n\n- 结构清晰， 便于扩展\n- 可以很方便的屏蔽浏览器私有语法的差异\n- 可以轻松实现多重继承\n- 完美的兼容了`CSS`代码，可以应用到老项目中",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363862",
    "title": "23. ::before 和 :after 的双冒号和单冒号有什么区别？",
    "content": "### 23. ::before 和 :after 的双冒号和单冒号有什么区别？\n\n（1）冒号(`:`)用于`CSS3`伪类，双冒号(`::`)用于`CSS3`伪元素。\n\n（2）`::before`就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于`dom`之中，只存在在页面之中。\n\n**注意：** `:before `和 `:after` 这两个伪元素，是在`CSS2.1`里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着`Web`的进化，在`CSS3`的规范里，伪元素的语法被修改成使用双冒号，成为`::before`、`::after`。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363863",
    "title": "24. display:inline-block 什么时候会显示间隙？",
    "content": "### 24. display:inline-block 什么时候会显示间隙？\n\n- 有空格时会有间隙，可以删除空格解决；\n- `margin`正值时，可以让`margin`使用负值解决；\n- 使用`font-size`时，可通过设置`font-size:0`、`letter-spacing`、`word-spacing`解决；",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363864",
    "title": "*25. 单行、多行文本溢出隐藏",
    "content": "### *25. 单行、多行文本溢出隐藏\n\n- 单行文本溢出\n\n```CSS\noverflow: hidden;            // 溢出隐藏\ntext-overflow: ellipsis;      // 溢出用省略号显示\nwhite-space: nowrap;         // 规定段落中的文本不进行换行\n```\n- 多行文本溢出\n\n```CSS\noverflow: hidden;            // 溢出隐藏\ntext-overflow: ellipsis;     // 溢出用省略号显示\ndisplay:-webkit-box;         // 作为弹性伸缩盒子模型显示。\n-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列\n-webkit-line-clamp:3;        // 显示的行数\n```\n\n注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个`-webkit-` 来兼容一部分浏览器。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363865",
    "title": "*26. Sass、Less 是什么？为什么要使用他们？ ",
    "content": "### *26. Sass、Less 是什么？为什么要使用他们？ \n\n他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。 \n\n**为什么要使用它们？** \n\n- 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。 \n- 可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363866",
    "title": "*27. 对媒体查询的理解？",
    "content": "### *27. 对媒体查询的理解？\n\n媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。 \n\n媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。 \n\n```JavaScript\n<!-- link元素中的CSS媒体查询 --> \n<link rel=\"stylesheet\" media=\"(max-width: 800px)\" href=\"example.css\" /> \n<!-- 样式表中的CSS媒体查询 --> \n<style> \n@media (max-width: 600px) { \n  .facet_sidebar { \n    display: none; \n  } \n}\n</style>\n```\n\n简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363867",
    "title": "28. 对 CSS 工程化的理解",
    "content": "### 28. 对 CSS 工程化的理解\n\nCSS 工程化是为了解决以下问题：\n\n1. **宏观设计**：CSS 代码如何组织、如何拆分、模块结构怎样设计？\n2. **编码优化**：怎样写出更好的 CSS？\n3. **构建**：如何处理我的 CSS，才能让它的打包结果最优？\n4. **可维护性**：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？\n\n以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：\n\n- 预处理器：Less、 Sass 等；\n- 重要的工程化插件： PostCss；\n- Webpack loader 等 。\n\n基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：\n\n**（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？**\n\n预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码：\n\n![](https://secure2.wostatic.cn/static/dSL4NB5L9Trspb7S3gZJKp/2.png?auth_key=1768101109-dzLpuzPnEMdr2rZ8SjhqoM-0-d6aca97d160b2ecbb362fb00c469fd1d)\n\n那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：\n\n1. 宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；\n2. 编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；\n3. 可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。\n\n这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：\n\n- 嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；\n- 支持定义 css 变量；\n- 提供计算函数；\n- 允许对代码片段进行 extend 和 mixin；\n- 支持循环语句的使用；\n- 支持将 CSS 文件模块化，实现复用。\n\n**（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？**\n\nPostCss 仍然是一个对 CSS 进行解析和处理的工具，它会对 CSS 做这样的事情：\n\n![](https://secure2.wostatic.cn/static/egy4XuqVC3v7MH1MiGi7db/2.png?auth_key=1768101110-3dmr6bQf1UXJ7rhkcEEemZ-0-0c1a968e37bba1c6145bc99737d7931c)\n\n它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。\n\nPostCss 在业务中的使用场景非常多：\n\n- 提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；\n- 当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 [Autoprefixer](https://github.com/postcss/autoprefixer) 插件可以帮助我们自动增加浏览器前缀；\n- 允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；\n\n**（3）Webpack 能处理 CSS 吗？如何实现？**\n\nWebpack 能处理 CSS 吗：\n\n- **Webpack 在裸奔的状态下，是不能处理 CSS 的**，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；\n- Webpack 在 loader 的辅助下，是可以处理 CSS 的。\n\n如何用 Webpack 实现对 CSS 的处理：\n\n- Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader\n- 注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：\n- - css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；\n    - style-loader：创建style标签，把 CSS 内容写入标签。\n\n在实际使用中，**css-loader 的执行顺序一定要安排在 style-loader 的前面**。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363868",
    "title": "29. 如何判断元素是否到达可视区域 ",
    "content": "### 29. 如何判断元素是否到达可视区域 \n\n以图片显示为例：\n\n- `window.innerHeight` 是浏览器可视区的高度；\n- `document.body.scrollTop || document.documentElement.scrollTop` 是浏览器滚动的过的距离；\n- `imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距离）；\n- 内容达到显示区域的：`img.offsetTop < window.innerHeight + document.body.scrollTop;`\n\n![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603966605254-fe880ec0-ebd1-4f94-b662-cdd5e5396c34.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_53%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363869",
    "title": "30. z-index属性在什么情况下会失效",
    "content": "### 30. z-index属性在什么情况下会失效\n\n通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。\n\nz-index属性在下列情况下会失效：\n\n- 父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；\n- 元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；\n- 元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；\n\n## 二、页面布局",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363870",
    "title": "*1. 常见的CSS布局单位",
    "content": "### *1. 常见的CSS布局单位\n\n常用的布局单位包括像素（`px`），百分比（`%`），`em`，`rem`，`vw/vh`。\n\n**（1）像素**（`px`）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：\n\n- **CSS像素**：为web开发者提供，在CSS中使用的一个抽象单位；\n- **物理像素**：只与设备的硬件密度有关，任何设备的物理像素都是固定的。\n\n**（2）百分比**（`%`），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。\n\n**（3）em和rem**相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：**em相对于父元素，rem相对于根元素。**\n\n- **em：** 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。\n- **rem：** rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。**作用**：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。\n\n**（4）vw/vh**是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。\n\n- vw：相对于视窗的宽度，视窗宽度是100vw；\n- vh：相对于视窗的高度，视窗高度是100vh；\n- vmin：vw和vh中的较小值；\n- vmax：vw和vh中的较大值；\n\n**vw/vh** 和百分比很类似，两者的区别：\n\n- 百分比（`%`）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)\n- vw/vm：相对于视窗的尺寸",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363871",
    "title": "*2. px、em、rem的区别及使用场景",
    "content": "### *2. px、em、rem的区别及使用场景\n\n**三者的区别：**\n\n- px是固定的像素，一旦设置了就无法因为适应页面大小而改变。\n- em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。\n- em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。\n\n**使用场景：**\n\n- 对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。\n- 对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363872",
    "title": "*3. 两栏布局的实现",
    "content": "### *3. 两栏布局的实现\n\n一般两栏布局指的是**左边一栏宽度固定，右边一栏宽度自适应**，两栏布局的具体实现：\n\n- 利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。\n\n```CSS\n.outer {\n  height: 100px;\n}\n.left {\n  float: left;\n  width: 200px;\n  background: tomato;\n}\n.right {\n  margin-left: 200px;\n  width: auto;\n  background: gold;\n}\n```\n- 利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。\n\n```CSS\n.left{\n     width: 100px;\n     height: 200px;\n     background: red;\n     float: left;\n }\n .right{\n     height: 300px;\n     background: blue;\n     overflow: hidden;\n }\n```\n- 利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。\n\n```CSS\n.outer {\n  display: flex;\n  height: 100px;\n}\n.left {\n  width: 200px;\n  background: tomato;\n}\n.right {\n  flex: 1;\n  background: gold;\n}\n```\n- 利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。\n\n```CSS\n.outer {\n  position: relative;\n  height: 100px;\n}\n.left {\n  position: absolute;\n  width: 200px;\n  height: 100px;\n  background: tomato;\n}\n.right {\n  margin-left: 200px;\n  background: gold;\n}\n```\n- 利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。\n\n```CSS\n.outer {\n  position: relative;\n  height: 100px;\n}\n.left {\n  width: 200px;\n  background: tomato;\n}\n.right {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 200px;\n  background: gold;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363873",
    "title": "*4. 三栏布局的实现",
    "content": "### *4. 三栏布局的实现\n\n三栏布局一般指的是页面中一共有三栏，**左右两栏宽度固定，中间自适应的布局**，三栏布局的具体实现：\n\n- 利用**绝对定位**，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。\n\n```CSS\n.outer {\n  position: relative;\n  height: 100px;\n}\n\n.left {\n  position: absolute;\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  position: absolute;\n  top: 0;\n  right: 0;\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.center {\n  margin-left: 100px;\n  margin-right: 200px;\n  height: 100px;\n  background: lightgreen;\n}\n```\n- 利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。\n\n```CSS\n.outer {\n  display: flex;\n  height: 100px;\n}\n\n.left {\n  width: 100px;\n  background: tomato;\n}\n\n.right {\n  width: 100px;\n  background: gold;\n}\n\n.center {\n  flex: 1;\n  background: lightgreen;\n}\n```\n- 利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式**，中间一栏必须放到最后：**\n\n```CSS\n.outer {\n  height: 100px;\n}\n\n.left {\n  float: left;\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  float: right;\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.center {\n  height: 100px;\n  margin-left: 100px;\n  margin-right: 200px;\n  background: lightgreen;\n}\n```\n- 圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。\n\n```CSS\n.outer {\n  height: 100px;\n  padding-left: 100px;\n  padding-right: 200px;\n}\n\n.left {\n  position: relative;\n  left: -100px;\n\n  float: left;\n  margin-left: -100%;\n\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  position: relative;\n  left: 200px;\n\n  float: right;\n  margin-left: -200px;\n\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.center {\n  float: left;\n\n  width: 100%;\n  height: 100px;\n  background: lightgreen;\n}\n```\n- 双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。\n\n```CSS\n.outer {\n  height: 100px;\n}\n\n.left {\n  float: left;\n  margin-left: -100%;\n\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  float: left;\n  margin-left: -200px;\n\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.wrapper {\n  float: left;\n\n  width: 100%;\n  height: 100px;\n  background: lightgreen;\n}\n\n.center {\n  margin-left: 100px;\n  margin-right: 200px;\n  height: 100px;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363874",
    "title": "*5. 水平垂直居中的实现",
    "content": "### *5. 水平垂直居中的实现\n\n- 利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要**考虑浏览器兼容问题。**\n\n```CSS\n.parent {\n    position: relative;\n}\n \n.child {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%,-50%);\n}\n```\n- 利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于**盒子有宽高**的情况：\n\n```CSS\n.parent {\n    position: relative;\n}\n \n.child {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    margin: auto;\n}\n```\n- 利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于**盒子宽高已知**的情况\n\n```CSS\n.parent {\n    position: relative;\n}\n \n.child {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -50px;     /* 自身 height 的一半 */\n    margin-left: -50px;    /* 自身 width 的一半 */\n}\n```\n- 使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要**考虑兼容的问题**，该方法在移动端用的较多：\n\n```CSS\n.parent {\n    display: flex;\n    justify-content:center;\n    align-items:center;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363875",
    "title": "6. 如何根据设计稿进行移动端适配？",
    "content": "### 6. 如何根据设计稿进行移动端适配？\n\n移动端适配主要有两个维度：\n\n- **适配不同像素密度，**针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；\n- **适配不同屏幕大小，**由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。\n\n为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363876",
    "title": "*7. 对Flex布局的理解及其使用场景",
    "content": "### *7. 对Flex布局的理解及其使用场景\n\nFlex是FlexibleBox的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，**子元素的float、clear和vertical-align属性将失效**。采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称\"项目\"。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。\n\n以下6个属性设置在**容器上**：\n\n- flex-direction属性决定主轴的方向（即项目的排列方向）。\n- flex-wrap属性定义，如果一条轴线排不下，如何换行。\n- flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n- justify-content属性定义了项目在主轴上的对齐方式。\n- align-items属性定义项目在交叉轴上如何对齐。\n- align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n以下6个属性设置在**项目上**：\n\n- order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n- flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n- flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n- flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n- flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。\n- align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n**简单来说：**\n\nflex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363877",
    "title": "*8. flex:1 表示什么",
    "content": "### *8. flex:1 表示什么\n\nflex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。flex:1 表示 flex: 1 1 0%**：**\n\n- 第一个参数表示: **flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大；**\n- 第二个参数表示: **flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小；**\n- 第三个参数表示: **flex-basis给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小。**",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363878",
    "title": "9. 响应式设计的概念及基本原理",
    "content": "### 9. 响应式设计的概念及基本原理\n\n响应式网站设计`（Responsive Web design`）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。\n\n关于原理： 基本原理是通过媒体查询`（@media）`查询检测不同的设备屏幕尺寸做处理。\n\n关于兼容： 页面头部必须有mate声明的`viewport`。\n\n```HTML\n<meta name=\"’viewport’\" content=\"”width=device-width,\" initial-scale=\"1.\" maximum-scale=\"1,user-scalable=no”\"/>\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363879",
    "title": "10. 实现“品” 字布局",
    "content": "### 10. 实现“品” 字布局\n\n品字布局就像下图这样：\n\n![](https://secure2.wostatic.cn/static/qNUJV3D2LJoesNEtijsLdY/2.png?auth_key=1768101118-wj7FMWqYgJTjjaQg2moKf-0-f0e1fdf2050c9c925762ba7c67c63377)\n\n**（1）浮动实现**\n\n我们可以使用定位实现，对于上面的1，使用magin属性让他水平居中；下面的两个使用浮动即可实现，其HTML结构如下：\n\n```HTML\n<div class=\"div1\">1</div>\n<div class=\"div2\">2</div>\n<div class=\"div3\">3</div>\n```\n\nCSS代码如下：\n\n```CSS\ndiv{ \n  width:100px; \n  height:100px; \n  font-size:40px; \n  line-height:100px; \n  color:#fff; \n  text-align:center;\n}\n\n.div1{ \n  background:red; \n  margin:0 auto;\n}\n\n.div2{ \n  background: green; \n  float:left; \n  margin-left: 50%;\n}\n\n.div3{ \n  background: blue; \n  float:left; \n  margin-left: -200px;\n}\n```\n\n该方法是在在三个盒子的宽高都知道的情况下才能实现的。\n\n**（2）inline-block实现**\n\nHTML结构如下：\n\n```CSS\n<div class=\"div1\">1</div>\n<div class=\"div2\">2</div>\n<div class=\"div3\">3</div>\n```\n\n这里将div设置为了inline-block，实际上和上面的float的作用是一眼的，就是让下面的两个块不换行。使用CSS样式如下：\n\n```CSS\ndiv{ \n  width:100px; \n  height:100px; \n  font-size:40px; \n  line-height:100px; \n  color:#fff; \n  text-align:center;\n}\n\n.div1{ \n  background:red; \n  margin:0 auto;\n}\n\n.div2{ \n  background: green; \n  display: inline-block;\n  margin-left: 50%;\n}\n\n.div3{ \n  background: blue; \n  display: inline-block;\n  margin-left: -200px;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363880",
    "title": "11. 实现九宫格布局",
    "content": "### 11. 实现九宫格布局\n\n实现效果如下：\n\n![](https://secure2.wostatic.cn/static/sqoWDdP76D4C18pRffzdJa/2.png?auth_key=1768101120-5KuoXzC7TPiUBdNnYyX7VM-0-f64d684e0b1d85efa9b06d17921e4efb)\n\n首先，定义好通用的HTML结构：\n\n```HTML\n<div class=\"box\">\n  <ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n    <li>6</li>\n    <li>7</li>\n    <li>8</li>\n    <li>9</li>\n  </ul>\n</div>\n```\n\n公共样式：\n\n```HTML\nul {\n  padding: 0;\n}\n\nli { \n  list-style: none;\n  text-align: center;\n  border-radius: 5px;\n  background: skyblue;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363881",
    "title": "# （1）flex实现",
    "content": "#### （1）flex实现\n\n对于九宫格布局，我首先想到的就是flex布局，flex布局实现九宫格很简单，需要设置一个flex-wrap: wrap;使得盒子在该换行的时候进行换行。\n\n由于我们给每个元素设置了下边距和右边距，所以最后同一列（3、6、9）的右边距和最后一行（7、8、9）的下边距撑大了ul，所以这里使用类型选择器来消除他们的影响。最终的实现代码如下：\n\n```CSS\nul {\n  display: flex;\n  flex-wrap: wrap;\n  width: 100%;\n  height: 100%;\n}\n\nli {\n  width: 30%;\n  height: 30%;\n  margin-right: 5%;\n  margin-bottom: 5%;\n}\n\nli:nth-of-type(3n){ \n  margin-right: 0;\n}\n\nli:nth-of-type(n+7){ \n  margin-bottom: 0;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363882",
    "title": "# （2）grid实现",
    "content": "#### （2）grid实现\n\ngrid布局相对于flex布局来说，实现九宫格就更加容易了，只需要设置几个属性即可：\n\n```CSS\nul {\n  width: 100%;\n  height: 100%;\n  display: grid;\n  grid-template-columns: 30% 30% 30%; \n  grid-template-rows: 30% 30% 30%; \n  grid-gap: 5%; \n}\n```\n\n其中grid-template-columns属性用来设置每一行中单个元素的宽度，grid-template-rows属性用来设置每一列中单个元素的高度，grid-gap属性用来设置盒子之间的间距。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363883",
    "title": "# （3）float实现",
    "content": "#### （3）float实现\n\n这里首先需要给父元素的div设置一个宽度，宽度值为：**盒子宽 * 3 + 间距 * 2；**然后给每个盒子设置固定的宽高，为了让他换行，可以使用float来实现，由于子元素的浮动，形成了BFC，所以父元素ul使用overflow:hidden；来消除浮动带来的影响。最终的实现代码如下：\n\n```CSS\nul {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n\nli {\n  float: left;\n  width: 30%;\n  height: 30%;\n  margin-right: 5%;\n  margin-bottom: 5%;\n}\n\nli:nth-of-type(3n){ \n  margin-right: 0;\n}\n\nli:nth-of-type(n+7){ \n  margin-bottom: 0;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.846Z",
    "updatedAt": "2026-01-11T03:16:03.846Z"
  },
  {
    "id": "1768101363884",
    "title": "# （4）inline-block实现",
    "content": "#### （4）inline-block实现\n\n其实inline-block的作用和上面float的作用是一样的，都是用来让元素换行的，实现代码如下：\n\n```CSS\nul {\n  width: 100%;\n  height: 100%;\n  letter-spacing: -10px;\n}\n\nli {\n  width: 30%;\n  height: 30%;\n  display: inline-block;\n  margin-right: 5%;\n  margin-bottom: 5%;\n}\n\nli:nth-of-type(3n){ \n  margin-right: 0;\n}\n\nli:nth-of-type(n+7){ \n  margin-bottom: 0;\n}\n```\n\n需要注意的是，设置为inline-block的元素之间可能会出现间隙，就可能出现下面这种情况：\n\n![](https://secure2.wostatic.cn/static/cofmpLkWBYzrEBP43Qw7Mm/2.png?auth_key=1768101123-vv1AiP9Jmfufo5nQ3i2g8s-0-08cfcdd6580a76b27a6221628234f436)\n\n这里使用了letter-spacing属性来消除这种影响，该属性可以用来增加或减少字符间的空白（字符间距）。使用之后就正常了，出现了预期的效果。也可以给ul设置font-size: 0;来消除盒子之间的字符间距：\n\n```CSS\nul {\n  font-size: 0;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363885",
    "title": "# （5）table实现",
    "content": "#### （5）table实现\n\nHTML结构：\n\n```HTML\n<ul class=\"table\">\n  <li>\n    <div>1</div>\n    <div>2</div>\n    <div>3</div>\n  </li>\n  <li>\n    <div>4</div>\n    <div>5</div>\n    <div>6</div>\n  </li>\n  <li>\n    <div>7</div>\n    <div>8</div>\n    <div>9</div>\n  </li>\n</ul>\n```\n\ntable布局也不算太难，首先给父元素设置为table布局，然后使用border-spacing设置单元格之间的间距，最后将li设置为表格行，将div设置为表格单元格，CSS样式如下：\n\n```CSS\n.table {\n  width: 100%;\n  height: 100%;\n  display: table;\n  border-spacing: 10px;\n}\n\nli {\n  display: table-row; \n}\n\ndiv {\n  width: 30%;\n  height: 30%;\n  display: table-cell;\n  text-align: center;\n  border-radius: 5px;\n  background: skyblue;\n}\n```\n\n## 三、定位与浮动",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363886",
    "title": "*1. 为什么需要清除浮动？清除浮动的方式",
    "content": "### *1. 为什么需要清除浮动？清除浮动的方式\n\n**浮动的定义：** 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。\n\n**浮动的工作原理：**\n\n- 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）\n- 浮动元素碰到包含它的边框或者其他浮动元素的边框停留\n\n浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。\n\n**浮动元素引起的问题？**\n\n- 父元素的高度无法被撑开，影响与父元素同级的元素\n- 与浮动元素同级的非浮动元素会跟随其后\n- 若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构\n\n**清除浮动的方式如下：**\n\n- 给父级div定义`height`属性\n- 最后一个浮动元素之后添加一个空的div标签，并添加`clear:both`样式\n- 包含浮动元素的父级标签添加`overflow:hidden`或者`overflow:auto`\n- 使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**\n\n```CSS\n.clearfix:after{\n    content: \"\\200B\";\n    display: table; \n    height: 0;\n    clear: both;\n  }\n  .clearfix{\n    *zoom: 1;\n  }\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363887",
    "title": "2. 使用 clear 属性清除浮动的原理？",
    "content": "### 2. 使用 clear 属性清除浮动的原理？\n\n使用clear属性清除浮动，其语法如下：\n\n```CSS\nclear:none|left|right|both\n```\n\n如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。\n\n官方对clear属性解释：“**元素盒子的边不能和前面的浮动元素相邻**”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。\n\n还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“**前面的**”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。\n\n一般使用伪元素的方式清除浮动：\n\n```CSS\n.clear::after{\n  content:'';\n  display: block; \n  clear:both;\n}\n```\n\nclear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363888",
    "title": "*3. 对BFC的理解，如何创建BFC",
    "content": "### *3. 对BFC的理解，如何创建BFC\n\n先来看两个相关的概念：\n\n- Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。 \n- Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。 \n\n块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。\n\n通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。\n\n**创建BFC的条件：**\n\n- 根元素：body；\n- 元素设置浮动：float 除 none 以外的值；\n- 元素设置绝对定位：position (absolute、fixed)；\n- display 值为：inline-block、table-cell、table-caption、flex等；\n- overflow 值为：hidden、auto、scroll；\n\n**BFC的特点：**\n\n- 垂直方向上，自上而下排列，和文档流的排列方式一致。\n- 在BFC中上下相邻的两个容器的margin会重叠\n- 计算BFC的高度时，需要计算浮动元素的高度\n- BFC区域不会与浮动的容器发生重叠\n- BFC是独立的容器，容器内部元素不会影响外部元素\n- 每个元素的左margin值和容器的左border相接触\n\n**BFC的作用：**\n\n- **解决margin的重叠问题**：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。\n- **解决高度塌陷的问题**：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置`overflow:hidden`。\n- **创建自适应两栏布局**：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。\n\n```CSS\n.left{\n     width: 100px;\n     height: 200px;\n     background: red;\n     float: left;\n }\n .right{\n     height: 300px;\n     background: blue;\n     overflow: hidden;\n }\n \n<div class=\"left\"></div>\n<div class=\"right\"></div>\n```\n\n左侧设置`float:left`，右侧设置`overflow: hidden`。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363889",
    "title": "*4. 什么是margin重叠问题？如何解决？",
    "content": "### *4. 什么是margin重叠问题？如何解决？\n\n**问题描述：**\n\n两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，**浮动的元素和绝对定位**这种脱离文档流的元素的外边距不会折叠。重叠只会出现在**垂直方向**。\n\n**计算原则：**\n\n折叠合并后外边距的计算原则如下：\n\n- 如果两者都是正数，那么就去最大者\n- 如果是一正一负，就会正值减去负值的绝对值\n- 两个都是负值时，用0减去两个中绝对值大的那个\n\n**解决办法：**\n\n对于折叠的情况，主要有两种：**兄弟之间重叠**和**父子之间重叠**\n\n（1）兄弟之间重叠\n\n- 底部元素变为行内盒子：`display: inline-block`\n- 底部元素设置浮动：`float`\n- 底部元素的position的值为`absolute/fixed`\n\n（2）父子之间重叠\n\n- 父元素加入：`overflow: hidden`\n- 父元素添加透明边框：`border:1px solid transparent`\n- 子元素变为行内盒子：`display: inline-block`\n- 子元素加入浮动属性或定位",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363890",
    "title": "5. 元素的层叠顺序",
    "content": "### 5. 元素的层叠顺序\n\n层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603553952688-ad155942-9d1d-4e4b-86a7-0f7dca46e6d1.png#align=left&display=inline&height=360&margin=[object)\n\n对于上图，由上到下分别是：\n\n（1）背景和边框：建立当前层叠上下文元素的背景和边框。\n\n（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。\n\n（3）块级盒：文档流内非行内级非定位后代元素。\n\n（4）浮动盒：非定位浮动元素。\n\n（5）行内盒：文档流内行内级非定位后代元素。\n\n（6）z-index:0：层叠级数为0的定位元素。\n\n（7）正z-index：z-index属性值为正的定位元素。\n\n**注意:** 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363891",
    "title": "*6. position的属性有哪些，区别是什么",
    "content": "### *6. position的属性有哪些，区别是什么\n\nposition有以下属性值：\n\n| 属性值   | 概述                                                         |\n| -------- | ------------------------------------------------------------ |\n| absolute | 生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。 |\n| relative | 生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。 |\n| fixed    | 生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。 |\n| static   | 默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。 |\n| inherit  | 规定从父元素继承position属性的值                             |\n\n\n前面三者的定位方式如下：\n\n- **relative：**元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694939-58dfe7f7-2fc9-45e5-9961-a953f95496a7.png#align=left&display=inline&height=105&margin=[object)\n\n- **fixed：**元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694841-89472ba9-b236-4098-802f-c3c26ff49466.png#align=left&display=inline&height=117&margin=[object)\n\n- **absolute：**元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了`position:relative/absolute/fixed`的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694882-589670e0-cd52-41d4-a3ed-4ebbdfc88f32.png#align=left&display=inline&height=142&margin=[object)\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694842-2764d9ed-d5fe-45f4-8ede-34a73d237f94.png#align=left&display=inline&height=118&margin=[object)",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363892",
    "title": "*7. **display、float、position的关系**",
    "content": "### *7. **display、float、position的关系**\n\n（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。\n\n（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。\n\n（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。\n\n（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。\n\n总的来说，可以把它看作是一个类似优先级的机制，\"position:absolute\"和\"position:fixed\"优先级最高，有它存在的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是\"none\"的时候或者它是根元素的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363893",
    "title": "8. absolute与fixed共同点与不同点",
    "content": "### 8. absolute与fixed共同点与不同点\n\n**共同点：**\n\n- 改变行内元素的呈现方式，将display置为inline-block \n- 使元素脱离普通文档流，不再占据文档物理空间\n- 覆盖非定位文档元素\n\n**不同点：**\n\n- absolute与fixed的根元素不同，absolute的根元素可以设置，fixed根元素是浏览器。\n- 在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363894",
    "title": "9. 对 sticky 定位的理解",
    "content": "### 9. 对 sticky 定位的理解\n\nsticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：**position: sticky;** 基于用户的滚动位置来定位。\n\n粘性定位的元素是依赖于用户的滚动，在 **position:relative** 与 **position:fixed** 定位之间切换。它的行为就像 **position:relative;** 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n\n## 四、场景应用",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363895",
    "title": "*1. 实现一个三角形",
    "content": "### *1. 实现一个三角形\n\nCSS绘制三角形主要用到的是border属性，也就是边框。\n\n平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：\n\n```CSS\ndiv {\n    width: 0;\n    height: 0;\n    border: 100px solid;\n    border-color: orange blue red green;\n}\n```\n\n将元素的长宽都设置为0，显示出来的效果是这样的：\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245125-d60dca78-0577-4aa1-8809-f1d38594889a.png#align=left&display=inline&height=298&margin=[object)\n\n所以可以根据border这个特性来绘制三角形：\n\n**（1）三角1**\n\n```CSS\ndiv {\n    width: 0;\n    height: 0;\n    border-top: 50px solid red;\n    border-right: 50px solid transparent;\n    border-left: 50px solid transparent;\n}\n\n\n```\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245420-28c28277-5074-4725-9386-ffc955cf950a.png#align=left&display=inline&height=132&margin=[object)\n\n**（2）三角2**\n\n```CSS\ndiv {\n    width: 0;\n    height: 0;\n    border-bottom: 50px solid red;\n    border-right: 50px solid transparent;\n    border-left: 50px solid transparent;\n}\n\n\n```\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245172-36f955bd-075b-442a-b88b-6c084c66ed25.png#align=left&display=inline&height=133&margin=[object)\n\n**（3）三角3**\n\n```CSS\ndiv {\n    width: 0;\n    height: 0;\n    border-left: 50px solid red;\n    border-top: 50px solid transparent;\n    border-bottom: 50px solid transparent;\n}\n\n\n```\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245082-84a06746-dfc7-4782-a0d4-27d521aecac7.png#align=left&display=inline&height=195&margin=[object)\n\n**（4）三角4**\n\n```CSS\ndiv {\n    width: 0;\n    height: 0;\n    border-right: 50px solid red;\n    border-top: 50px solid transparent;\n    border-bottom: 50px solid transparent;\n}\n\n\n```\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245064-ecd01197-99fc-476e-897f-a4165b55792a.png#align=left&display=inline&height=191&margin=[object)\n\n**（5）三角5**\n\n```CSS\ndiv {\n    width: 0;\n    height: 0;\n    border-top: 100px solid red;\n    border-right: 100px solid transparent;\n}\n\n\n```\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245095-5b40d585-7e68-4bb0-aaef-6c8fce7d36b8.png#align=left&display=inline&height=177&margin=[object)\n\n还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363896",
    "title": "*2. 实现一个扇形",
    "content": "### *2. 实现一个扇形\n\n用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：\n\n```CSS\ndiv{\n    border: 100px solid transparent;\n    width: 0;\n    height: 0;\n    border-radius: 100px;\n    border-top-color: red;\n}\n\n\n```\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636444767-26da7bbe-5479-44e2-9088-50c9211d6c0d.png#align=left&display=inline&height=190&margin=[object)",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363897",
    "title": "3. 实现一个圆和半圆",
    "content": "### 3. 实现一个圆和半圆\n\n**（1）实现圆：**\n\n```CSS\ndiv {\n  background-color: red;\n  height: 100px;\n  width: 100px;\n  border-radius: 50%;\n}\n```\n\n**注意：**在使用border-radius时，使用50%和100%都可以得到一个圆，那这两个值到底有什么区别呢：border-radius的值是百分比的话，就相当于盒子的宽度和高度的百分比。如一个50px 150px的方形，如果border-radius设置为100%，则等价于：\n\n```CSS\nborder-radius: 50px/150px; 1\n```\n\n而border-radius又是由border-top-left-radius、border-top-right-radius、border-bottom-left-radius、border-bottom-right-radius组成，所有上面border-radius：100%又等价于：\n\n```CSS\nborder-top-left-radius: 100%; \nborder-top-right-radius: 100%; \nborder-bottom-left-radius: 100%; \nborder-bottom-right-radius: 100%;\n```\n\n或\n\n```CSS\nborder-top-left-radius: 50px 150px; \nborder-top-right-radius: 50px 150px; \nborder-bottom-left-radius: 50px 150px; \nborder-bottom-right-radius: 50px 150px; \n```\n\n为什么border-radius设置成100%和50%都能画成圆呢？因为，在W3C中对重合曲线做了规定：如果两个相邻的半径和超过了对应的盒子的边的长度，那么浏览器要重新计算以保证它们不重合。也就是说，如果相邻圆角的半径都设置成大于50%，那么浏览器会根据图形的实际情况做一些计算。因此，为了避免不必要的计算，建议使用border-radius: 50%。\n\n**（2）实现半圆：**\n\n```CSS\ndiv {\n  background-color: red;\n  width: 100px;\n  height: 50px;\n  border-radius: 0px 0px 100px 100px;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363898",
    "title": "*4. 实现一个宽高自适应的正方形",
    "content": "### *4. 实现一个宽高自适应的正方形\n\n- 利用vw来实现：\n\n```CSS\n.square {\n  width: 10%;\n  height: 10vw;\n  background: tomato;\n}\n```\n- 利用元素的margin/padding百分比是相对父元素width的性质来实现：\n\n```CSS\n.square {\n  width: 20%;\n  height: 0;\n  padding-top: 20%;\n  background: orange;\n}\n```\n- 利用子元素的margin-top的值来实现：\n\n```CSS\n.square {\n  width: 30%;\n  overflow: hidden;\n  background: yellow;\n}\n.square::after {\n  content: '';\n  display: block;\n  margin-top: 100%;\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363899",
    "title": "*4. 画一个梯形",
    "content": "### *4. 画一个梯形\n\n```JavaScript\n<div class=\"trapezoid\"></div>\n```\n\n（1）实现一个直角梯形：\n\n```CSS\n.trapezoid {\n    height: 0;\n    width: 100px;\n    border-bottom: 100px solid red;\n    border-right: 40px solid transparent;\n}\n```\n\n效果：\n\n![](https://secure2.wostatic.cn/static/bF5z5QZty2xMtzFJ7cJmmb/image.png?auth_key=1768101140-hSjFRSv3ok3TjV6CqJ9irJ-0-3c75321b0bf1e24d74c00318627c780f)\n\n（2）实现一个等腰梯形\n\n```CSS\n.trapezoid {\n  height:0;\n  width:100px;\n  border-width:0 40px 100px 40px;\n  border-style:none solid solid;\n  border-color:transparent transparent red;\n}\n```\n\n效果：\n\n![](https://secure2.wostatic.cn/static/b4jXpoJLrVTQ4hhueMejit/image.png?auth_key=1768101141-2zjvD7ejKqSgZwPayZTQ8j-0-f86893a45717625e5d594b187e05d41e)",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363900",
    "title": "*5. 画一条0.5px的线",
    "content": "### *5. 画一条0.5px的线\n\n- **采用transform: scale()的方式**，该方法用来定义元素的2D 缩放转换：\n\n```CSS\ntransform: scale(0.5,0.5);\n```\n- **采用meta viewport的方式**\n\n```CSS\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5\"/>\n```\n\n这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363901",
    "title": "6. 设置小于12px的字体",
    "content": "### 6. 设置小于12px的字体\n\n在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。\n\n**解决办法：**\n\n- 使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。\n- 使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/...；\n- 使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363902",
    "title": "7. 如何解决 1px 问题？",
    "content": "### 7. 如何解决 1px 问题？\n\n1px 问题指的是：在一些 `Retina屏幕` 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：\n\n```HTML\nwindow.devicePixelRatio = 设备的物理像素 / CSS像素。\n```\n\n打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 `devicePixelRatio` 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2：\n\n![](https://secure2.wostatic.cn/static/fUhQQ19QxadSknV4aSTm5H/image.png?auth_key=1768101144-acUdSV43bG36Qii5XWo76p-0-6b06668db304ebf3b982192696d869be)\n\n这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。\n\n解决**1px 问题的三种思路：**",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363903",
    "title": "# 思路一：直接写 0.5px",
    "content": "#### 思路一：直接写 0.5px\n\n如果之前 1px 的样式这样写：\n\n```CSS\nborder:1px solid #333\n```\n\n可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：\n\n```JavaScript\n<div id=\"container\" data-device={{window.devicePixelRatio}}></div>\n```\n\n然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：\n\n```CSS\n#container[data-device=\"2\"] {\n  border:0.5px solid #333\n}\n```\n\n直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363904",
    "title": "# 思路二：伪元素先放大后缩小",
    "content": "#### 思路二：伪元素先放大后缩小\n\n这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。\n\n思路是**先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的**宽和高都设置为目标元素的两倍，border值设为 1px。**接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一**，间接地实现了 0.5px 的效果。\n\n代码如下：\n\n```CSS\n#container[data-device=\"2\"] {\n    position: relative;\n}\n#container[data-device=\"2\"]::after{\n      position:absolute;\n      top: 0;\n      left: 0;\n      width: 200%;\n      height: 200%;\n      content:\"\";\n      transform: scale(0.5);\n      transform-origin: left top;\n      box-sizing: border-box;\n      border: 1px solid #333;\n    }\n}\n```",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768101363905",
    "title": "# 思路三：viewport 缩放来解决",
    "content": "#### 思路三：viewport 缩放来解决\n\n这个思路就是对 meta 标签里几个关键属性下手：\n\n```HTML\n<meta name=\"viewport\" content=\"initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no\">\n```\n\n这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：\n\n```JavaScript\nconst scale = 1 / window.devicePixelRatio;\n// 这里 metaEl 指的是 meta 标签对应的 Dom\nmetaEl.setAttribute('content', `width=device-width,user-scalable=no,initial-scale=${scale},maximum-scale=${scale},minimum-scale=${scale}`);\n```\n\n这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。",
    "categoryId": "1768000001002",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:16:03.847Z",
    "updatedAt": "2026-01-11T03:16:03.847Z"
  },
  {
    "id": "1768102144328",
    "title": "src和href的区别",
    "content": "<p><strong>回答：</strong></p>\n<p>**src 用于替换当前元素，href 建立链接（指向外部资源，不替换当前元素）**🍇</p>\n<p>（1）src</p>\n<pre><code class=\"language-HTML\">&lt;script src=\"”js.js”\"&gt;&lt;/script&gt;\n\n</code></pre>\n<p>src会阻塞浏览器后续资源的加载和解析，必须等它加载完才能继续（所以JS脚本通常放在页面底部，避免阻塞渲染）</p>\n<p>(2) href</p>\n<p>href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果在文档中添加</p>\n<pre><code class=\"language-HTML\">&lt;link href=”common.css” rel=”stylesheet”/&gt;\n</code></pre>\n<p>会并行下载资源,不阻塞当前文档的处理（所以CSS用link标签加载，不会影响页面渲染）</p>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:29:04.328Z",
    "updatedAt": "2026-01-11T03:29:04.328Z"
  },
  {
    "id": "1768102171094",
    "title": "对HTML语义化的理解",
    "content": "<p><strong>回答：</strong></p>\n<p>语义化是指<strong>用正确的标签做正确的事，根据内容结构选合适的标签</strong>。</p>\n<p>语义化的优点如下：</p>\n<ul>\n<li>对机器友好，搜索引擎能更好地抓取信息（有利于SEO），读屏软件也能正确识别；</li>\n<li>对开发者友好，代码结构清晰，维护起来方便</li>\n</ul>\n<p>常见的语义化标签：</p>\n<pre>&lt;header&gt;&lt;/header&gt;  头部<br>&lt;nav&gt;&lt;/nav&gt;  导航栏<br>&lt;section&gt;&lt;/section&gt;  区块（有语义化的div）<br>&lt;main&gt;&lt;/main&gt;  主要区域<br>&lt;article&gt;&lt;/article&gt;  主要内容<br>&lt;aside&gt;&lt;/aside&gt;  侧边栏<br>&lt;footer&gt;&lt;/footer&gt;  底部</pre>\n\n\n\n\n\n",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:29:31.094Z",
    "updatedAt": "2026-01-11T03:29:31.094Z"
  },
  {
    "id": "1768102201302",
    "title": "DOCTYPE(⽂档类型) 的作⽤",
    "content": "<p><strong>回答：</strong></p>\n<p>DOCTYPE是HTML文档第一行的声明，作用是告诉浏览器用什么规则解析网页。 它会影响浏览器的渲染模式：如果有正确的DOCTYPE，浏览器用“标准模式”（按W3C标准解析）；如果没有或写错了，可能会用“怪异模式”（兼容旧网页的松散规则）。</p>\n<p><strong>解析：</strong></p>\n<p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义<strong>来解析文档</strong>，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p>\n<p>浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p>\n<ul>\n<li><strong>CSS1Compat：标准模式（Strick mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li>\n<li><strong>BackCompat：怪异模式(混杂模式)(Quick mode)</strong>，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:30:01.303Z",
    "updatedAt": "2026-01-11T03:30:01.303Z"
  },
  {
    "id": "1768102255352",
    "title": "script标签中defer和async的区别",
    "content": "<p><strong>回答：</strong></p>\n<p>script标签的defer和async都是用来异步加载JS脚本的，不会阻塞HTML解析。 它们的区别主要在执行顺序和时机：</p>\n<ol>\n<li>执行顺序 ：async脚本谁先加载完谁先执行，没有固定顺序；defer脚本严格按HTML中的顺序执行。</li>\n<li>执行时机 ：async脚本加载完成后立即执行（可能打断HTML解析）；defer脚本等HTML完全解析完才执行。 比如统计代码适合用async，因为它不依赖其他脚本；而依赖jQuery的插件适合用defer，因为需要保证jQuery先加载执行。</li>\n</ol>\n<p><strong>解析：</strong></p>\n<p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p>\n<p>下图可以直观的看出三者之间的区别:</p><p><div>\n          <div class=\"image-wrapper relative inline-block\" data-id=\"img-1768102252180\">\n            <img src=\"/api/images/1768102252173_o3diu7.png\" alt=\"上传的图片\" style=\"max-width: 100%; height: auto;\">\n          </div>\n        </div><br></p>\n<p><img src=\"https://secure2.wostatic.cn/static/pDxTtgxUjNyhp3qBV3aAcY/image.png?auth_key=1768101425-aX29hbuz2r2AZX5MRR44Xo-0-d9e8040c0eafad75cea439b98ffc835f\" alt=\"\"></p>\n<p>其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。</p>\n<p><strong>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p>\n<ul>\n<li>**执行顺序：**多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li>\n<li><strong>脚本是否并行执行：async属性，表示</strong>后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:30:55.352Z",
    "updatedAt": "2026-01-11T03:30:55.352Z"
  },
  {
    "id": "1768102319079",
    "title": "常⽤的meta标签有哪些",
    "content": "<p>meta标签是HTML里用来描述网页属性的辅助标签，在里，不显示在页面上。 常用的有这几个：</p>\n<ol>\n<li>charset ：设置编码为UTF-8，避免乱码；</li>\n<li>keywords/description ：给搜索引擎看的关键词和简介，帮助SEO；</li>\n<li>viewport ：移动端适配必须加，让页面占满屏幕；</li>\n<li>refresh ：设置自动刷新或跳转页面；</li>\n<li>robots ：控制搜索引擎爬虫是否索引页面。</li>\n</ol>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:31:59.079Z",
    "updatedAt": "2026-01-11T03:31:59.079Z"
  },
  {
    "id": "1768102353830",
    "title": "HTML5有哪些更新",
    "content": "<p>HTML5的更新主要有这几个方面：</p>\n<ol>\n<li>语义化标签 ：新增header、nav、footer、article等，让HTML结构更清晰，对SEO友好；</li>\n<li>多媒体支持 ：audio、video标签原生播放音视频，告别Flash；</li>\n<li>表单增强 ：新的输入类型（email、date、color等）和属性（placeholder、required等），减少JS验证；</li>\n<li>客户端存储 ：localStorage和sessionStorage，比Cookie容量大、更安全；</li>\n<li>新API ：Canvas绘图、Geolocation定位、Web Worker后台线程、WebSocket实时通信等；</li>\n<li>移除过时元素 ：比如font、center、frameset这些纯表现或过时的标签。</li>\n</ol>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:32:33.830Z",
    "updatedAt": "2026-01-11T03:32:33.830Z"
  },
  {
    "id": "1768102379475",
    "title": "img的srcset属性的作⽤？",
    "content": "<p><strong>回答：</strong></p>\n<p>img的srcset属性是用来实现响应式图片的，让浏览器根据不同屏幕条件自动选图片。 主要解决两个问题：小屏幕加载大图片浪费流量，大屏幕加载小图片显示模糊。</p>\n<p><strong>解析：</strong></p>\n<p>响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：</p>\n<pre><code class=\"language-HTML\">&lt;img src=\"image-128.png\" srcset=\"image-256.png 2x\" /&gt;\n</code></pre>\n<p>使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。</p>\n<p>按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：</p>\n<pre><code class=\"language-HTML\">&lt;img src=\"image-128.png\"\n\n  srcset=\"image-128.png 128w, image-256.png 256w, image-512.png 512w\"\n\n  sizes=\"(max-width: 360px) 340px, 128px\" /&gt;\n</code></pre>\n<p>其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。</p>\n<p>sizes语法如下：</p>\n<p>sizes=\"[media query] [length], [media query] [length] ... \"</p>\n<p>sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。</p>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:32:59.475Z",
    "updatedAt": "2026-01-11T03:32:59.475Z"
  },
  {
    "id": "1768102401986",
    "title": "行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？",
    "content": "<ul>\n<li>行内元素有：<code>a b span img input select strong</code>；</li>\n<li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li>\n</ul>\n<p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p>\n<ul>\n<li>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li>\n<li>鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:33:21.986Z",
    "updatedAt": "2026-01-11T03:33:21.986Z"
  },
  {
    "id": "1768102421290",
    "title": "对 web worker 的理解",
    "content": "<p><strong>回答：</strong></p>\n<p>Web Worker是HTML5的后台线程技术，主要用来解决JS单线程阻塞的问题。</p>\n<p>它的特点是：运行在主线程之外，不影响页面响应；通过postMessage和onmessage与主线程通信；不能访问DOM/BOM，只能做计算。</p>\n<p><strong>解析：</strong></p>\n<p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>\n<p>如何创建 web worker：</p>\n<ol>\n<li>检测浏览器对于 web worker 的支持性</li>\n<li>创建 web worker 文件（js，回传函数等）</li>\n<li>创建 web worker 对象</li>\n</ol>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:33:41.290Z",
    "updatedAt": "2026-01-11T03:33:41.290Z"
  },
  {
    "id": "1768102449114",
    "title": "HTML5的离线储存怎么使用，它的工作原理是什么",
    "content": "<p><strong>回答：</strong></p>\n<p>HTML5离线存储是让网页断网也能访问的缓存机制，基于.appcache文件实现。</p>\n<p>工作原理：浏览器解析.appcache清单，缓存指定资源，离线时自动从本地加载。</p>\n<p><strong>解析：</strong></p>\n<p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>\n<p>**原理：**HTML5的离线存储是基于一个新建的 <code>.appcache</code> 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>\n<p><strong>使用方法：</strong></p>\n<p>（1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p>\n<pre><code class=\"language-HTML\">&lt;html lang=\"en\" manifest=\"index.manifest\"&gt;\n</code></pre>\n<p>（2）在 <code>cache.manifest</code> 文件中编写需要离线存储的资源：</p>\n<p>CACHE MANIFEST</p>\n<pre><code>#v0.11\n\nCACHE:\n\njs/app.js\n\ncss/style.css\n\nNETWORK:\n\nresourse/logo.png\n\nFALLBACK:\n\n/ /offline.html\n</code></pre>\n<ul>\n<li><strong>CACHE</strong>: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li>\n<li><strong>NETWORK</strong>: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li>\n<li><strong>FALLBACK</strong>: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li>\n</ul>\n<p>（3）在离线状态时，操作 <code>window.applicationCache</code> 进行离线缓存的操作。</p>\n<p><strong>如何更新缓存：</strong></p>\n<p>（1）更新 manifest 文件</p>\n<p>（2）通过 javascript 操作</p>\n<p>（3）清除浏览器缓存</p>\n<p><strong>注意事项：</strong></p>\n<p>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p>\n<p>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</p>\n<p>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</p>\n<p>（4）FALLBACK 中的资源必须和 manifest 文件同源。</p>\n<p>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</p>\n<p>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</p>\n<p>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:34:09.114Z",
    "updatedAt": "2026-01-11T03:34:09.114Z"
  },
  {
    "id": "1768102467001",
    "title": "浏览器是如何对 HTML5 的离线储存资源进行管理和加载？",
    "content": "<ul>\n<li><strong>在线的情况下</strong>，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</li>\n<li><strong>离线的情况下</strong>，浏览器会直接使用离线存储的资源。</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:34:27.001Z",
    "updatedAt": "2026-01-11T03:34:27.001Z"
  },
  {
    "id": "1768102479687",
    "title": " title与h1的区别、b与strong的区别、i与em的区别？",
    "content": "<ul>\n<li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</li>\n<li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li>\n<li><strong>i内容展示为斜体，em表示强调的文本</strong></li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:34:39.687Z",
    "updatedAt": "2026-01-11T03:34:39.687Z"
  },
  {
    "id": "1768102506000",
    "title": "iframe 有那些优点和缺点？",
    "content": "<p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>用来加载速度较慢的内容（如广告）</li>\n<li>可以使脚本可以并行下载</li>\n<li>支持跨域通信</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>iframe 会阻塞主页面的 onload 事件</li>\n<li>无法被一些搜索引擎索识别</li>\n<li>会产生很多页面，不容易管理</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:35:06.000Z",
    "updatedAt": "2026-01-11T03:35:06.000Z"
  },
  {
    "id": "1768102529198",
    "title": "label 的作用是什么？如何使用？",
    "content": "<p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p>\n<ul>\n<li>使用方法1：</li>\n</ul>\n<pre><code class=\"language-HTML\">&lt;label for=\"mobile\"&gt;Number:&lt;/label&gt;\n\n&lt;input type=\"text\" id=\"mobile\"/&gt;\n</code></pre>\n<ul>\n<li>使用方法2：</li>\n</ul>\n<pre><code class=\"language-HTML\">&lt;label&gt;Date:&lt;input type=\"text\"/&gt;&lt;/label&gt;\n</code></pre>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:35:29.198Z",
    "updatedAt": "2026-01-11T03:35:29.198Z"
  },
  {
    "id": "1768102548154",
    "title": "Canvas和SVG的区别",
    "content": "<p><strong>（1）SVG：</strong></p>\n<p>SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p>\n<p>其特点如下：</p>\n<ul>\n<li>不依赖分辨率</li>\n<li>支持事件处理器</li>\n<li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>\n<li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>\n<li>不适合游戏应用</li>\n</ul>\n<p><strong>（2）Canvas：</strong></p>\n<p>Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p>\n<p>其特点如下：</p>\n<ul>\n<li>依赖分辨率</li>\n<li>不支持事件处理器</li>\n<li>弱的文本渲染能力</li>\n<li>能够以 .png 或 .jpg 格式保存结果图像</li>\n<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>\n</ul>\n<p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:35:48.154Z",
    "updatedAt": "2026-01-11T03:35:48.154Z"
  },
  {
    "id": "1768102569520",
    "title": " head 标签有什么作用，其中什么标签必不可少？",
    "content": "<p><strong>回答：</strong></p>\n<p>定义文档头部，包含文档的元信息、样式、脚本等非内容数据</p>\n<ul>\n<li><strong>必需标签</strong>：<code>&lt;title&gt;</code>（定义文档标题，浏览器标签栏显示）</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>&lt;head&gt; 标签用于定义文档的头部，它是所有头部元素的容器。&lt;head&gt; 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p>\n<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>\n<p>下面这些标签可用在 head 部分：&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;。</p>\n<p>其中 &lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。</p>",
    "categoryId": "1768000001001",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:36:09.520Z",
    "updatedAt": "2026-01-11T03:36:09.520Z"
  },
  {
    "id": "1768102602575",
    "title": "文档声明（Doctype）和<!Doctype html>有何作用? 严格模式与混杂模式如何区分？它们有何意义?",
    "content": "<p><strong>回答：</strong></p>\n<p><strong>DOCTYPE作用</strong>：告诉浏览器HTML文档的版本，指导正确解析</p>\n<ul>\n<li><strong>&lt;!doctype html&gt;作用</strong>：触发浏览器进入标准模式，使用HTML5标准解析页面</li>\n<li><strong>严格模式</strong>：按W3C标准解析，保证跨浏览器一致性</li>\n<li><strong>混杂模式</strong>：浏览器用旧版方式解析，兼容老网站</li>\n<li><strong>区分</strong>：看DOCTYPE是否存在且正确，HTML5无严格/混杂之分</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>**文档声明的作用：**文档声明是为了告诉浏览器，当前<code>HTML</code>文档使用什么版本的<code>HTML</code>来写的，这样浏览器才能按照声明的版本来正确的解析。</p>\n<p><strong>&lt;!Doctype html&gt;的作用：</strong><code>&lt;!doctype html&gt;</code> 的作用就是让浏览器进入标准模式，使用最新的 <code>HTML5</code> 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。</p>\n<p><strong>严格模式与混杂模式的区分：</strong></p>\n<ul>\n<li><strong>严格模式</strong>： 又称为标准模式，指浏览器按照<code>W3C</code>标准解析代码；</li>\n<li><strong>混杂模式</strong>： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；</li>\n</ul>\n<p><strong>区分</strong>：网页中的<code>DTD</code>，直接影响到使用的是严格模式还是浏览模式，可以说<code>DTD</code>的使用与这两种方式的区别息息相关。</p>\n<ul>\n<li>如果文档包含严格的<code>DOCTYPE</code> ，那么它一般以严格模式呈现（<strong>严格 DTD ——严格模式</strong>）；</li>\n<li>包含过渡 <code>DTD</code> 和 <code>URI</code> 的 <code>DOCTYPE</code> ，也以严格模式呈现，但有过渡 <code>DTD</code> 而没有 <code>URI</code> （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（<strong>有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式</strong>）；</li>\n<li><code>DOCTYPE</code> 不存在或形式不正确会导致文档以混杂模式呈现（<strong>DTD不存在或者格式不正确——混杂模式</strong>）；</li>\n<li><code>HTML5</code> 没有 <code>DTD</code> ，因此也就没有严格模式与混杂模式的区别，<code>HTML5</code> 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(<strong>HTML5 没有严格和混杂之分</strong>)。</li>\n</ul>\n<p>总之，<strong>严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。</strong></p>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:36:42.575Z",
    "updatedAt": "2026-01-11T03:36:42.575Z"
  },
  {
    "id": "1768102634257",
    "title": "浏览器乱码的原因是什么？如何解决？",
    "content": "<p><strong>回答：</strong></p>\n<p><strong>原因</strong>：编码不一致（如页面用gbk，内容用utf-8）</p>\n<ul>\n<li><strong>解决方法</strong>：统一使用UTF-8编码（设置<code>&lt;meta charset=\"UTF-8\"&gt;</code>）</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p><strong>产生乱码的原因：</strong></p>\n<ul>\n<li>网页源代码是<code>gbk</code>的编码，而内容中的中文字是<code>utf-8</code>编码的，这样浏览器打开即会出现<code>html</code>乱码，反之也会出现乱码；</li>\n<li><code>html</code>网页编码是<code>gbk</code>，而程序从数据库中调出呈现是<code>utf-8</code>编码的内容也会造成编码乱码；</li>\n<li>浏览器不能自动检测网页编码，造成网页乱码。</li>\n</ul>\n<p><strong>解决办法：</strong></p>\n<ul>\n<li>使用软件编辑HTML网页内容；</li>\n<li>如果网页设置编码是<code>gbk</code>，而数据库储存数据编码格式是<code>UTF-8</code>，此时需要程序查询数据库数据显示数据前进程序转码；</li>\n<li>如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:37:14.257Z",
    "updatedAt": "2026-01-11T03:37:14.257Z"
  },
  {
    "id": "1768102651880",
    "title": "渐进增强和优雅降级之间的区别",
    "content": "<p><strong>回答：</strong></p>\n<p><strong>渐进增强</strong>：从基础功能开始，逐步为高级浏览器添加增强效果</p>\n<ul>\n<li><strong>优雅降级</strong>：先实现完整功能，再为旧浏览器添加兼容性处理</li>\n<li><strong>区别</strong>：渐进增强向前看（基础功能优先），优雅降级向后看（完整功能优先）</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p><strong>（1）渐进增强（progressive enhancement）</strong>：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。</p>\n<p><strong>（2）优雅降级 graceful degradation</strong>： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p>\n<p><strong>两者区别：</strong></p>\n<ul>\n<li>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；</li>\n<li>降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。</li>\n</ul>\n<p>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p>\n<p>“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:37:31.880Z",
    "updatedAt": "2026-01-11T03:37:31.880Z"
  },
  {
    "id": "1768102668156",
    "title": "说一下 HTML5 drag API",
    "content": "<p><strong>回答：</strong></p>\n<p>提供元素拖放功能的事件接口</p>\n<ul>\n<li>主要事件：dragstart（开始拖放）、dragover（拖放移动中）、drop（完成放置）</li>\n<li>作用：实现自定义拖放交互效果</li>\n</ul>\n<p><strong>解析：</strong></p>\n<ul>\n<li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</li>\n<li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</li>\n<li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</li>\n<li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</li>\n<li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li>\n<li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li>\n<li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</li>\n</ul>",
    "categoryId": "1768000001001",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:37:48.156Z",
    "updatedAt": "2026-01-11T03:37:48.156Z"
  },
  {
    "id": 1768103122903,
    "title": "JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。",
    "content": "其中 Symbol 和 BigInt 是ES6 中新增的数据类型：<br><br>  - Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。<br>  - BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。<br><br>  这些数据可以分为原始数据类型和引用数据类型：<br><br>  - 栈：原始数据类型（Undefined、Null、Boolean、Number、String）<br>  - 堆：引用数据类型（对象、数组和函数）<br><br>  两种类型的区别在于<strong>存储位置的不同：</strong><br><br>  - 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br>  - 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。<br><br>  堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：<br><br>  - 在数据结构中，栈中数据的存取方式为先进后出。<br>  - 堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。<br><br>  在操作系统中，内存被分为栈区和堆区：<br><br>  - 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>  - 堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122904,
    "title": "数据类型检测的方式有哪些",
    "content": "<strong>回答：</strong>检测的方法typeof，instanceof，<br><br>  <strong>（1）typeof</strong><br><br>  console.log(typeof 2);               // number<br><br>  console.log(typeof true);            // boolean<br><br>  console.log(typeof 'str');           // string<br><br>  console.log(typeof []);              // object<br><br>  console.log(typeof function(){});    // function<br><br>  console.log(typeof {});              // object<br><br>  console.log(typeof undefined);       // undefined<br><br>  console.log(typeof null);            // object<br><br>  其中数组、对象、null都会被判断为object，其他判断都正确。<br><br>  <strong>（2）instanceof</strong><br><br>  <code>instanceof</code>可以正确判断对象的类型，其内部运行机制是<strong>判断在其原型链中能否找到该类型的原型</strong>。<br><br>  console.log(2 instanceof Number);                    // false<br><br>  console.log(true instanceof Boolean);                // false<br><br>  console.log('str' instanceof String);                // false<br><br>  console.log([] instanceof Array);                    // true<br><br>  console.log(function(){} instanceof Function);       // true<br><br>  console.log({} instanceof Object);                   // true<br><br>  可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。<br><br>  <strong>（3） constructor</strong><br><br>  console.log((2).constructor === Number); // true<br><br>  console.log((true).constructor === Boolean); // true<br><br>  console.log(('str').constructor === String); // true<br><br>  console.log(([]).constructor === Array); // true<br><br>  console.log((function() {}).constructor === Function); // true<br><br>  console.log(({}).constructor === Object); // true<br><br>  <code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：<br><br>  function Fn(){};<br><br>  Fn.prototype = new Array();<br><br>  var f = new Fn();<br><br>  console.log(f.constructor===Fn);    // false<br><br>  console.log(f.constructor===Array); // true<br><br>  <strong>（4）Object.prototype.toString.call()</strong><br><br>  <code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：<br><br>  var a = Object.prototype.toString;<br><br>  console.log(a.call(2));<br><br>  console.log(a.call(true));<br><br>  console.log(a.call('str'));<br><br>  console.log(a.call([]));<br><br>  console.log(a.call(function(){}));<br><br>  console.log(a.call({}));<br><br>  console.log(a.call(undefined));<br><br>  console.log(a.call(null));<br><br>  同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？<br><br>  这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122905,
    "title": "判断数组的方式有哪些",
    "content": "<strong>回答：</strong>Array.isArray()<br><br>  - 通过Object.prototype.toString.call()做判断<br><br>    Object.prototype.toString.call(obj).slice(8,-1) === 'Array';<br><br>  - 通过原型链做判断<br><br>    obj.<strong>proto</strong> === Array.prototype;<br><br>  - 通过ES6的Array.isArray()做判断<br><br>    Array.isArrray(obj);<br><br>  - 通过instanceof做判断<br><br>    obj instanceof Array<br><br>  - 通过Array.prototype.isPrototypeOf<br><br>    Array.prototype.isPrototypeOf(obj)",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122906,
    "title": "null和undefined区别",
    "content": "<strong>回答：</strong><br><br>  Undefined 与 Null 都是单值基本类型，分别表示“未定义”和“空对象”；未赋值的变量默认 undefined，可能返回对象的变量可初始化为 null。undefined 不是保留字。typeof null 返回 \"object\"，双等判等 true，三等判等 false。<br><br>  <strong>解析：</strong><br><br>  首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。<br><br>  undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。<br><br>  undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。<br><br>  当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122907,
    "title": "typeof null 的结果是什么，为什么？",
    "content": "typeof null 的结果是Object。<br><br>  在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：<br><br>  000: object   - 当前存储的数据指向一个对象。<br><br>  <pre><code class=\"language-\">  1: int      - 当前存储的数据是一个 31 位的有符号整数。<br>  </code></pre><br><br>  010: double   - 当前存储的数据指向一个双精度的浮点数。<br><br>  100: string   - 当前存储的数据指向一个字符串。<br><br>  110: boolean  - 当前存储的数据是布尔值。<br><br>  如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。<br><br>  有两种特殊数据类型：<br><br>  - undefined的值是 (-2)30(一个超出整数范围的数字)；<br>  - null 的值是机器码 NULL 指针(null 指针的值全是 0)<br><br>  那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122908,
    "title": "intanceof 操作符的实现原理及实现",
    "content": "instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。<br><br>  <pre><code class=\"language-JavaScript\">  function myInstanceof(left, right) {<br>    // 获取对象的原型<br>    let proto = Object.getPrototypeOf(left)<br>    // 获取构造函数的 prototype 对象<br>    let prototype = right.prototype; <br>    // 判断构造函数的 prototype 对象是否在对象的原型链上<br>    while (true) {<br>      if (!proto) return false;<br>      if (proto === prototype) return true;<br>      // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型<br>      proto = Object.getPrototypeOf(proto);<br>    }<br>  }<br>  </code></pre>",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122909,
    "title": "为什么0.1+0.2 ! == 0.3，如何让其相等",
    "content": "<strong>回答：</strong><br><br>  0.1、0.2 在 IEEE 754 双精度浮点里都是无限循环二进制，被截断后两者相加比 0.3 大了一点，所以严格相等失败。<br><br>  在开发过程中遇到类似这样的问题：<br><br>  <pre><code class=\"language-JavaScript\">  let n1 = 0.1, n2 = 0.2<br>  <br>  console.log(n1 + n2)  // 0.30000000000000004<br>  </code></pre><br><br>  这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：<br><br>  (n1 + n2).toFixed(2) // 注意，toFixed为四舍五入<br><br>  <code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？<br><br>  计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？<br><br>  一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。<br><br>  根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。<br><br>  下面看一下<strong>双精度数是如何保存</strong>的：<br><br>  ![img](https://secure2.wostatic.cn/static/pCGRc9PjpLgeq5omzhNHCS/2.png?auth_key=1768101739-d9NKEsjJoVkfM8XffF7Zjp-0-e590195345b18d627242749b5d47ec2d)<br><br>  - 第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位<br>  - 第二部分（绿色）：用来存储指数（exponent），占用11位<br>  - 第三部分（红色）：用来存储小数（fraction），占用52位<br><br>  对于0.1，它的二进制为：<br><br>  <pre><code class=\"language-JavaScript\">  0.00011001100110011001100110011001100110011001100110011001 10011...<br>  </code></pre><br><br>  转为科学计数法（科学计数法的结果就是浮点数）：<br><br>  <pre><code class=\"language-JavaScript\">  1.1001100110011001100110011001100110011001100110011001<em>2^-4<br>  </code></pre><br><br>  可以看出0.1的符号位为0，指数位为-4，小数位为：<br><br>  <pre><code class=\"language-JavaScript\">  1001100110011001100110011001100110011001100110011001<br>  </code></pre><br><br>  那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？<br><br>  IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。<br><br>  - 当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。<br>  - 当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。<br>  - 当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。<br><br>  对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.<br><br>  所以，0.1表示为：<br><br>  <pre><code class=\"language-JavaScript\">  0 1111111011 1001100110011001100110011001100110011001100110011001<br>  </code></pre><br><br>  说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？<br><br>  对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3<br><br>  <pre><code class=\"language-JavaScript\">  function numberepsilon(arg1,arg2){                   <br>    return Math.abs(arg1 - arg2) < Number.EPSILON;        <br>  }        <br>  <br>  console.log(numberepsilon(0.1 + 0.2, 0.3)); // true<br>  </code></pre><br><br>  在开发过程中遇到类似这样的问题：<br><br>  <pre><code class=\"language-JavaScript\">  let n1 = 0.1, n2 = 0.2<br>  <br>  console.log(n1 + n2)  // 0.30000000000000004<br>  </code></pre><br><br>  这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：<br><br>  (n1 + n2).toFixed(2) // 注意，toFixed为四舍五入<br><br>  <code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？<br><br>  计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？<br><br>  一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。<br><br>  根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。<br><br>  下面看一下<strong>双精度数是如何保存</strong>的：<br><br>  ![img](https://secure2.wostatic.cn/static/pCGRc9PjpLgeq5omzhNHCS/2.png?auth_key=1768101739-f5wjWyMF1D2EqrYuc5vek3-0-158fa760c99770de48bb8db9d8616ee4)<br><br>  - 第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位<br>  - 第二部分（绿色）：用来存储指数（exponent），占用11位<br>  - 第三部分（红色）：用来存储小数（fraction），占用52位<br><br>  对于0.1，它的二进制为：<br><br>  <pre><code class=\"language-JavaScript\">  0.00011001100110011001100110011001100110011001100110011001 10011...<br>  </code></pre><br><br>  转为科学计数法（科学计数法的结果就是浮点数）：<br><br>  <pre><code class=\"language-JavaScript\">  1.1001100110011001100110011001100110011001100110011001</em>2^-4<br>  </code></pre><br><br>  可以看出0.1的符号位为0，指数位为-4，小数位为：<br><br>  <pre><code class=\"language-JavaScript\">  1001100110011001100110011001100110011001100110011001<br>  </code></pre><br><br>  那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？<br><br>  IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。<br><br>  - 当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。<br>  - 当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。<br>  - 当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。<br><br>  对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.<br><br>  所以，0.1表示为：<br><br>  <pre><code class=\"language-JavaScript\">  0 1111111011 1001100110011001100110011001100110011001100110011001<br>  </code></pre><br><br>  说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？<br><br>  对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3<br><br>  <pre><code class=\"language-JavaScript\">  function numberepsilon(arg1,arg2){                   <br>    return Math.abs(arg1 - arg2) < Number.EPSILON;        <br>  }        <br>  <br>  console.log(numberepsilon(0.1 + 0.2, 0.3)); // true<br>  </code></pre>",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122910,
    "title": "如何获取安全的 undefined 值？",
    "content": "<strong>回答：</strong>undefined 不是保留字，可被重新赋值导致判断失效；<code>void <任意表达式></code> 永远返回“原装”undefined，故用 <code>void 0</code> 即可安全获取真 undefined。<br><br>  因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122911,
    "title": "typeof NaN 的结果是什么？number",
    "content": "NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。<br><br>  typeof NaN; // \"number\"<br><br>  NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122912,
    "title": "isNaN 和 Number.isNaN 函数的区别？",
    "content": "<li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li><br>  - 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122913,
    "title": "其他值到字符串的转换规则？",
    "content": "<li>Null 和 Undefined 类型 ，null 转换为 \"null\"，undefined 转换为 \"undefined\"，</li><br>  - Boolean 类型，true 转换为 \"true\"，false 转换为 \"false\"。<br>  - Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。<br>  - Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。<br>  - 对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如\"[object Object]\"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122914,
    "title": "其他值到数字值的转换规则？",
    "content": "<li>Undefined 类型的值转换为 NaN。</li><br>  - Null 类型的值转换为 0。<br>  - Boolean 类型的值，true 转换为 1，false 转换为 0。<br>  - String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。<br>  - Symbol 类型的值不能转换为数字，会报错。<br>  - 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。<br><br>  为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。<br><br>  如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122915,
    "title": "其他值到布尔类型的值的转换规则？",
    "content": "以下这些是假值：<br><br>  • undefined<br><br>  • null<br><br>  • false<br><br>  • +0、-0 和 NaN<br><br>  • \"\"<br><br>  假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122916,
    "title": "|| 和 && 操作符的返回值？",
    "content": "|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。<br><br>  - 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。<br>  - && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。<br><br>  || 和 && 返回它们其中一个操作数的值，而非条件判断的结果",
    "categoryId": "1768000001003",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122917,
    "title": "[Object.is](http://Object.is)() 与比较操作符 “===”、“==” 的区别？",
    "content": "<li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li><br>  - 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。<br>  - 使用 [Object.is](http://Object.is) 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122918,
    "title": "什么是 JavaScript 中的包装类型？",
    "content": "就是通过toUpperCase属性将小写的字母转化成大写的<br><br>  在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：<br><br>  <pre><code class=\"language-JavaScript\">  const a = \"abc\";<br>  a.length; // 3<br>  a.toUpperCase(); // \"ABC\"<br>  </code></pre><br><br>  在访问<code>'abc'.length</code>时，JavaScript 将<code>'abc'</code>在后台转换成<code>String('abc')</code>，然后再访问其<code>length</code>属性。<br><br>  JavaScript也可以使用<code>Object</code>函数显式地将基本类型转换为包装类型：<br><br>  <pre><code class=\"language-JavaScript\">  var a = 'abc'<br>  Object(a) // String {\"abc\"}<br>  </code></pre><br><br>  也可以使用<code>valueOf</code>方法将包装类型倒转成基本类型：<br><br>  <pre><code class=\"language-JavaScript\">  var a = 'abc'<br>  var b = Object(a)<br>  var c = b.valueOf() // 'abc'<br>  </code></pre><br><br>  看看如下代码会打印出什么：<br><br>  <pre><code class=\"language-JavaScript\">  var a = new Boolean( false );<br>  if (!a) {<br>    console.log( \"Oops\" ); // never runs<br>  }<br>  </code></pre><br><br>  答案是什么都不会打印，因为虽然包裹的基本类型是<code>false</code>，但是<code>false</code>被包裹成包装类型后就成了对象，所以其非值为<code>false</code>，所以循环体中的内容不会运行。",
    "categoryId": "1768000001003",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122919,
    "title": "JavaScript 中如何进行隐式类型转换？",
    "content": "首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：<br><br>  <pre><code class=\"language-JavaScript\">  /*<em><br>  - @obj 需要转换的对象<br>  - @type 期望的结果类型<br>  </em>/<br>  <br>  ToPrimitive(obj,type)<br>  </code></pre><br><br>  <code>type</code>的值为<code>number</code>或者<code>string</code>。<br><br>  <strong>（1）当</strong><code>type</code><strong>为</strong><code>number</code><strong>时规则如下：</strong><br><br>  - 调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；<br>  - 调用<code>obj</code>的<code>toString</code>方法，后续同上；<br>  - 抛出<code>TypeError</code> 异常。<br><br>  <strong>（2）当</strong><code>type</code><strong>为</strong><code>string</code><strong>时规则如下：</strong><br><br>  - 调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；<br>  - 调用<code>obj</code>的<code>valueOf</code>方法，后续同上；<br>  - 抛出<code>TypeError</code> 异常。<br><br>  可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：<br><br>  - 如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；<br>  - 其他情况下，<code>type</code>默认为<code>number</code>。<br><br>  总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：<br><br>  <pre><code class=\"language-JavaScript\">  var objToNumber = value => Number(value.valueOf().toString())<br>  objToNumber([]) === 0<br>  objToNumber({}) === NaN<br>  </code></pre><br><br>  而 JavaScript 中的隐式类型转换主要发生在<code>+、-、<em>、/</code>以及<code>==、>、<</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。<br><br>  以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：<br><br>  1. <code>+</code><strong>操作符</strong><code>+</code>操作符的两边有至少一个<code>string</code>类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。<br><br>  <pre><code class=\"language-JavaScript\">  1 + '23' // '123'<br>  <br>  1 + false // 1 <br>  <br>  1 + Symbol() // Uncaught TypeError: Cannot convert a Symbol value to a number<br>  <br>  '1' + false // '1false'<br>  <br>  false + true // 1<br>  </code></pre><br><br>  1. <code>-</code><strong>、</strong><code></em></code><strong>、</strong><code>/</code><strong>操作符</strong><code>NaN</code>也是一个数字<br><br>  <pre><code class=\"language-JavaScript\">  1 <em> '23' // 23<br>  <br>  1 </em> false // 0<br>  <br>  1 / 'aa' // NaN<br>  </code></pre><br><br>  1. <strong>对于</strong><code>==</code><strong>操作符</strong><br><br>     操作符两边的值都尽量转成<code>number</code>：<br><br>  <pre><code class=\"language-JavaScript\">  3 == true // false, 3 转为number为3，true转为number为1<br>  <br>  '0' == false //true, '0'转为number为0，false转为number为0<br>  <br>  '0' == 0 // '0'转为number为0<br>  </code></pre><br><br>  1. <strong>对于</strong><code><</code><strong>和</strong><code>></code><strong>比较符</strong><br><br>     如果两边都是字符串，则比较字母表顺序：<br><br>  <pre><code class=\"language-JavaScript\">  'ca' < 'bd' // false<br>  'a' < 'b' // true<br>  '12' < 13 // true<br>  false > -1 // true<br>  var a = {}<br>  a > 2 // false<br>  a.valueOf() // {}, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步<br>  a.toString() // \"[object Object]\"，现在是一个字符串了<br>  Number(a.toString()) // NaN，根据上面 < 和 > 操作符的规则，要转换成数字<br>  NaN > 2 //false，得出比较结果<br>  var a = {name:'Jack'}<br>  var b = {age: 18}<br>  a + b // \"[object Object][object Object]\"<br>  a.valueOf() // {}，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步<br>  a.toString() // \"[object Object]\"<br>  b.valueOf() // 同理<br>  b.toString() // \"[object Object]\"<br>  a + b // \"[object Object][object Object]\"<br>  </code></pre>",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122920,
    "title": "`+` 操作符什么时候用于字符串的拼接？",
    "content": "根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。<br><br>  简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。<br><br>  那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。",
    "categoryId": "1768000001003",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122922,
    "title": "为什么会有**BigInt**的提案？",
    "content": "JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122923,
    "title": "object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别",
    "content": "<pre><code class=\"language-JavaScript\">  // 扩展运算符：<br>  let outObj = {<br>    inObj: {a: 1, b: 2}<br>  }<br>  <br>  let newObj = {...outObj}<br>  <br>  newObj.inObj.a = 2<br>  <br>  console.log(outObj) // {inObj: {a: 2, b: 2}}<br>  // Object.assign():<br>  <br>  let outObj = {<br>    inObj: {a: 1, b: 2}<br>  }<br>  <br>  let newObj = Object.assign({}, outObj)<br>  <br>  newObj.inObj.a = 2<br>  <br>  console.log(outObj) // {inObj: {a: 2, b: 2}}<br>  </code></pre><br><br>  可以看到，两者都是浅拷贝。<br><br>  - Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。<br>  - 扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": 1768103122924,
    "title": "如何判断一个对象是空对象",
    "content": "通过Object.keys判断长度即可<br><br>  - 使用JSON自带的.stringify方法来判断：<br><br>  <pre><code class=\"language-JavaScript\">  if(Json.stringify(Obj) == '{}' ){<br>    console.log('空对象');<br>   }<br>  </code></pre><br><br>  - 使用ES6新增的方法Object.keys()来判断：<br><br>  <pre><code class=\"language-JavaScript\">  if(Object.keys(Obj).length < 0){<br>    console.log('空对象');<br>  }<br>  </code></pre><br><br>  运算过程如下：<br><br>  又比如：<br><br>  其对比过程如下：<br><br>  以上说的是基本类型的隐式转换，而对象会被<code>ToPrimitive</code>转换为基本类型再进行转换：<br><br>  其他情况下，转换为数字再比较：",
    "categoryId": "1768000001003",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:45:22.894Z",
    "updatedAt": "2026-01-11T03:45:22.894Z"
  },
  {
    "id": "1768103310582",
    "title": "1. 反问环节提问？",
    "content": "<ul>\n<li>我的直接上级他们的上级都是什么样的管理风格？</li>\n<li>您期望我在最初的一个月 / 三个月能够完成什么？</li>\n<li>您对在这里工作最满意的地方是？</li>\n<li>公司常用的技术栈是什么？</li>\n<li>是否会使用静态代码分析呢？</li>\n<li>公司是否有技术分享交流活动？有的话，多久一次呢？</li>\n<li>公司有标准的开发环境吗？是强制的吗？</li>\n<li>业务需求有没有文档记录？是如何记录的？</li>\n<li>公司技术团队的架构和人员组成？</li>\n<li>公司目前招人的原因是？（因为产品发展 or 新产品 or人员波动？)</li>\n<li>绩效评估流程是怎样的？</li>\n<li>您上一次注意到有人成长是什么时候？他们在哪方面成长了？</li>\n</ul>",
    "categoryId": "1768000001013",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:30.582Z",
    "updatedAt": "2026-01-11T03:48:30.582Z"
  },
  {
    "id": 1768103319816,
    "title": "1*. new操作符的实现原理",
    "content": "<strong>new操作符的执行过程：</strong><br><br>（1）首先创建了一个新的空对象<br><br>（2）设置原型，将对象的原型设置为函数的 prototype 对象。<br><br>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br><br>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。<br><br>具体实现：<br><br><pre><code class=\"language-JavaScript\">function objectFactory() {<br>  let newObject = null;<br>  let constructor = Array.prototype.shift.call(arguments);<br>  let result = null;<br>  // 判断参数是否是一个函数<br>  if (typeof constructor !== \"function\") {<br>    console.error(\"type error\");<br>    return;<br>  }<br>  // 新建一个空对象，对象的原型为构造函数的 prototype 对象<br>  newObject = Object.create(constructor.prototype);<br>  // 将 this 指向新建对象，并执行函数<br>  result = constructor.apply(newObject, arguments);<br>  // 判断返回对象<br>  let flag = result && (typeof result === \"object\" || typeof result === \"function\");<br>  // 判断返回结果<br>  return flag ? result : newObject;<br>}<br>// 使用方法<br>objectFactory(构造函数, 初始化参数);<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319817,
    "title": "map和Object的区别",
    "content": "<strong>Map和Object的核心区别：</strong>Map是ES6新增的数据结构，键可以是任意类型（对象、函数等），保持插入顺序，频繁添加删除操作性能更好，没有原型链污染，直接通过size属性获取大小；Object是传统对象，键主要是字符串或Symbol，不保证顺序，可直接JSON序列化，有原型链，需要通过Object.keys().length计算大小。<br><br>|          | Map                                                          | Object                                                       |<br>| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |<br>| 意外的键 | Map默认情况不包含任何键，只包含显式插入的键。                | Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。 |<br>| 键的类型 | Map的键可以是任意值，包括函数、对象或任意基本类型。          | Object 的键必须是 String 或是Symbol。                        |<br>| 键的顺序 | Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。 | Object 的键是无序的                                          |<br>| Size     | Map 的键值对个数可以轻易地通过size 属性获取                  | Object 的键值对个数只能手动计算                              |<br>| 迭代     | Map 是 iterable 的，所以可以直接被迭代。                     | 迭代Object需要以某种方式获取它的键然后才能迭代。             |<br>| 性能     | 在频繁增删键值对的场景下表现更好。                           | 在频繁添加和删除键值对的场景下未作出优化。                   |",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319818,
    "title": "map和weakMap的区别",
    "content": "<strong>Map和WeakMap的核心区别：</strong>Map的键可以是任意类型（对象、函数、基本类型），使用强引用阻止垃圾回收，可遍历，有size属性和clear方法，适合通用数据存储但需手动清理避免内存泄漏；WeakMap的键只能是对象，使用弱引用不阻止垃圾回收，不可遍历，无size属性和clear方法，能自动清理避免内存泄漏。<br><br><strong>（1）Map</strong><br><br>map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。<br><br>实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：<br><br><pre><code class=\"language-JavaScript\">const map = [<br>     [\"name\",\"张三\"],<br>     [\"age\",18],<br>]<br></code></pre><br><br>Map数据结构有以下操作方法：<br><br><li><strong>size</strong>： <code>map.size</code> 返回Map结构的成员总数。</li><br><li><strong>set(key,value)</strong>：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li><br><li><strong>get(key)</strong>：该方法读取key对应的键值，如果找不到key，返回undefined。</li><br><li><strong>has(key)</strong>：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li><br><li><strong>delete(key)</strong>：该方法删除某个键，返回true，如果删除失败，返回false。</li><br><li><strong>clear()</strong>：map.clear()清除所有成员，没有返回值。</li><br><br>Map结构原生提供是三个遍历器生成函数和一个遍历方法<br><br><li>keys()：返回键名的遍历器。</li><br><li>values()：返回键值的遍历器。</li><br><li>entries()：返回所有成员的遍历器。</li><br><li>forEach()：遍历Map的所有成员。</li><br><br><pre><code class=\"language-JavaScript\">const map = new Map([<br>     [\"foo\",1],<br>     [\"bar\",2],<br>])<br>for(let key of map.keys()){<br>    console.log(key);  // foo bar<br>}<br>for(let value of map.values()){<br>     console.log(value); // 1 2<br>}<br>for(let items of map.entries()){<br>    console.log(items);  // [\"foo\",1]  [\"bar\",2]<br>}<br>map.forEach( (value,key,map) => {<br>     console.log(key,value); // foo 1    bar 2<br>})<br></code></pre><br><br><strong>（2）WeakMap</strong><br><br>WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。<strong>其键必须是对象</strong>，原始数据类型不能作为key值，而值可以是任意的。<br><br>该对象也有以下几种方法：<br><br><li><strong>set(key,value)</strong>：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li><br><li><strong>get(key)</strong>：该方法读取key对应的键值，如果找不到key，返回undefined。</li><br><li><strong>has(key)</strong>：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li><br><li><strong>delete(key)</strong>：该方法删除某个键，返回true，如果删除失败，返回false。</li><br><br>其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。<br><br>WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。<br><br>而WeakMap的<strong>键名所引用的对象都是弱引用</strong>，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的<strong>键名对象和所对应的键值对会自动消失，不用手动删除引用</strong>。<br><br><strong>总结：</strong><br><br><li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><br><li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319819,
    "title": "JavaScript有哪些内置对象",
    "content": "全局的对象（ global objects ）或称标准内置对象，不要和 \"全局对象（global object）\" 混淆。这里说的全局的对象是说在<br><br>全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。<br><br><strong>标准内置对象的分类：</strong><br><br>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。<br><br>例如 Infinity、NaN、undefined、null 字面量<br><br>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。<br><br>例如 eval()、parseFloat()、parseInt() 等<br><br>（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。<br><br>例如 Object、Function、Boolean、Symbol、Error 等<br><br>（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。<br><br>例如 Number、Math、Date<br><br>（5）字符串，用来表示和操作字符串的对象。<br><br>例如 String、RegExp<br><br>（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array<br><br>（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。<br><br>例如 Map、Set、WeakMap、WeakSet<br><br>（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。<br><br>例如 SIMD 等<br><br>（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。<br><br>例如 JSON 等<br><br>（10）控制抽象对象<br><br>例如 Promise、Generator 等<br><br>（11）反射<br><br>例如 Reflect、Proxy<br><br>（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。<br><br>例如 Intl、Intl.Collator 等<br><br>（13）WebAssembly<br><br>（14）其他<br><br>例如 arguments<br><br><strong>总结：</strong><br><br>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319820,
    "title": "常用的正则表达式有哪些？",
    "content": "<pre><code class=\"language-JavaScript\">// （1）匹配 16 进制颜色值<br>var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;<br><br>// （2）匹配日期，如 yyyy-mm-dd 格式<br>var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;<br><br>// （3）匹配 qq 号<br>var regex = /^[1-9][0-9]{4,10}$/g;<br><br>// （4）手机号码正则<br>var regex = /^1[34578]\\d{9}$/g;<br><br>// （5）用户名正则<br>var regex = /^[a-zA-Z\\$][a-zA-Z0-9_\\$]{4,16}$/;<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319821,
    "title": "对JSON的理解",
    "content": "<strong>回答：</strong><br><br>JSON 是一种轻量级跨语言数据交换格式，常用于前后端数据传递。虽然JSON语法基于JavaScript，但两者不同：JSON格式更严格，属性值不能是函数或NaN等。<br><br>JavaScript提供了两种转换的方法：<br><br><li>JSON.stringify() ：将JS对象序列化为JSON字符串，用于发送数据到后端</li><br><li>JSON.parse() ：将JSON字符串解析为JS对象，用于接收后端数据</li><br><br><strong>解析：</strong><br><br>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。<br><br>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为<br><br>JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。<br><br>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。<br><br>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，<br><br><li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li><br><li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319822,
    "title": "7*. JavaScript脚本延迟加载的方式有哪些？",
    "content": "JavaScript延迟加载的方式有async属性，setTimeout延迟方法<br><br>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。<br><br>一般有以下几种方式：<br><br><li><strong>defer 属性：</strong> 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li><br><li><strong>async 属性：</strong> 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li><br><li><strong>动态创建 DOM 方式：</strong> 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li><br><li><strong>使用 setTimeout 延迟方法：</strong> 设置一个定时器来延迟加载js脚本文件</li><br><li><strong>让 JS 最后加载：</strong> 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319823,
    "title": "JavaScript 类数组对象的定义？",
    "content": "<strong>回答：</strong><br><br>类数组对象是指具有数字索引和length属性但不是Array实例的对象，类数组对象可以通过索引访问元素并获取长度，但不能直接使用push、map等数组方法，需要通过Array.from()、展开运算符或Array.prototype.slice.call()等方法转换为真正的数组后才能使用完整的数组方法。<br><br>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。<br><br>常见的类数组转换为数组的方法有这样几种：<br><br>（1）通过 call 调用数组的 slice 方法来实现转换<br><br><pre><code class=\"language-JavaScript\">Array.prototype.slice.call(arrayLike);<br></code></pre><br><br>（2）通过 call 调用数组的 splice 方法来实现转换<br><br><pre><code class=\"language-JavaScript\">Array.prototype.splice.call(arrayLike, 0);<br></code></pre><br><br>（3）通过 apply 调用数组的 concat 方法来实现转换<br><br><pre><code class=\"language-JavaScript\">Array.prototype.concat.apply([], arrayLike);<br></code></pre><br><br>（4）通过 Array.from 方法来实现转换<br><br><pre><code class=\"language-JavaScript\">Array.from(arrayLike);<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319824,
    "title": "数组有哪些原生方法？",
    "content": "<li>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li><br><li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li><br><li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li><br><li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li><br><li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li><br><li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li><br><li>数组归并方法 reduce() 和 reduceRight() 方法</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319825,
    "title": "*Unicode、UTF-8、UTF-16、UTF-32的区别？**",
    "content": "<h4>（1）Unicode</h4><br><br>在说<code>Unicode</code>之前需要先了解一下<code>ASCII</code>码：ASCII 码（<code>American Standard Code for Information Interchange</code>）称为美国标准信息交换码。<br><br><li>它是基于拉丁字母的一套电脑编码系统。</li><br><li>它定义了一个用于代表常见字符的字典。</li><br><li>它包含了\"A-Z\"(包含大小写)，数据\"0-9\" 以及一些常见的符号。</li><br><li>它是专门为英语而设计的，有128个编码，对其他语言无能为力</li><br><br><code>ASCII</code>码可以表示的编码有限，要想表示其他语言的编码，还是要使用<code>Unicode</code>来表示，可以说<code>Unicode</code>是<code>ASCII</code> 的超集。<br><br><code>Unicode</code>全称 <code>Unicode Translation Format</code>，又叫做统一码、万国码、单一码。<code>Unicode</code> 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。<br><br><code>Unicode</code>的实现方式（也就是编码方式）有很多种，常见的是<strong>UTF-8</strong>、<strong>UTF-16</strong>、<strong>UTF-32</strong>和<strong>USC-2</strong>。<br><br><h4>（2）UTF-8</h4><br><br><code>UTF-8</code>是使用最广泛的<code>Unicode</code>编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容<code>ASCII</code>码的128个字符。<br><br><strong>注意：</strong> <code>UTF-8</code> 是一种编码方式，<code>Unicode</code>是一个字符集合。<br><br><code>UTF-8</code>的编码规则：<br><br><li>对于<strong>单字节</strong>的符号，字节的第一位为0，后面的7位为这个字符的<code>Unicode</code>编码，因此对于英文字母，它的<code>Unicode</code>编码和<code>ACSII</code>编码一样。</li><br><li>对于<strong>n字节</strong>的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的<code>Unicode</code>码 。</li><br><br>来看一下具体的<code>Unicode</code>编号范围与对应的<code>UTF-8</code>二进制格式 ：<br><br>| 编码范围（编号对应的十进制数）  | 二进制格式                          |<br>| ------------------------------- | ----------------------------------- |<br>| 0x00—0x7F （0-127）             | 0xxxxxxx                            |<br>| 0x80—0x7FF （128-2047）         | 110xxxxx 10xxxxxx                   |<br>| 0x800—0xFFFF  （2048-65535）    | 1110xxxx 10xxxxxx 10xxxxxx          |<br>| 0x10000—0x10FFFF  （65536以上） | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |<br><br>那该如何通过具体的<code>Unicode</code>编码，进行具体的<code>UTF-8</code>编码呢？<strong>步骤如下：</strong><br><br><li>找到该<code>Unicode</code>编码的所在的编号范围，进而找到与之对应的二进制格式</li><br><li>将<code>Unicode</code>编码转换为二进制数（去掉最高位的0）</li><br><li>将二进制数从右往左一次填入二进制格式的<code>X</code>中，如果有<code>X</code>未填，就设为0</li><br><br>来看一个实际的例子：<br><br>“<strong>马</strong>” 字的<code>Unicode</code>编码是：<code>0x9A6C</code>，整数编号是<code>39532</code><br><br>（1）首选确定了该字符在第三个范围内，它的格式是 <code>1110xxxx 10xxxxxx 10xxxxxx</code><br><br>（2）39532对应的二进制数为<code>1001 1010 0110 1100</code><br><br>（3）将二进制数填入X中，结果是：<code>11101001 10101001 10101100</code><br><br><h4>（3）UTF-16</h4><br><br><strong>1. 平面的概念</strong><br><br>在了解<code>UTF-16</code>之前，先看一下<strong>平面</strong>的概念：<br><br><code>Unicode</code>编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放<strong>65536</strong>（216）个字符，这称为一个<strong>平面</strong>，目前总共有17 个平面。<br><br>最前面的一个平面称为<strong>基本平面</strong>，它的码点从<strong>0 — 216</strong>-1，写成16进制就是<code>U+0000 — U+FFFF</code>，那剩下的16个平面就是<strong>辅助平面</strong>，码点范围是 <code>U+10000—U+10FFFF</code>。<br><br><strong>2. UTF-16 概念：</strong><br><br><code>UTF-16</code>也是<code>Unicode</code>编码集的一种编码形式，把<code>Unicode</code>字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。<code>Unicode</code>字符的码位需要1个或者2个16位长的码元来表示，因此<code>UTF-16</code>也是用变长字节表示的。<br><br><strong>3. UTF-16 编码规则：</strong><br><br><li>编号在 <code>U+0000—U+FFFF</code> 的字符（常用字符集），直接用两个字节表示。</li><br><li>编号在 <code>U+10000—U+10FFFF</code> 之间的字符，需要用四个字节表示。</li><br><br><strong>4. 编码识别</strong><br><br>那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？<br><br><code>UTF-16</code> 编码肯定也考虑到了这个问题，在基本平面内，从 <code>U+D800 — U+DFFF</code> 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。<br><br>辅助平面共有 <strong>220</strong> 个字符位，因此表示这些字符至少需要 20 个二进制位。<code>UTF-16</code> 将这 20 个二进制位分成两半，前 10 位映射在 <code>U+D800 — U+DBFF</code>，称为<strong>高位</strong>（H），后 10 位映射在 <code>U+DC00 — U+DFFF</code>，称为<strong>低位</strong>（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。<br><br>因此，当遇到两个字节时，发现它的码点在 <code>U+D800 —U+DBFF</code>之间，就可以知道，它后面的两个字节的码点应该在 <code>U+DC00 — U+DFFF</code> 之间，这四个字节必须放在一起进行解读。<br><br><strong>5. 举例说明</strong><br><br>以 \"<strong>𡠀</strong>\" 字为例，它的 <code>Unicode</code> 码点为 <code>0x21800</code>，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：<br><br><li>首先计算超出部分的结果：<code>0x21800 - 0x10000</code></li><br><li>将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：<code>0001000110 0000000000</code></li><br><li>将得到的两个10位二进制数分别对应到两个区间中</li><br><li><code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>， 将<code>0001000110</code>填充在它的后10 个二进制位，得到 <code>1101100001000110</code>，转成 16 进制数为 <code>0xD846</code>。同理，低位为 <code>0xDC00</code>，所以这个字的<code>UTF-16</code> 编码为 <code>0xD846 0xDC00</code></li><br><br><h4>（4） UTF-32</h4><br><br><code>UTF-32</code> 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。<br><br>比如“<strong>马</strong>” 字的Unicode编号是：<code>U+9A6C</code>，整数编号是<code>39532</code>，直接转化为二进制：<code>1001 1010 0110 1100</code>，这就是它的UTF-32编码。<br><br><h4>（5）总结</h4><br><br><strong>Unicode、UTF-8、UTF-16、UTF-32有什么区别？</strong><br><br><li><code>Unicode</code> 是编码字符集（字符集），而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是字符集编码（编码规则）；</li><br><li><code>UTF-16</code> 使用变长码元序列的编码方式，相较于定长码元序列的<code>UTF-32</code>算法更复杂，甚至比同样是变长码元序列的<code>UTF-8</code>也更为复杂，因为其引入了独特的<strong>代理对</strong>这样的代理机制；</li><br><li><code>UTF-8</code>需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而<code>UTF-16</code>不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；</li><br><li>如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用<code>UTF-8</code>就比<code>UTF-16</code>节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么<code>UTF-16</code>就占优势了，可以节省很多空间；</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319826,
    "title": "常见的位运算符有哪些？其计算规则是什么？",
    "content": "现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。<br><br>常见的位运算有以下几种：<br><br>| 运算符 | 描述 | 运算规则                                                 | 两个位都为0时，结果才为0 |<br>| ------ | ---- | -------------------------------------------------------- | ------------------------ |<br>| <code>&</code>    | 与   | 两个位都为1时，结果才为1                                 |                          |<br>| <code>      | </code>    | 或                                                       |                          |<br>| <code>^</code>    | 异或 | 两个位相同为0，相异为1                                   |                          |<br>| <code>~</code>    | 取反 | 0变1，1变0                                               |                          |<br>| <code><<</code>   | 左移 | 各二进制位全部左移若干位，高位丢弃，低位补0              |                          |<br>| <code>>></code>   | 右移 | 各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃 |                          |<br><br><h4>1. 按位与运算符（&）</h4><br><br><strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。<br><br><strong>运算规则：</strong><br><br><pre><code class=\"language-JavaScript\">0 & 0 = 0  <br>0 & 1 = 0  <br>1 & 0 = 0  <br>1 & 1 = 1<br></code></pre><br><br>总结：两位同时为1，结果才为1，否则结果为0。<br><br>例如：3&5 即：<br><br><pre><code class=\"language-JavaScript\">0000 0011 <br>   0000 0101 <br> = 0000 0001<br></code></pre><br><br>因此 3&5 的值为1。<br><br>注意：负数按补码形式参加按位与运算。<br><br><strong>用途：</strong><br><br><strong>（1）判断奇偶</strong><br><br>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i & 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。<br><br><strong>（2）清零</strong><br><br>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。<br><br><h4>2. 按位或运算符（|）</h4><br><br><strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。<br><br><strong>运算规则：</strong><br><br><pre><code class=\"language-JavaScript\">0 | 0 = 0<br>0 | 1 = 1  <br>1 | 0 = 1  <br>1 | 1 = 1<br></code></pre><br><br>总结：参加运算的两个对象只要有一个为1，其值为1。<br><br>例如：3|5即：<br><br><pre><code class=\"language-JavaScript\">0000 0011<br>  0000 0101 <br>= 0000 0111<br></code></pre><br><br>因此，3|5的值为7。<br><br>注意：负数按补码形式参加按位或运算。<br><br><h4>3. 异或运算符（^）</h4><br><br><strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。<br><br><strong>运算规则：</strong><br><br><pre><code class=\"language-JavaScript\">0 ^ 0 = 0  <br>0 ^ 1 = 1  <br>1 ^ 0 = 1  <br>1 ^ 1 = 0<br></code></pre><br><br>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。<br><br>例如：3|5即：<br><br><pre><code class=\"language-JavaScript\">0000 0011<br>  0000 0101 <br>= 0000 0110<br></code></pre><br><br>因此，3^5的值为6。<br><br>异或运算的性质:<br><br><li>交换律：<code>(a^b)^c == a^(b^c)</code></li><br><li>结合律：<code>(a + b)^c == a^b + b^c</code></li><br><li>对于任何数x，都有 <code>x^x=0，x^0=x</code></li><br><li>自反性: <code>a^b^b=a^0=a</code>;</li><br><br><h4>4. 取反运算符 (~)</h4><br><br><strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。<br><br>运算规则：<br><br><pre><code class=\"language-JavaScript\">~ 1 = 0<br>~ 0 = 1<br></code></pre><br><br>总结：对一个二进制数按位取反，即将0变1，1变0。<br><br>例如：~6 即：<br><br><pre><code class=\"language-JavaScript\">0000 0110<br>= 1111 1001<br></code></pre><br><br>在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。<br><br>当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：<br><br><pre><code class=\"language-JavaScript\">0000 0110<br>   = 1111 1001<br>反码：1000 0110<br>补码：1000 0111<br></code></pre><br><br>因此，~6的值为-7。<br><br><h4>5. 左移运算符（<<）</h4><br><br><strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。<br><br>设 a=1010 1110，a = a<< 2 将a的二进制位左移2位、右补0，即得a=1011 1000。<br><br>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。<br><br><h4>6. 右移运算符（>>）</h4><br><br><strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。<br><br>例如：a=a>>2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。<br><br>操作数每右移一位，相当于该数除以2。<br><br><h4>7. 原码、补码、反码</h4><br><br>上面提到了补码、反码等知识，这里就补充一下。<br><br>计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。<br><br><strong>（1）原码</strong><br><br>原码就是一个数的二进制数。<br><br>例如：10的原码为0000 1010<br><br><strong>（2）反码</strong><br><br><li>正数的反码与原码相同，如：10 反码为 0000 1010</li><br><li>负数的反码为除符号位，按位取反，即0变1，1变0。</li><br><br>例如：-10<br><br><pre><code class=\"language-JavaScript\">原码：1000 1010<br>反码：1111 0101<br></code></pre><br><br><strong>（3）补码</strong><br><br><li>正数的补码与原码相同，如：10 补码为 0000 1010</li><br><li>负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li><br><br>例如：-10<br><br><pre><code class=\"language-JavaScript\">原码：1000 1010<br>反码：1111 0101<br>补码：1111 0110<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319828,
    "title": "为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?",
    "content": "<code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。<br><br>要遍历类数组，有三个方法：<br><br>（1）将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：<br><br><pre><code class=\"language-JavaScript\">function foo(){ <br>  Array.prototype.forEach.call(arguments, a => console.log(a))<br>}<br></code></pre><br><br>（2）使用Array.from方法将类数组转化成数组：‌<br><br><pre><code class=\"language-JavaScript\">function foo(){ <br>  const arrArgs = Array.from(arguments) <br>  arrArgs.forEach(a => console.log(a))<br>}<br></code></pre><br><br>（3）使用展开运算符将类数组转化成数组<br><br><pre><code class=\"language-JavaScript\">function foo(){ <br>    const arrArgs = [...arguments] <br>    arrArgs.forEach(a => console.log(a)) <br>}<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319829,
    "title": "13*. 什么是 DOM 和 BOM？",
    "content": "<strong>回答：</strong><br><br>DOM（文档对象模型）是浏览器将 HTML 文档转换为 JavaScript 可操作的对象树结构，用于操作网页内容如文字、图片、按钮等元素；BOM（浏览器对象模型）是浏览器提供的与浏览器窗口交互的对象集合，用于操作浏览器本身如窗口、历史记录、弹窗等功能。简单来说，DOM 负责操作网页内容，BOM 负责操作浏览器功能，两者的根对象分别是 document 和 window。<br><br><li>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li><br><li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319830,
    "title": "对类数组对象的理解，如何转化为数组",
    "content": "一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。<br><br>常见的类数组转换为数组的方法有这样几种：<br><br><li>通过 call 调用数组的 slice 方法来实现转换</li><br><br><pre><code class=\"language-JavaScript\">Array.prototype.slice.call(arrayLike);<br></code></pre><br><br><li>通过 call 调用数组的 splice 方法来实现转换</li><br><br><pre><code class=\"language-JavaScript\">Array.prototype.splice.call(arrayLike, 0);<br></code></pre><br><br><li>通过 apply 调用数组的 concat 方法来实现转换</li><br><br><pre><code class=\"language-JavaScript\">Array.prototype.concat.apply([], arrayLike);<br></code></pre><br><br><li>通过 Array.from 方法来实现转换</li><br><br><pre><code class=\"language-JavaScript\">Array.from(arrayLike);<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319831,
    "title": "escape、encodeURI、encodeURIComponent 的区别",
    "content": "<li>encodeURI</li><br>  - <code>encodeURI</code> 用于对整个 URI 进行编码。它会将除了 URI 安全字符之外的所有字符编码。URI 安全字符包括字母、数字、连字符 <code>-</code>、下划线 <code>_</code>、波浪号 <code>~</code> 以及点 <code>.</code>。<code>encodeURI</code> 不会对 URI 中的保留字符进行编码，这些<strong>保留字符</strong>包括 <code>;</code>, <code>/</code>, <code>?</code>, <code>:</code>, <code>@</code>, <code>&</code>, <code>=</code>, <code>+</code>, <code>$</code>, <code>,</code>, <code>#</code>。<br>  - 代码示例：<br><br><pre><code class=\"language-JavaScript\">const uri = \"http://example.com/path/to/page?name=value&another=value\";<br>console.log(encodeURI(uri)); <br>// 输出: \"http://example.com/path/to/page?name=value&another=value\"<br></code></pre><br><br><li>encodeURIComponent</li><br>  - <code>encodeURIComponent</code> 用于对 URI 的各个<strong>组成部分</strong>进行编码，例如查询参数或片段标识符。它会将除了 <code>-</code>, <code>_</code>, <code>.</code>, <code>~</code> 之外的所有非字母数字字符进行编码。<code>encodeURIComponent</code> 会对所有保留字符进行编码，因此它非常适合用于编码 URL 的各个组成部分。。<br>  - 代码示例：<br><br><pre><code class=\"language-JavaScript\">const query = \"name=value&another=value\";<br>console.log(encodeURIComponent(query)); <br>// 输出: \"name%3Dvalue%26another%3Dvalue\"<br></code></pre><br><br><li>escape</li><br>  - <code>escape</code> 是一个较旧的函数，用于将字符串编码为适用于 URL 的格式。然而，<code>它已经被废弃</code>，并且不推荐在现代浏览器中使用。它的主要问题是它不能正确地处理 Unicode 字符，并且它的编码规则与现代 URL 编码标准不符。<br>  - 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319832,
    "title": "16*. 对AJAX的理解，实现一个AJAX请求",
    "content": "AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。<br><br>创建AJAX请求的步骤：<br><br><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><br><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><br><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><br><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li><br><br><pre><code class=\"language-JavaScript\">const SERVER_URL = \"/server\";<br>let xhr = new XMLHttpRequest();<br>// 创建 Http 请求<br>xhr.open(\"GET\", url, true);<br>// 设置状态监听函数<br>xhr.onreadystatechange = function() {<br>  if (this.readyState !== 4) return;<br>  // 当请求成功时<br>  if (this.status === 200) {<br>    handle(this.response);<br>  } else {<br>    console.error(this.statusText);<br>  }<br>};<br>// 设置请求失败时的监听函数<br>xhr.onerror = function() {<br>  console.error(this.statusText);<br>};<br>// 设置请求头信息<br>xhr.responseType = \"json\";<br>xhr.setRequestHeader(\"Accept\", \"application/json\");<br>// 发送 Http 请求<br>xhr.send(null);<br></code></pre><br><br>使用Promise封装AJAX：<br><br><pre><code class=\"language-JavaScript\">// promise 封装实现：<br>function getJSON(url) {<br>  // 创建一个 promise 对象<br>  let promise = new Promise(function(resolve, reject) {<br>    let xhr = new XMLHttpRequest();<br>    // 新建一个 http 请求<br>    xhr.open(\"GET\", url, true);<br>    // 设置状态的监听函数<br>    xhr.onreadystatechange = function() {<br>      if (this.readyState !== 4) return;<br>      // 当请求成功或失败时，改变 promise 的状态<br>      if (this.status === 200) {<br>        resolve(this.response);<br>      } else {<br>        reject(new Error(this.statusText));<br>      }<br>    };<br>    // 设置错误监听函数<br>    xhr.onerror = function() {<br>      reject(new Error(this.statusText));<br>    };<br>    // 设置响应的数据类型<br>    xhr.responseType = \"json\";<br>    // 设置请求头信息<br>    xhr.setRequestHeader(\"Accept\", \"application/json\");<br>    // 发送 http 请求<br>    xhr.send(null);<br>  });<br>  return promise;<br>}<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319833,
    "title": "JavaScript为什么要进行变量提升，它导致了什么问题？",
    "content": "<strong>回答：</strong><br><br>JavaScript 变量提升是编译器将变量和函数声明移动到作用域顶部的机制，其历史原因是为了简化早期编译器实现并允许在声明前调用函数，但这种机制导致声明与赋值分离造成理解困难、变量覆盖、函数声明优先级混乱、循环变量泄漏、全局污染和调试困难等问题，现代 JavaScript 推荐使用 let 和 const 替代 var，它们虽然也有提升但会进入暂时性死区（TDZ）在声明前访问会报错而非 undefined，配合严格模式、在作用域顶部声明变量、使用函数表达式等最佳实践可以有效避免变量提升带来的问题。<br><br>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。<br><br>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。<br><br>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。<br><br><li><strong>在解析阶段</strong>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</li><br><li><strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</li><br><br>那为什么会进行变量提升呢？主要有以下两个原因：<br><br><li>提高性能</li><br><li>容错性更好</li><br><br><strong>（1）提高性能</strong><br><br>在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。<br><br>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。<br><br><strong>（2）容错性更好</strong><br><br>变量提升可以在一定程度上提高JS的容错性，看下面的代码：<br><br><pre><code class=\"language-JavaScript\">a = 1;<br>var a;<br>console.log(a);<br></code></pre><br><br>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。<br><br>虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。<br><br><strong>总结：</strong><br><br><li>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li><br><li>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li><br><br>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：<br><br><pre><code class=\"language-JavaScript\">var tmp = new Date();<br><br>function fn(){<br>  console.log(tmp);<br>  if(false){<br>    var tmp = 'hello world';<br>  }<br>}<br><br>fn();  // undefined<br></code></pre><br><br>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。<br><br><pre><code class=\"language-JavaScript\">var tmp = 'hello world';<br><br>for (var i = 0; i < tmp.length; i++) {<br>  console.log(tmp[i]);<br>}<br><br>console.log(i); // 11<br></code></pre><br><br>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319834,
    "title": "什么是尾调用，使用尾调用有什么好处？",
    "content": "尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319835,
    "title": "*ES6**模块与**CommonJS**模块有什么异同？",
    "content": "<strong>回答：</strong><br><br>ES6模块与CommonJS模块都解决了JavaScript模块化问题并避免全局污染，但核心差异在于加载机制：CommonJS采用运行时加载和值拷贝，支持动态导入但无法静态分析和tree-shaking，语法为require/exports；<br><br>ES6模块采用编译时加载和动态绑定，支持静态分析和tree-shaking优化，语法为import/export，this指向undefined而非CommonJS的{}<br><br>ES6 Module和CommonJS模块的区别：<br><br><li>CommonJS</li><br>  - 使用 <code>require</code> 函数来加载模块，使用 <code>module.exports</code> 或 <code>exports</code> 对象来导出模块中的变量、函数或类，没有默认导出的概念，所有导出都是显式的。<br>  - 是动态加载的，依赖关系<strong>在运行时确定</strong>；不支持树摇，必须加载整个模块才能使用其中的一个导出；可以在严格模式或非严格模式下执行。<br>  - 是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；<br><li>ES6 模块</li><br>  - 使用 <code>import</code> 语句导入模块中的导出；使用 <code>export</code> 语句导出模块中的变量、函数或类；可以使用 <code>export default</code> 来导出一个默认的导出项。<br>  - 是<strong>静态分析</strong>的，这意味着在执行代码之前就已经确定了模块的依赖关系；<strong>支持树摇</strong>（Tree Shaking），可以排除未使用的导出；使用严格模式（strict mode）执行。<br>  - import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。<br><br>ES6 Module和CommonJS模块的共同点：<br><br><li>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319836,
    "title": "常见的DOM操作有哪些",
    "content": "<h4>1）DOM 节点的获取</h4><br><br>DOM 节点的获取的API及使用：<br><br><pre><code class=\"language-JavaScript\">getElementById // 按照 id 查询<br>getElementsByTagName // 按照标签名查询<br>getElementsByClassName // 按照类名查询<br>querySelectorAll // 按照 css 选择器查询<br><br>// 按照 id 查询<br>var imooc = document.getElementById('imooc') // 查询到 id 为 imooc 的元素<br>// 按照标签名查询<br>var pList = document.getElementsByTagName('p')  // 查询到标签为 p 的集合<br>console.log(divList.length)<br>console.log(divList[0])<br>// 按照类名查询<br>var moocList = document.getElementsByClassName('mooc') // 查询到类名为 mooc 的集合<br>// 按照 css 选择器查询<br>var pList = document.querySelectorAll('.mooc') // 查询到类名为 mooc 的集合<br></code></pre><br><br><h4>2）DOM 节点的创建</h4><br><br><strong>创建一个新节点，并把它添加到指定节点的后面。</strong> 已知的 HTML 结构如下：<br><br><pre><code class=\"language-HTML\"><html><br>  <head><br>    <title>DEMO</title><br>  </head><br>  <body><br>    <div id=\"container\"> <br>      <h1 id=\"title\">我是标题</h1><br>    </div>   <br>  </body><br></html><br></code></pre><br><br>要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：<br><br><pre><code class=\"language-JavaScript\">// 首先获取父节点<br>var container = document.getElementById('container')<br>// 创建新节点<br>var targetSpan = document.createElement('span')<br>// 设置 span 节点的内容<br>targetSpan.innerHTML = 'hello world'<br>// 把新创建的元素塞进父节点里去<br>container.appendChild(targetSpan)<br></code></pre><br><br><h4>3）DOM 节点的删除</h4><br><br><strong>删除指定的 DOM 节点，</strong> 已知的 HTML 结构如下：<br><br><pre><code class=\"language-JavaScript\"><html><br>  <head><br>    <title>DEMO</title><br>  </head><br>  <body><br>    <div id=\"container\"> <br>      <h1 id=\"title\">我是标题</h1><br>    </div>   <br>  </body><br></html><br></code></pre><br><br>需要删除 id 为 title 的元素，做法是：<br><br><pre><code class=\"language-JavaScript\">// 获取目标元素的父元素<br>var container = document.getElementById('container')<br>// 获取目标元素<br>var targetNode = document.getElementById('title')<br>// 删除目标元素<br>container.removeChild(targetNode)<br></code></pre><br><br>或者通过子节点数组来完成删除：<br><br><pre><code class=\"language-JavaScript\">// 获取目标元素的父元素<br>var container = document.getElementById('container')<br>// 获取目标元素<br>var targetNode = container.childNodes[1]<br>// 删除目标元素<br>container.removeChild(targetNode)<br></code></pre><br><br><h4>4）修改 DOM 元素</h4><br><br>修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。<br><br><strong>将指定的两个 DOM 元素交换位置，</strong> 已知的 HTML 结构如下：<br><br><pre><code class=\"language-JavaScript\"><html><br>  <head><br>    <title>DEMO</title><br>  </head><br>  <body><br>    <div id=\"container\"> <br>      <h1 id=\"title\">我是标题</h1><br>      <p id=\"content\">我是内容</p><br>    </div>   <br>  </body><br></html><br></code></pre><br><br>现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：<br><br><pre><code class=\"language-JavaScript\">// 获取父元素<br>var container = document.getElementById('container')   <br> <br>// 获取两个需要被交换的元素<br>var title = document.getElementById('title')<br>var content = document.getElementById('content')<br>// 交换两个元素，把 content 置于 title 前面<br>container.insertBefore(content, title)<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319837,
    "title": "use strict是什么意思 ? 使用它区别是什么？",
    "content": "use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：<br><br><li>消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;</li><br><li>消除代码运行的不安全之处，保证代码运行的安全；</li><br><li>提高编译器效率，增加运行速度；</li><br><li>为未来新版本的 Javascript 做好铺垫。</li><br><br>区别：<br><br><li>禁止使用 with 语句。</li><br><li>禁止 this 关键字指向全局对象。</li><br><li>对象不能有重名的属性。</li>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319838,
    "title": "如何判断一个对象是否属于某个类？",
    "content": "<li>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li><br><li>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li><br><li>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319839,
    "title": "强类型语言和弱类型语言的区别",
    "content": "<li><strong>强类型语言</strong>：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。</li><br><li><strong>弱类型语言</strong>：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串'12'和整数3进行连接得到字符串'123'，在相加的时候会进行强制类型转换。</li><br><br>两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319840,
    "title": "解释性语言和编译型语言的区别",
    "content": "（1）解释型语言<br><br>使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下<br><br><li>解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</li><br><li>只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</li><br><li>JavaScript、Python等属于解释型语言。</li><br><br>（2）编译型语言<br><br>使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：<br><br><li>一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li><br><li>与特定平台相关，一般无法移植到其他平台；</li><br><li>C、C++等属于编译型语言。</li><br><br><strong>两者主要区别在于：</strong> 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319841,
    "title": "25*. for...in和for...of的区别",
    "content": "for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下<br><br><li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li><br><li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319842,
    "title": "如何使用for...of遍历对象",
    "content": "for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。<br><br>如果需要遍历的对象是类数组对象，用Array.from转成数组即可。<br><br><pre><code class=\"language-JavaScript\">var obj = {<br>    0:'one',<br>    1:'two',<br>    length: 2<br>};<br>obj = Array.from(obj);<br>for(var k of obj){<br>    console.log(k)<br>}<br></code></pre><br><br>如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。<br><br><pre><code class=\"language-JavaScript\">//方法一：<br>var obj = {<br>    a:1,<br>    b:2,<br>    c:3<br>};<br><br>obj[Symbol.iterator] = function(){<br>  var keys = Object.keys(this);<br>  var count = 0;<br>  return {<br>    next(){<br>      if(count<keys.length){<br>        return {value: obj[keys[count++]],done:false};<br>      }else{<br>        return {value:undefined,done:true};<br>      }<br>    }<br>  }<br>};<br><br>for(var k of obj){<br>  console.log(k);<br>}<br><br>// 方法二<br>var obj = {<br>    a:1,<br>    b:2,<br>    c:3<br>};<br>obj[Symbol.iterator] = function*(){<br>    var keys = Object.keys(obj);<br>    for(var k of keys){<br>        yield [k,obj[k]]<br>    }<br>};<br><br>for(var [k,v] of obj){<br>    console.log(k,v);<br>}<br></code></pre>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319843,
    "title": "ajax、axios、fetch的区别",
    "content": "<strong>（1）AJAX</strong><br><br>Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式[网页](https://link.zhihu.com/?target=https://baike.baidu.com/item/网页)应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：<br><br><li>本身是针对MVC编程，不符合前端MVVM的浪潮</li><br><li>基于原生XHR开发，XHR本身的架构不清晰</li><br><li>不符合关注分离（Separation of Concerns）的原则</li><br><li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li><br><br><strong>（2）Fetch</strong><br><br>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。<strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。<br><br>fetch的优点：<br><br><li>语法简洁，更加语义化</li><br><li>基于标准 Promise 实现，支持 async/await</li><br><li>更加底层，提供的API丰富（request, response）</li><br><li>脱离了XHR，是ES规范里新的实现方式</li><br><br>fetch的缺点：<br><br><li>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li><br><li>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})</li><br><li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li><br><li>fetch没有办法原生监测请求的进度，而XHR可以</li><br><br><strong>（3）Axios</strong><br><br>Axios 是一种基于Promise封装的HTTP客户端，其特点如下：<br><br><li>浏览器端发起XMLHttpRequests请求</li><br><li>node端发起http请求</li><br><li>支持Promise API</li><br><li>监听请求和返回</li><br><li>对请求和返回进行转化</li><br><li>取消请求</li><br><li>自动转换json数据</li><br><li>客户端支持抵御XSRF攻击</li>",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319844,
    "title": "数组的遍历方法有哪些",
    "content": "总结：forEach，map，filter，for...of，find<br><br>| ***<em><strong>方法</strong>              | </em>**<em><strong>是否改变原数组</strong> | </em>***<strong>特点</strong>                                                 |<br>| ------------------------- | ---------------------- | ------------------------------------------------------------ |<br>| forEach()                 | 是                     | 数组方法，会改变原数组，没有返回值                           |<br>| map()                     | 否                     | 数组方法，不改变原数组，有返回值，可链式调用                 |<br>| filter()                  | 否                     | 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用 |<br>| for...of                  | 否                     | for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环 |<br>| every() 和 some()         | 否                     | 数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false. |<br>| find() 和 findIndex()     | 否                     | 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值 |<br>| reduce() 和 reduceRight() | 否                     | 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作 |",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319845,
    "title": "forEach和map方法有什么区别",
    "content": "这方法都是用来遍历数组的，两者区别如下：<br><br><li>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li><br><li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li>",
    "categoryId": "1768000001004",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103319846,
    "title": "addEventListener()方法的参数和使用",
    "content": "<strong>EventTarget.addEventListener()</strong> 方法将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 事件目标可以是一个文档上的元素 Element，Document和Window或者任何其他支持事件的对象。<br><br>addEventListener()的工作原理是将实现EventListener的函数或对象添加到调用它的EventTarget上的指定事件类型的事件侦听器列表中。<br><br>它的使用语法如下：<br><br><pre><code class=\"language-JavaScript\">target.addEventListener(type, listener, options);<br>target.addEventListener(type, listener, useCapture);<br>target.addEventListener(type, listener, useCapture, wantsUntrusted);  <br></code></pre><br><br>其中参数如下：<br><br><strong>（1）type</strong><br><br>表示监听事件类型的字符串。<br><br><strong>（2）listener</strong><br><br>当所监听的事件类型触发时，会接收到一个事件通知（实现了 Event 接口的对象）对象。listener 必须是一个实现了 EventListener 接口的对象，或者是一个函数。<br><br><strong>（3）options 可选</strong><br><br>一个指定有关 listener 属性的可选参数<strong>对象</strong>。可用的选项如下：<br><br><li>capture:  Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。</li><br><li>once:  Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。</li><br><li>passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。</li><br><li>signal：AbortSignal，该 AbortSignal 的 abort() 方法被调用时，监听器会被移除。</li><br><br><strong>（4）useCapture</strong>  <strong>可选</strong><br><br>Boolean，在DOM树中，注册了listener的元素， 是否要先于它下面的EventTarget，调用该listener。 当useCapture(设为true) 时，沿着DOM树向上冒泡的事件，不会触发listener。当一个元素嵌套了另一个元素，并且两个元素都对同一事件注册了一个处理函数时，所发生的事件冒泡和事件捕获是两种不同的事件传播方式。事件传播模式决定了元素以哪个顺序接收事件。如果没有指定， useCapture 默认为 false 。<br><br><strong>（5）wantsUntrusted</strong><br><br>如果为 true , 则事件处理程序会接收网页自定义的事件。此参数只适用于 Gecko（chrome的默认值为true，其他常规网页的默认值为false），主要用于附加组件的代码和浏览器本身。",
    "categoryId": "1768000001004",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:48:39.806Z",
    "updatedAt": "2026-01-11T03:48:39.806Z"
  },
  {
    "id": 1768103590262,
    "title": "let、const、var的区别",
    "content": "<strong>回答：</strong><br><br>1. let和const具有块级作用域而var是函数作用域<br>2. let和const不存在变量提升而var存在变量提升<br>3. let和const不能重复声明而var可以<br>4. const声明后不能重新赋值而let和var可以<br>5. var全局声明会挂载到window对象而let和const不会<br><br><strong>解析：</strong><br><br><strong>（1）块级作用域：</strong>块作用域由 <code>{ }</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：<br><br><li>内层变量可能覆盖外层变量</li><br><li>用来计数的循环变量泄露为全局变量</li><br><br><strong>（2）变量提升：</strong>var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。<br><br><strong>（3）给全局添加属性：</strong>浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。<br><br><strong>（4）重复声明：</strong>var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。<br><br><strong>（5）暂时性死区：在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为</strong>暂时性死区。使用var声明的变量不存在暂时性死区。<br><br><strong>（6）初始值设置：</strong>在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。<br><br><strong>（7）指针指向：</strong>let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。<br><br>| <strong>区别</strong>           | <strong>var</strong> | <strong>let</strong> | <strong>const</strong> |<br>| ------------------ | ------- | ------- | --------- |<br>| 是否有块级作用域   | ×       | ✔️       | ✔️         |<br>| 是否存在变量提升   | ✔️       | ×       | ×         |<br>| 是否添加全局属性   | ✔️       | ×       | ×         |<br>| 能否重复声明变量   | ✔️       | ×       | ×         |<br>| 是否存在暂时性死区 | ×       | ✔️       | ✔️         |<br>| 是否必须设置初始值 | ×       | ×       | ✔️         |<br>| 能否改变指针指向   | ✔️       | ✔️       | ×         |",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590263,
    "title": "const对象的属性可以修改吗",
    "content": "<strong>回答：</strong><br><br>const对象的属性可以修改，因为const保证的是变量指向的内存地址不变而不是对象内容不变，所以可以修改、新增或删除对象的属性，但不能重新赋值整个对象<br><br>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。<br><br>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590264,
    "title": "如果new一个箭头函数的会怎么样",
    "content": "<strong>回答：</strong><br><br>new一个箭头函数会报错，因为箭头函数没有自己的this而是捕获外层作用域的this，没有prototype属性，不能用作构造函数，所以禁止使用new关键字调用，箭头函数设计初衷是作为回调函数使用而非构造函数。<br><br>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。<br><br>new操作符的实现步骤如下：<br><br>1. 创建一个对象<br>2. 将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）<br>3. 指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）<br>4. 返回新的对象<br><br>所以，上面的第二、三步，箭头函数都是没有办法执行的。",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590265,
    "title": "箭头函数与普通函数的区别",
    "content": "<strong>回答：</strong><br><br>箭头函数与普通函数的主要区别在于：<br><br>箭头函数没有自己的this而是继承外层作用域的this且无法通过call/apply/bind改变，没有prototype属性不能用作构造函数，没有arguments对象需用剩余参数代替，不能用new调用，不能用作Generator函数，不能使用yield关键字，没有自己的super关键字，语法更简洁适合回调函数，而普通函数this指向调用者可改变、有prototype可作为构造函数、有arguments对象、可用new创建实例、可使用super关键字，适用于需要this绑定、作为构造函数或需要arguments对象的场景。<br><br><strong>（1）箭头函数比普通函数更加简洁</strong><br><br><li>如果没有参数，就直接写一个空括号即可</li><br><li>如果只有一个参数，可以省去参数的括号</li><br><li>如果有多个参数，用逗号分割</li><br><li>如果函数体的返回值只有一句，可以省略大括号</li><br><li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li><br><br><pre><code class=\"language-JavaScript\">let fn = () => void doesNotReturn();<br></code></pre><br><br><strong>（2）箭头函数没有自己的this</strong><br><br>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。<br><br><strong>（3）箭头函数继承来的this指向永远不会改变</strong><br><br><pre><code class=\"language-JavaScript\">var id = 'GLOBAL';<br>var obj = {<br>  id: 'OBJ',<br>  a: function(){<br>    console.log(this.id);<br>  },<br>  b: () => {<br>    console.log(this.id);<br>  }<br>};<br>obj.a();    // 'OBJ'<br>obj.b();    // 'GLOBAL'<br>new obj.a()  // undefined<br>new obj.b()  // Uncaught TypeError: obj.b is not a constructor<br></code></pre><br><br>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<code>{}</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。<br><br><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong><br><br><pre><code class=\"language-JavaScript\">var id = 'Global';<br>let fun1 = () => {<br>    console.log(this.id)<br>};<br>fun1();                     // 'Global'<br>fun1.call({id: 'Obj'});     // 'Global'<br>fun1.apply({id: 'Obj'});    // 'Global'<br>fun1.bind({id: 'Obj'})();   // 'Global'<br></code></pre><br><br><strong>（5）箭头函数不能作为构造函数使用</strong><br><br>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。<br><br><strong>（6）箭头函数没有自己的arguments</strong><br><br>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。<br><br><strong>（7）箭头函数没有prototype</strong><br><br><strong>（8）箭头函数不能用作Generator函数，不能使用yeild关键字</strong>",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590266,
    "title": "箭头函数的**this**指向哪⾥？",
    "content": "箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。<br><br>可以⽤Babel理解⼀下箭头函数:<br><br><pre><code class=\"language-JavaScript\">// ES6 <br>const obj = { <br>  getArrow() { <br>    return () => { <br>      console.log(this === obj); <br>    }; <br>  } <br>}<br></code></pre><br><br>转化后：<br><br><pre><code class=\"language-JavaScript\">// ES5，由 Babel 转译<br>var obj = { <br>   getArrow: function getArrow() { <br>     var _this = this; <br>     return function () { <br>        console.log(_this === obj); <br>     }; <br>   } <br>};<br></code></pre>",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590267,
    "title": "扩展运算符的作用及使用场景",
    "content": "<strong>（1）对象扩展运算符</strong><br><br>对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。<br><br><pre><code class=\"language-JavaScript\">let bar = { a: 1, b: 2 };<br>let baz = { ...bar }; // { a: 1, b: 2 }<br></code></pre><br><br>上述方法实际上等价于:<br><br><pre><code class=\"language-JavaScript\">let bar = { a: 1, b: 2 };<br>let baz = Object.assign({}, bar); // { a: 1, b: 2 }<br></code></pre><br><br><code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。<br><br>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。<br><br><pre><code class=\"language-JavaScript\">let bar = {a: 1, b: 2};<br>let baz = {...bar, ...{a:2, b: 4}};  // {a: 2, b: 4}<br></code></pre><br><br>利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。<br><br>需要注意：扩展运算符对<strong>对象实例的拷贝属于浅拷贝</strong>。<br><br><strong>（2）数组扩展运算符</strong><br><br>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。<br><br><pre><code class=\"language-JavaScript\">console.log(...[1, 2, 3])<br>// 1 2 3<br>console.log(...[1, [2, 3, 4], 5])<br>// 1 [2, 3, 4] 5<br></code></pre><br><br>下面是数组的扩展运算符的应用：<br><br><li><strong>将数组转换为参数序列</strong></li><br><br><pre><code class=\"language-JavaScript\">function add(x, y) {<br>  return x + y;<br>}<br>const numbers = [1, 2];<br>add(...numbers) // 3<br></code></pre><br><br><li><strong>复制数组</strong></li><br><br><pre><code class=\"language-JavaScript\">const arr1 = [1, 2];<br>const arr2 = [...arr1];<br></code></pre><br><br>要记住：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。<br><br><li><strong>合并数组</strong></li><br><br>如果想在数组内合并数组，可以这样：<br><br><pre><code class=\"language-JavaScript\">const arr1 = ['two', 'three'];<br>const arr2 = ['one', ...arr1, 'four', 'five'];<br>// [\"one\", \"two\", \"three\", \"four\", \"five\"]<br></code></pre><br><br><li><strong>扩展运算符与解构赋值结合起来，用于生成数组</strong></li><br><br><pre><code class=\"language-JavaScript\">const [first, ...rest] = [1, 2, 3, 4, 5];<br>first // 1<br>rest  // [2, 3, 4, 5]<br></code></pre><br><br>需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong><br><br><pre><code class=\"language-JavaScript\">const [...rest, last] = [1, 2, 3, 4, 5];         // 报错<br>const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错<br></code></pre><br><br><li><strong>将字符串转为真正的数组</strong></li><br><br><pre><code class=\"language-JavaScript\">[...'hello']    // [ \"h\", \"e\", \"l\", \"l\", \"o\" ]<br></code></pre><br><br><li><strong>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</strong></li><br><br>比较常见的应用是可以将某些数据结构转为数组：<br><br><pre><code class=\"language-JavaScript\">// arguments对象<br>function foo() {<br>  const args = [...arguments];<br>}<br></code></pre><br><br>用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。<br><br><li><strong>使用</strong><code><strong>Math</strong></code><strong>函数获取数组中特定的值</strong></li><br><br><pre><code class=\"language-JavaScript\">const numbers = [9, 4, 7, 1];<br>Math.min(...numbers); // 1<br>Math.max(...numbers); // 9<br></code></pre>",
    "categoryId": "1768000001005",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590268,
    "title": "对对象与数组的解构的理解",
    "content": "解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。<br><br><strong>1）数组的解构</strong><br><br>在解构数组时，以元素的位置为匹配条件来提取想要的数据的：<br><br><pre><code class=\"language-JavaScript\">const [a, b, c] = [1, 2, 3]<br></code></pre><br><br>最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：<br><br>![img](https://secure2.wostatic.cn/static/qLe5MFqx2XRQAqtJDWd7oa/image.png?auth_key=1768103476-fu7mWciZ6ob6ERNkeHkas4-0-cb1a38b72770cfc62cc83a4e9bc6af7b)<br><br>数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：<br><br><pre><code class=\"language-JavaScript\">const [a,,c] = [1,2,3]<br></code></pre><br><br>通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量：<br><br>![img](https://secure2.wostatic.cn/static/vDcrxGKrQhCeTsr3U3q3kX/image.png?auth_key=1768103476-mrgyGc58k7ZTBKXBmCBLoV-0-baf74d9fabbb8a62aad64c748ba7efdf)<br><br><strong>2）对象的解构</strong><br><br>对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：<br><br><pre><code class=\"language-JavaScript\">const stu = {<br>  name: 'Bob',<br>  age: 24<br>}<br></code></pre><br><br>假如想要解构它的两个自有属性，可以这样：<br><br><pre><code class=\"language-JavaScript\">const { name, age } = stu<br></code></pre><br><br>这样就得到了 name 和 age 两个和 stu 平级的变量：<br><br>![img](https://secure2.wostatic.cn/static/rqYLfzHrRVUskHjg4xDaia/image.png?auth_key=1768103477-4Ex5K66AWgpy4QHNAZh3dX-0-4fddc0504a1a99b25096dc128422d6f5)<br><br>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：<br><br><pre><code class=\"language-JavaScript\">const { age, name } = stu<br></code></pre>",
    "categoryId": "1768000001005",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590269,
    "title": "*如何提取高度嵌套的对象里的指定属性？**",
    "content": "有时会遇到一些嵌套程度非常深的对象：<br><br><pre><code class=\"language-JavaScript\">const school = {<br>   classes: {<br>      stu: {<br>         name: 'Bob',<br>         age: 24,<br>      }<br>   }<br>}<br></code></pre><br><br>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：<br><br><pre><code class=\"language-JavaScript\">const { name } = school<br></code></pre><br><br>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：<br><br><pre><code class=\"language-JavaScript\">const { classes } = school<br>const { stu } = classes<br>const { name } = stu<br>name // 'Bob'<br></code></pre><br><br>但是还有一种更标准的做法，可以用一行代码来解决这个问题：<br><br><pre><code class=\"language-JavaScript\">const { classes: { stu: { name } }} = school<br>       <br>console.log(name)  // 'Bob'<br></code></pre><br><br>可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590270,
    "title": "对 rest 参数的理解",
    "content": "扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：<br><br><pre><code class=\"language-JavaScript\">function mutiple(...args) {<br>  let result = 1;<br>  for (var val of args) {<br>    result *= val;<br>  }<br>  return result;<br>}<br>mutiple(1, 2, 3, 4) // 24<br></code></pre><br><br>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：<br><br><pre><code class=\"language-JavaScript\">function mutiple(...args) {<br>  console.log(args)<br>}<br>mutiple(1, 2, 3, 4) // [1, 2, 3, 4]<br></code></pre><br><br>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong>",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": 1768103590271,
    "title": "ES6中模板语法与字符串处理",
    "content": "ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：<br><br><pre><code class=\"language-JavaScript\">var name = 'css'   <br>var career = 'coder' <br>var hobby = ['coding', 'writing']<br>var finalString = 'my name is ' + name + ', I work as a ' + career + ', I love ' + hobby[0] + ' and ' + hobby[1]<br></code></pre><br><br>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：<br><br><pre><code class=\"language-JavaScript\">var name = 'css'   <br>var career = 'coder' <br>var hobby = ['coding', 'writing']<br>var finalString = <code>my name is ${name}, I work as a ${career} I love ${hobby[0]} and ${hobby[1]}</code><br></code></pre><br><br>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：<br><br><li>在模板字符串中，空格、缩进、换行都会被保留</li><br><li>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li><br><br>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：<br><br><pre><code class=\"language-JavaScript\">let list = <code><br>  <ul><br>    <li>列表项1</li><br>    <li>列表项2</li><br>  </ul><br></code>;<br>console.log(message); // 正确输出，不存在报错<br></code></pre><br><br>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：<br><br><pre><code class=\"language-JavaScript\">function add(a, b) {<br>  const finalString = <code>${a} + ${b} = ${a+b}</code><br>  console.log(finalString)<br>}<br>add(1, 2) // 输出 '1 + 2 = 3'<br></code></pre><br><br>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：<br><br><li><strong>存在性判定</strong>：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf > -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</li><br><li>- <strong>includes</strong>：判断字符串与子串的包含关系：</li><br><br><pre><code class=\"language-JavaScript\">const son = 'haha' <br>const father = 'xixi haha hehe'<br>father.includes(son) // true<br></code></pre><br><br><li>- <strong>startsWith</strong>：判断字符串是否以某个/某串字符开头：</li><br><br><pre><code class=\"language-JavaScript\">const father = 'xixi haha hehe'<br>father.startsWith('haha') // false<br>father.startsWith('xixi') // true<br></code></pre><br><br><li>- <strong>endsWith</strong>：判断字符串是否以某个/某串字符结尾：</li><br><br><pre><code class=\"language-JavaScript\">const father = 'xixi haha hehe'<br>  father.endsWith('hehe') // true<br></code></pre><br><br><li><strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</li><br><br><pre><code class=\"language-JavaScript\">const sourceCode = 'repeat for 3 times;'<br>const repeated = sourceCode.repeat(3) <br>console.log(repeated) // repeat for 3 times;repeat for 3 times;repeat for 3 times;<br></code></pre>",
    "categoryId": "1768000001005",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:53:10.251Z",
    "updatedAt": "2026-01-11T03:53:10.251Z"
  },
  {
    "id": "1768103647710",
    "title": "UI组件库",
    "content": "<h3>Bootstrap</h3>\n<p><a href=\"https://www.bootcss.com/\">https://www.bootcss.com/</a></p>\n<h3>Layui</h3>\n<p><a href=\"http://layui.xhcen.com/layui.html\">http://layui.xhcen.com/layui.html</a></p>\n<h3><strong>Vant</strong></h3>\n<p><a href=\"https://vant-ui.github.io/vant/#/zh-CN\">https://vant-ui.github.io/vant/#/zh-CN</a></p>\n<h3><strong>Vant Weapp</strong></h3>\n<p><a href=\"https://youzan.github.io/vant-weapp/#/home\">https://youzan.github.io/vant-weapp/#/home</a></p>\n<h3><strong>ElementUI</strong></h3>\n<p><a href=\"https://element.eleme.cn/#/zh-CN\">https://element.eleme.cn/#/zh-CN</a></p>\n<h3><strong>Element Plus</strong></h3>\n<p><a href=\"https://element-plus.org/zh-CN/#/zh-CN\">https://element-plus.org/zh-CN/#/zh-CN</a></p>\n<h3><strong>AntDesign</strong></h3>\n<p><a href=\"https://ant-design.antgroup.com/index-cn\">https://ant-design.antgroup.com/index-cn</a></p>\n<h3><strong>AntDesign Vue</strong></h3>\n<p><a href=\"https://www.antdv.com/docs/vue/introduce\">https://www.antdv.com/docs/vue/introduce</a></p>",
    "categoryId": "1768000001015",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:54:07.710Z",
    "updatedAt": "2026-01-11T03:54:07.710Z"
  },
  {
    "id": 1768103797051,
    "title": "1. 对原型、原型链的理解",
    "content": "<strong>回答：</strong><br><br>每个函数都有一个prototype属性，指向一个对象（原型对象）称这个对象为原型对象。<br><br>当访问一个对象的属性时，会先在对象本身查找，如果找不到，会沿着__proto__向上查找，直到找到或到达Object.prototype. proto （null）这种查找链条就是原型链<br><br>在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。<br><br>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。<br><br><strong>特点：</strong> JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。<br><br>![img](https://secure2.wostatic.cn/static/bJ92MYsFbsAUVFHqwa1c6D/2.png?auth_key=1768103667-k2S4PpLAQ7bfBeRrPpu1D1-0-ff72fff33b0a5ae77171d5ba7a88f034)",
    "categoryId": "1768000001006",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797052,
    "title": "2. 原型修改、重写",
    "content": "<pre><code class=\"language-JavaScript\">function Person(name) {<br>    this.name = name<br>}<br>// 修改原型<br>Person.prototype.getName = function() {}<br>var p = new Person('hello')<br>console.log(p.__proto__ === Person.prototype) // true<br>console.log(p.__proto__ === p.constructor.prototype) // true<br>// 重写原型<br>Person.prototype = {<br>    getName: function() {}<br>}<br>var p = new Person('hello')<br>console.log(p.__proto__ === Person.prototype)        // true<br>console.log(p.__proto__ === p.constructor.prototype) // false<br></code></pre><br><br>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用constructor指回来：<br><br><pre><code class=\"language-JavaScript\">Person.prototype = {<br>    getName: function() {}<br>}<br>var p = new Person('hello')<br>p.constructor = Person<br>console.log(p.__proto__ === Person.prototype)        // true<br>console.log(p.__proto__ === p.constructor.prototype) // true<br></code></pre>",
    "categoryId": "1768000001006",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797053,
    "title": "3. 原型链指向",
    "content": "<pre><code class=\"language-JavaScript\">p.__proto__  // Person.prototype<br>Person.prototype.__proto__  // Object.prototype<br>p.__proto__.__proto__ //Object.prototype<br>p.__proto__.constructor.prototype.__proto__ // Object.prototype<br>Person.prototype.constructor.prototype.__proto__ // Object.prototype<br>p1.__proto__.constructor // Person<br>Person.prototype.constructor  // Person<br></code></pre>",
    "categoryId": "1768000001006",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797054,
    "title": "原型链的终点是什么？如何打印出原型链的终点？",
    "content": "<strong>回答：</strong><br><br>当访问一个对象的属性时，会先在对象本身查找，如果找不到，会沿着__proto__向上查找，直到找到或到达Object.prototype. proto ，原型链的终点是<code>null</code><br><br>由于<code>Object</code>是构造函数，原型链终点是<code>Object.prototype.__proto__</code>，而<code>Object.prototype.__proto__=== null // true</code>，所以，原型链的终点是<code>null</code>。原型链上的所有原型都是对象，所有的对象最终都是由<code>Object</code>构造的，而<code>Object.prototype</code>的下一级是<code>Object.prototype.__proto__</code>。<br><br>![img](https://secure2.wostatic.cn/static/aJ4ULg9mb8nqSdd5okS7F2/image.png?auth_key=1768103667-k9ETkEauK1fN41CykC5BwX-0-9b623954f138bbf2cad54a5ef318139e)",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797055,
    "title": "如何获得对象非原型链上的属性？",
    "content": "使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：<br><br><li>Object.keys() ：获取可枚举属性</li><br><li>Object.getOwnPropertyNames() ：获取所有属性（包括不可枚举）</li><br><li>hasOwnProperty() ：判断是否为自身属性</li><br><li>for...in + hasOwnProperty ：遍历自身属性</li><br><li>Object.getOwnPropertySymbols() ：获取Symbol属性</li><br><br><pre><code class=\"language-JavaScript\">function iterate(obj){<br>   var res=[];<br>   for(var key in obj){<br>        if(obj.hasOwnProperty(key))<br>           res.push(key+': '+obj[key]);<br>   }<br>   return res;<br>} <br></code></pre>",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797056,
    "title": "1. 对闭包的理解",
    "content": "<strong>回答：</strong><br><br>在函数环境中，内层函数访问了外层函数的变量就形成了闭包。<br><br><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。<br><br>闭包有两个常用的用途；<br><br><li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而<strong>在外部访问到函数内部的变量</strong>，可以使用这种方法来创建私有变量。</li><br><li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li><br><br>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。<br><br><pre><code class=\"language-JavaScript\">function A() {<br>  let a = 1<br>  window.B = function () {<br>      console.log(a)<br>  }<br>}<br>A()<br>B() // 1<br></code></pre><br><br>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题<br><br><pre><code class=\"language-JavaScript\">for (var i = 1; i <= 5; i++) {<br>  setTimeout(function timer() {<br>    console.log(i)<br>  }, i <em> 1000)<br>}<br></code></pre><br><br>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：<br><br><li>第一种是使用闭包的方式</li><br><br><pre><code class=\"language-JavaScript\">for (var i = 1; i <= 5; i++) {<br>  ;(function(j) {<br>    setTimeout(function timer() {<br>      console.log(j)<br>    }, j </em> 1000)<br>  })(i)<br>}<br></code></pre><br><br>在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。<br><br><li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</li><br><br><pre><code class=\"language-JavaScript\">for (var i = 1; i <= 5; i++) {<br>  setTimeout(<br>    function timer(j) {<br>      console.log(j)<br>    },<br>    i <em> 1000,<br>    i<br>  )<br>}<br></code></pre><br><br><li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li><br><br><pre><code class=\"language-JavaScript\">for (let i = 1; i <= 5; i++) {<br>  setTimeout(function timer() {<br>    console.log(i)<br>  }, i </em> 1000)<br>}<br></code></pre>",
    "categoryId": "1768000001006",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797057,
    "title": "2. 对作用域、作用域链的理解",
    "content": "<strong>回答：</strong><br><br>作用域是变量和函数的可访问范围，分为全局作用域、函数作用域和块级作用域。其中全局作用域任何地方都可访问，函数作用域仅在函数内部有效，块级作用域由let和const在代码块内创建；<br><br>作用域链是JavaScript查找变量的机制，当访问变量时从当前作用域开始逐级向外层作用域查找，直到找到该变量或到达全局作用域，遵循就近原则和单向查找规则；<br><br>##### 1）全局作用域和函数作用域<br><br>（1）全局作用域<br><br><li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li><br><li>所有未定义直接赋值的变量自动声明为全局作用域</li><br><li>所有window对象的属性拥有全局作用域</li><br><li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li><br><br>（2）函数作用域<br><br><li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li><br><li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li><br><br>##### 2）块级作用域<br><br><li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>{ }</code>包裹的代码片段）</li><br><li>let和const声明的变量不会有变量提升，也不可以重复声明</li><br><li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li><br><br><strong>作用域链：</strong><br><br>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。<br><br>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong><br><br>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。<br><br>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。",
    "categoryId": "1768000001006",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797058,
    "title": "对执行上下文的理解",
    "content": "<strong>回答：</strong><br><br>执行上下文是JavaScript代码执行时的环境，包含变量、函数、作用域链和this等信息，分为全局执行上下文、函数执行上下文和eval执行上下文三种类型，其中全局执行上下文在程序启动时创建且只有一个，函数执行上下文在函数调用时创建可以有多个；JavaScript引擎使用执行上下文栈（后进先出）管理执行上下文，全局执行上下文最先入栈，函数调用时新的执行上下文压入栈顶，执行完成后弹出；创建执行上下文分为创建阶段和执行阶段，创建阶段完成this绑定、词法环境创建和变量环境创建，执行阶段完成变量分配和代码执行；全局执行上下文包含变量定义和函数声明，函数执行上下文还包含this和arguments，理解执行上下文对掌握变量提升、作用域链、闭包和this指向等JavaScript核心概念至关重要。<br><br>##### 1. 执行上下文类型<br><br><strong>（1）全局执行上下文</strong><br><br>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。<br><br><strong>（2）函数执行上下文</strong><br><br>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。<br><br><strong>（3）</strong><code>eval</code><strong>函数执行上下文</strong><br><br>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。<br><br>##### 2. 执行上下文栈<br><br><li>JavaScript引擎使用执行上下文栈来管理执行上下文，执行上下文可以看作是代码执行的环境。</li><br><li>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li><br><br><pre><code class=\"language-JavaScript\">let a = 'Hello World!';<br>function first() {<br>  console.log('Inside first function');<br>  second();<br>  console.log('Again inside first function');<br>}<br>function second() {<br>  console.log('Inside second function');<br>}<br>first();<br>//执行顺序<br>//先执行second(),在执行first()<br></code></pre><br><br>##### 3. 创建执行上下文<br><br>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong><br><br><strong>1）创建阶段</strong><br><br>（1）this绑定<br><br><li>在全局执行上下文中，this指向全局对象（window对象）</li><br><li>在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li><br><br>（2）创建词法环境组件<br><br><li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。</li><br><li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li><br><br>（3）创建变量环境组件<br><br><li>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li><br><br><strong>2）执行阶段</strong><br><br>此阶段会完成对变量的分配，最后执行完代码。<br><br><strong>简单来说执行上下文就是指：</strong><br><br>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。<br><br>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。<br><br><li>全局上下文：变量定义，函数声明</li><br><li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li>",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797059,
    "title": "对this对象的理解",
    "content": "this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。<br><br><li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li><br><li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li><br><li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li><br><li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li><br><br>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797060,
    "title": "2. call() 和 apply() 的区别？",
    "content": "<strong>回答：</strong>call和apply的第一个参数都是this指向，区别在于apply的第二个参数是数组，call的参数逐个传递。<br><br>它们的作用一模一样，区别仅在于传入参数的形式的不同。<br><br><li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li><br><li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li>",
    "categoryId": "1768000001006",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797061,
    "title": "实现call、apply 及 bind 函数",
    "content": "<strong>（1）call 函数的实现步骤：</strong><br><br><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><br><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><br><li>处理传入的参数，截取第一个参数后的所有参数。</li><br><li>将函数作为上下文对象的一个属性。</li><br><li>使用上下文对象来调用这个方法，并保存返回结果。</li><br><li>删除刚才新增的属性。</li><br><li>返回结果。</li><br><br><pre><code class=\"language-JavaScript\">Function.prototype.myCall = function(context) {<br>  // 判断调用对象<br>  if (typeof this !== \"function\") {<br>    console.error(\"type error\");<br>  }<br>  // 获取参数<br>  let args = [...arguments].slice(1),<br>    result = null;<br>  // 判断 context 是否传入，如果未传入则设置为 window<br>  context = context || window;<br>  // 将调用函数设为对象的方法<br>  context.fn = this;<br>  // 调用函数<br>  result = context.fn(...args);<br>  // 将属性删除<br>  delete context.fn;<br>  return result;<br>};<br></code></pre><br><br><strong>（2）apply 函数的实现步骤：</strong><br><br><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><br><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><br><li>将函数作为上下文对象的一个属性。</li><br><li>判断参数值是否传入</li><br><li>使用上下文对象来调用这个方法，并保存返回结果。</li><br><li>删除刚才新增的属性</li><br><li>返回结果</li><br><br><pre><code class=\"language-JavaScript\">Function.prototype.myApply = function(context) {<br>  // 判断调用对象是否为函数<br>  if (typeof this !== \"function\") {<br>    throw new TypeError(\"Error\");<br>  }<br>  let result = null;<br>  // 判断 context 是否存在，如果未传入则为 window<br>  context = context || window;<br>  // 将函数设为对象的方法<br>  context.fn = this;<br>  // 调用方法<br>  if (arguments[1]) {<br>    result = context.fn(...arguments[1]);<br>  } else {<br>    result = context.fn();<br>  }<br>  // 将属性删除<br>  delete context.fn;<br>  return result;<br>};<br></code></pre><br><br><strong>（3）bind 函数的实现步骤：</strong><br><br><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><br><li>保存当前函数的引用，获取其余传入参数值。</li><br><li>创建一个函数返回</li><br><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li><br><br><pre><code class=\"language-JavaScript\">Function.prototype.myBind = function(context) {<br>  // 判断调用对象是否为函数<br>  if (typeof this !== \"function\") {<br>    throw new TypeError(\"Error\");<br>  }<br>  // 获取参数<br>  var args = [...arguments].slice(1),<br>    fn = this;<br>  return function Fn() {<br>    // 根据调用方式，传入不同绑定值<br>    return fn.apply(<br>      this instanceof Fn ? this : context,<br>      args.concat(...arguments)<br>    );<br>  };<br>};<br></code></pre>",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797062,
    "title": "1. 异步编程的实现方式？",
    "content": "<strong>回答：回调函数</strong> 的方式，<strong>Promise</strong>的方式，<strong>async</strong>函数的方式<br><br><strong>解析：</strong><br><br>JavaScript中的异步机制可以分为以下几种：<br><br><li><strong>回调函数</strong> 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li><br><li><strong>Promise</strong> 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li><br><li><strong>generator</strong> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li><br><li><strong>async 函数</strong> 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li>",
    "categoryId": "1768000001006",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797063,
    "title": "2. setTimeout、Promise、Async/Await 的区别",
    "content": "<strong>回答：</strong><br><br>setTimeout是定时器，放入宏任务队列；Promise是异步编程解决方案，放入微任务队列；Async/Await是Promise的语法糖，也是微任务。现代开发推荐使用Async/Await，它结合了Promise的优点，代码更简洁、可读性更强、调试更方便。<br><br><strong>解析：</strong><br><br><h4>（1）setTimeout</h4><br><br><pre><code class=\"language-JavaScript\">console.log('script start')  //1. 打印 script start<br>setTimeout(function(){<br>    console.log('settimeout')  // 4. 打印 settimeout<br>})  // 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数<br>console.log('script end')  //3. 打印 script start<br>// 输出顺序：script start->script end->settimeout<br></code></pre><br><br><h4>（2）Promise</h4><br><br>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。<br><br><pre><code class=\"language-JavaScript\">console.log('script start')<br>let promise1 = new Promise(function (resolve) {<br>    console.log('promise1')<br>    resolve()<br>    console.log('promise1 end')<br>}).then(function () {<br>    console.log('promise2')<br>})<br>setTimeout(function(){<br>    console.log('settimeout')<br>})<br>console.log('script end')<br>// 输出顺序: script start->promise1->promise1 end->script end->promise2->settimeout<br></code></pre><br><br>当JS主线程执行到Promise对象时：<br><br><li>promise1.then() 的回调就是一个 task</li><br><li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li><br><li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li><br><li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li><br><br><h4>（3）async/await</h4><br><br><pre><code class=\"language-JavaScript\">async function async1(){<br>   console.log('async1 start');<br>    await async2();<br>    console.log('async1 end')<br>}<br>async function async2(){<br>    console.log('async2')<br>}<br>console.log('script start');<br>async1();<br>console.log('script end')<br>// 输出顺序：script start->async1 start->async2->script end->async1 end<br></code></pre><br><br>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。<br><br>例如：<br><br><pre><code class=\"language-JavaScript\">async function func1() {<br>    return 1<br>}<br>console.log(func1())<br></code></pre><br><br>![img](https://secure2.wostatic.cn/static/hu8bbcamw1wJS5gfb6E2f7/image.png?auth_key=1768103671-iYvzxzyyCMfBhmDGx5FxFZ-0-bb66af8a3444cf79d162454dc807a29b)<br><br>func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。<br><br><pre><code class=\"language-JavaScript\">func1().then(res => {<br>    console.log(res);  // 30<br>})<br></code></pre><br><br>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。",
    "categoryId": "1768000001006",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797064,
    "title": "对Promise的理解",
    "content": "<strong>回答：</strong><br><br>Promise是JavaScript中用于异步编程的解决方案，它是一个代表异步操作最终结果的对象，具有三种状态（pending进行中、fulfilled已成功、rejected已失败），状态一旦改变就不可逆；Promise通过then、catch、finally等实例方法支持链式调用，解决了回调地狱问题，提供统一的错误处理机制，使异步代码更加清晰和可维护；Promise还提供了resolve、reject、all、race、allSettled、any等静态方法，支持快速创建Promise、并行执行多个异步操作、竞速处理等场景；Promise是async/await的基础，async/await本质上是Promise的语法糖，使异步代码可以用同步的方式编写，进一步提高了代码的可读性和可维护性；理解Promise对于掌握现代JavaScript异步编程至关重要。<br><br>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。<br><br>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。<br><br>（1）Promise的实例有<strong>三个状态</strong>:<br><br><li>Pending（进行中）</li><br><li>Resolved（已完成）</li><br><li>Rejected（已拒绝）</li><br><br>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。<br><br>（2）Promise的实例有<strong>两个过程</strong>：<br><br><li>pending -> fulfilled : Resolved（已完成）</li><br><li>pending -> rejected：Rejected（已拒绝）</li><br><br>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。<br><br><strong>Promise的特点：</strong><br><br><li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“<strong>承诺</strong>”；</li><br><li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>，从<code>pending</code>变为<code>rejected</code>。这时就称为<code>resolved</code>（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li><br><br><strong>Promise的缺点：</strong><br><br><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><br><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><br><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li><br><br><strong>总结：</strong><br><br>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。<br><br>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。<br><br><strong>注意：</strong> 在构造<code>Promise</code> 的时候，构造函数内部的代码是立即执行的",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797065,
    "title": "Promise的基本用法",
    "content": "<h4>（1）创建Promise对象</h4><br><br>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。<br><br>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。<br><br><pre><code class=\"language-JavaScript\">const promise = new Promise(function(resolve, reject) {<br>  // ... some code<br>  if (/<em> 异步操作成功 </em>/){<br>    resolve(value);<br>  } else {<br>    reject(error);<br>  }<br>});<br></code></pre><br><br><strong>一般情况下都会使用</strong><code>new Promise()</code><strong>来创建promise对象，但是也可以使用</strong><code>promise.resolve</code><strong>和</strong> <code>promise.reject</code><strong>这两个方法：</strong><br><br><li><strong>Promise.resolve</strong></li><br><br><code>Promise.resolve(value)</code>的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：<br><br><pre><code class=\"language-JavaScript\">Promise.resolve(11).then(function(value){<br>  console.log(value); // 打印出11<br>});<br></code></pre><br><br><code>resolve(11)</code>代码中，会让promise对象进入确定(<code>resolve</code>状态)，并将参数<code>11</code>传递给后面的<code>then</code>所指定的<code>onFulfilled</code> 函数；<br><br>创建promise对象可以使用<code>new Promise</code>的形式创建对象，也可以使用<code>Promise.resolve(value)</code>的形式创建promise对象；<br><br><li><strong>Promise.reject</strong></li><br><br><code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个promise对象。代码如下：<br><br><pre><code class=\"language-JavaScript\">Promise.reject(new Error(“我错了，请原谅俺！！”));<br></code></pre><br><br>就是下面的代码new Promise的简单形式：<br><br><pre><code class=\"language-JavaScript\">new Promise(function(resolve,reject){<br>   reject(new Error(\"我错了，请原谅俺！！\"));<br>});<br></code></pre><br><br>下面是使用resolve方法和reject方法：<br><br><pre><code class=\"language-JavaScript\">function testPromise(ready) {<br>  return new Promise(function(resolve,reject){<br>    if(ready) {<br>      resolve(\"hello world\");<br>    }else {<br>      reject(\"No thanks\");<br>    }<br>  });<br>};<br>// 方法调用<br>testPromise(true).then(function(msg){<br>  console.log(msg);<br>},function(error){<br>  console.log(error);<br>});<br></code></pre><br><br>上面的代码的含义是给<code>testPromise</code>方法传递一个参数，返回一个promise对象，如果为<code>true</code>的话，那么调用promise对象中的<code>resolve()</code>方法，并且把其中的参数传递给后面的<code>then</code>第一个函数内，因此打印出 “<code>hello world</code>”, 如果为<code>false</code>的话，会调用promise对象中的<code>reject()</code>方法，则会进入<code>then</code>的第二个函数内，会打印<code>No thanks</code>；<br><br><h4>（2）Promise方法</h4><br><br>Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。<br><br>1. <strong>then()</strong><br><br>当Promise执行的内容符合成功条件时，调用<code>resolve</code>函数，失败就调用<code>reject</code>函数。Promise创建完了，那该如何调用呢？<br><br><pre><code class=\"language-text\">promise.then(function(value) {<br>  // success<br>}, function(error) {<br>  // failure<br>});<br></code></pre><br><br><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。<br><br><code>then</code>方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个then方法。<br><br>当要写有顺序的异步事件时，需要串行时，可以这样写：<br><br><pre><code class=\"language-JavaScript\">let promise = new Promise((resolve,reject)=>{<br>    ajax('first').success(function(res){<br>        resolve(res);<br>    })<br>})<br>promise.then(res=>{<br>    return new Promise((resovle,reject)=>{<br>        ajax('second').success(function(res){<br>            resolve(res)<br>        })<br>    })<br>}).then(res=>{<br>    return new Promise((resovle,reject)=>{<br>        ajax('second').success(function(res){<br>            resolve(res)<br>        })<br>    })<br>}).then(res=>{<br>    <br>})<br></code></pre><br><br>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。<br><br><strong>2. catch()</strong><br><br>Promise对象除了有then方法，还有一个catch方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。<br><br><pre><code class=\"language-JavaScript\">p.then((data) => {<br>     console.log('resolved',data);<br>},(err) => {<br>     console.log('rejected',err);<br>     }<br>); <br>p.then((data) => {<br>    console.log('resolved',data);<br>}).catch((err) => {<br>    console.log('rejected',err);<br>});<br></code></pre><br><br><strong>3. all()</strong><br><br><code>all</code>方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个<code>promise</code>对象。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。<br><br><pre><code class=\"language-JavaScript\">javascript<br>let promise1 = new Promise((resolve,reject)=>{<br>  setTimeout(()=>{<br>       resolve(1);<br>  },2000)<br>});<br>let promise2 = new Promise((resolve,reject)=>{<br>  setTimeout(()=>{<br>       resolve(2);<br>  },1000)<br>});<br>let promise3 = new Promise((resolve,reject)=>{<br>  setTimeout(()=>{<br>       resolve(3);<br>  },3000)<br>});<br>Promise.all([promise1,promise2,promise3]).then(res=>{<br>    console.log(res);<br>    //结果为：[1,2,3] <br>})<br></code></pre><br><br>调用<code>all</code>方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象<code>resolve</code>执行时的值。<br><br><strong>（4）race()</strong><br><br><code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。<br><br><pre><code class=\"language-JavaScript\">let promise1 = new Promise((resolve,reject)=>{<br>  setTimeout(()=>{<br>       reject(1);<br>  },2000)<br>});<br>let promise2 = new Promise((resolve,reject)=>{<br>  setTimeout(()=>{<br>       resolve(2);<br>  },1000)<br>});<br>let promise3 = new Promise((resolve,reject)=>{<br>  setTimeout(()=>{<br>       resolve(3);<br>  },3000)<br>});<br>Promise.race([promise1,promise2,promise3]).then(res=>{<br>  console.log(res);<br>  //结果：2<br>},rej=>{<br>    console.log(rej)};<br>)<br></code></pre><br><br>那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：<br><br><pre><code class=\"language-JavaScript\">Promise.race([promise1,timeOutPromise(5000)]).then(res=>{})<br></code></pre><br><br><strong>5. finally()</strong><br><br><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。<br><br><pre><code class=\"language-JavaScript\">promise<br>.then(result => {···})<br>.catch(error => {···})<br>.finally(() => {···});<br></code></pre><br><br>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。<br><br>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。<br><br><pre><code class=\"language-JavaScript\">server.listen(port)<br>  .then(function () {<br>    // ...<br>  })<br>  .finally(server.stop);<br></code></pre><br><br><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<code>finally</code>本质上是<code>then</code>方法的特例：<br><br><pre><code class=\"language-JavaScript\">promise<br>.finally(() => {<br>  // 语句<br>});<br>// 等同于<br>promise<br>.then(<br>  result => {<br>    // 语句<br>    return result;<br>  },<br>  error => {<br>    // 语句<br>    throw error;<br>  }<br>);<br></code></pre><br><br>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797067,
    "title": "Promise解决了什么问题",
    "content": "在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：<br><br><pre><code class=\"language-JavaScript\">let fs = require('fs')<br>fs.readFile('./a.txt','utf8',function(err,data){<br>  fs.readFile(data,'utf8',function(err,data){<br>    fs.readFile(data,'utf8',function(err,data){<br>      console.log(data)<br>    })<br>  })<br>})<br></code></pre><br><br>上面的代码有如下缺点：<br><br><li>后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li><br><li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li><br><br><code>Promise</code>出现之后，代码变成这样：<br><br><pre><code class=\"language-JavaScript\">let fs = require('fs')<br>function read(url){<br>  return new Promise((resolve,reject)=>{<br>    fs.readFile(url,'utf8',function(error,data){<br>      error && reject(error)<br>      resolve(data)<br>    })<br>  })<br>}<br>read('./a.txt').then(data=>{<br>  return read(data) <br>}).then(data=>{<br>  return read(data)  <br>}).then(data=>{<br>  console.log(data)<br>})<br></code></pre><br><br>这样代码看起了就简洁了很多，解决了地狱回调的问题。",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797068,
    "title": "Promise.all和Promise.race的区别的使用场景",
    "content": "<strong>（1）</strong> <strong>Promise.all</strong><br><br><code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被reject失败状态的值</strong>。<br><br>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。<br><br>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。<br><br><strong>（2）Promise.race</strong><br><br>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：<br><br><pre><code class=\"language-JavaScript\">Promise.race([promise1,timeOutPromise(5000)]).then(res=>{})<br></code></pre>",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797069,
    "title": "对async/await 的理解",
    "content": "async/await其实是<code>Generator</code> 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：<br><br><pre><code class=\"language-JavaScript\">async function testAsy(){<br>   return 'hello world';<br>}<br>let result = testAsy(); <br>console.log(result)<br></code></pre><br><br>![img](https://secure2.wostatic.cn/static/hHydJSyNabCpYZWHGABWbr/image.png?auth_key=1768103676-6bKKGrZvvdMuGGi3eenbbn-0-9b33d8754d963fef344bbd86c97845cd)<br><br>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。<br><br>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：<br><br><pre><code class=\"language-JavaScript\">async function testAsy(){<br>   return 'hello world'<br>}<br>let result = testAsy() <br>console.log(result)<br>result.then(v=>{<br>    console.log(v)   // hello world<br>})<br></code></pre><br><br>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。<br><br>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。<br><br><strong>注意：</strong><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve => resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797070,
    "title": "await 到底在等啥？",
    "content": "<strong>await 在等待什么呢？</strong> 一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。<br><br>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：<br><br><pre><code class=\"language-JavaScript\">function getSomething() {<br>    return \"something\";<br>}<br>async function testAsync() {<br>    return Promise.resolve(\"hello async\");<br>}<br>async function test() {<br>    const v1 = await getSomething();<br>    const v2 = await testAsync();<br>    console.log(v1, v2);<br>}<br>test();<br></code></pre><br><br>await 表达式的运算结果取决于它等的是什么。<br><br><li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li><br><li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li><br><br>来看一个例子：<br><br><pre><code class=\"language-JavaScript\">function testAsy(x){<br>   return new Promise(resolve=>{setTimeout(() => {<br>       resolve(x);<br>     }, 3000)<br>    }<br>   )<br>}<br>async function testAwt(){    <br>  let result =  await testAsy('hello world');<br>  console.log(result);    // 3秒钟之后出现hello world<br>  console.log('cuger')   // 3秒钟之后出现cug<br>}<br>testAwt();<br>console.log('cug')  //立即输出cug<br></code></pre><br><br>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以'cug''最先输出，hello world'和‘cuger’是3秒钟后同时出现的。",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797071,
    "title": "async/await的优势",
    "content": "单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。<br><br>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 <code>setTimeout</code> 来模拟异步操作：<br><br><pre><code class=\"language-JavaScript\">/*<em><br> </em> 传入参数 n，表示这个函数执行的时间（毫秒）<br> <em> 执行的结果是 n + 200，这个值将用于下一步骤<br> </em>/<br>function takeLongTime(n) {<br>    return new Promise(resolve => {<br>        setTimeout(() => resolve(n + 200), n);<br>    });<br>}<br>function step1(n) {<br>    console.log(<code>step1 with ${n}</code>);<br>    return takeLongTime(n);<br>}<br>function step2(n) {<br>    console.log(<code>step2 with ${n}</code>);<br>    return takeLongTime(n);<br>}<br>function step3(n) {<br>    console.log(<code>step3 with ${n}</code>);<br>    return takeLongTime(n);<br>}<br></code></pre><br><br>现在用 Promise 方式来实现这三个步骤的处理：<br><br><pre><code class=\"language-JavaScript\">function doIt() {<br>    console.time(\"doIt\");<br>    const time1 = 300;<br>    step1(time1)<br>        .then(time2 => step2(time2))<br>        .then(time3 => step3(time3))<br>        .then(result => {<br>            console.log(<code>result is ${result}</code>);<br>            console.timeEnd(\"doIt\");<br>        });<br>}<br>doIt();<br>// c:\\var\\test>node --harmony_async_await .<br>// step1 with 300<br>// step2 with 500<br>// step3 with 700<br>// result is 900<br>// doIt: 1507.251ms<br></code></pre><br><br>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。<br><br>如果用 async/await 来实现呢，会是这样：<br><br><pre><code class=\"language-JavaScript\">async function doIt() {<br>    console.time(\"doIt\");<br>    const time1 = 300;<br>    const time2 = await step1(time1);<br>    const time3 = await step2(time2);<br>    const result = await step3(time3);<br>    console.log(<code>result is ${result}</code>);<br>    console.timeEnd(\"doIt\");<br>}<br>doIt();<br></code></pre><br><br>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797072,
    "title": "async/await对比Promise的优势",
    "content": "<li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担</li><br><li>Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅</li><br><li>错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余</li><br><li>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</li>",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797073,
    "title": "async/await 如何捕获异常",
    "content": "<pre><code class=\"language-JavaScript\">async function fn(){<br>    try{<br>        let a = await Promise.reject('error')<br>    }catch(error){<br>        console.log(error)<br>    }<br>}<br></code></pre>",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797074,
    "title": "对象创建的方式有哪些？",
    "content": "一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：<br><br>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。<br><br>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。<br><br>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。<br><br>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。<br><br>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。<br><br>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797075,
    "title": "对象继承的方式有哪些？",
    "content": "（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。<br><br>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。<br><br>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。<br><br>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。<br><br>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。<br><br>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797076,
    "title": "浏览器的垃圾回收机制",
    "content": "<h4><em>（1）垃圾回收的概念</h4><br><br><strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。<br><br><strong>回收机制</strong>：<br><br><li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li><br><li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li><br><li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li><br><br><h4>（2）垃圾回收的方式</h4><br><br>浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。<br><br><strong>1）标记清除</strong><br><br><li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li><br><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li><br><br><strong>2）引用计数</strong><br><br><li>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li><br><li>这种方法会引起<strong>循环引用</strong>的问题：例如：<code> obj1</code>和<code>obj2</code>通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，<code>obj1</code>和<code>obj2</code>还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li><br><br><pre><code class=\"language-JavaScript\">function fun() {<br>    let obj1 = {};<br>    let obj2 = {};<br>    obj1.a = obj2; // obj1 引用 obj2<br>    obj2.a = obj1; // obj2 引用 obj1<br>}<br></code></pre><br><br>这种情况下，就要手动释放变量占用的内存：<br><br><pre><code class=\"language-JavaScript\">obj1.a =  null<br> obj2.a =  null<br></code></pre><br><br><h4></em>（3）减少垃圾回收</h4><br><br>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。<br><br><li><strong>对数组进行优化：</strong> 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li><br><li><strong>对</strong><code>object</code><strong>进行优化：</strong> 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li><br><li><strong>对函数进行优化：</strong> 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li>",
    "categoryId": "1768000001006",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": 1768103797077,
    "title": "2. 哪些情况会导致内存泄漏",
    "content": "以下四种情况会造成内存的泄漏：<br><br><li><strong>意外的全局变量：</strong> 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><br><li><strong>被遗忘的计时器或回调函数：</strong> 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><br><li><strong>脱离 DOM 的引用：</strong> 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><br><li><strong>闭包：</strong> 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>",
    "categoryId": "1768000001006",
    "isFrequent": true,
    "createdAt": "2026-01-11T03:56:37.040Z",
    "updatedAt": "2026-01-11T03:56:37.040Z"
  },
  {
    "id": "1768103800551",
    "title": "功能依赖库",
    "content": "<h3>DraggableNext</h3>\n<p><a href=\"https://www.itxst.com/vue-draggable-next/tutorial.html\">https://www.itxst.com/vue-draggable-next/tutorial.html</a></p>\n<p><a href=\"https://github.com/SortableJS/vue.draggable.next\">https://github.com/SortableJS/vue.draggable.next</a></p>\n<h3><strong>ES Drager</strong></h3>\n<p><a href=\"https://vangleer.github.io/es-drager/#/basic\">https://vangleer.github.io/es-drager/#/basic</a></p>\n<p><a href=\"https://vangleer.github.io/es-drager/#/basic\">https://vangleer.github.io/es-drager/#/basic</a></p>\n<h3><strong>html2canvas</strong></h3>\n<p><a href=\"https://www.npmjs.com/package/html2canvas\">https://www.npmjs.com/package/html2canvas</a></p>\n<h3><strong>Vuetify</strong></h3>\n<p><a href=\"https://vuetifyjs.com/zh-Hans/components/images/\">https://vuetifyjs.com/zh-Hans/components/images/</a></p>\n<h3>Masonry</h3>\n<p><a href=\"https://masonry.desandro.com/\">https://masonry.desandro.com/</a></p>",
    "categoryId": "1768000001015",
    "isFrequent": false,
    "createdAt": "2026-01-11T03:56:40.551Z",
    "updatedAt": "2026-01-11T03:56:40.551Z"
  },
  {
    "id": 1768104014835,
    "title": "1. Vue的基本原理",
    "content": "<strong>回答：</strong><br><br>Vue实例创建时遍历 data 属性   Vue 2：使用 Object.defineProperty 将它们转为getter/setter，Vue 3：使用 Proxy 实现更全面的响应式，在组件渲染时，访问data属性会记录当前组件的watcher实例为依赖，数据变化时，setter通知关联的watcher，触发组件重新渲染。<br><br><strong>解析：</strong><br><br>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。<br><br>![img](https://secure2.wostatic.cn/static/xhfDFF6pdFwyL3hGWA5NaW/image.png?auth_key=1768103830-rJJ4h7UXp3v3R36SPzQXRG-0-973cf2d1af4eaca28733def3df46c672)",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014836,
    "title": "2. 双向数据绑定的原理",
    "content": "<strong>回答：</strong><br><br>Vue双向数据绑定的核心是 数据劫持+发布-订阅模式。<br><br>Vue在初始化时，通过<code>Object.defineProperty()</code>方法将数据对象中的属性转换为getter和setter。当数据对象中的属性被访问时，会触发getter函数。Vue会将该属性关联的Watcher对象添加到依赖列表中。当数据对象中的属性被修改时，会触发setter函数。Vue会通知依赖列表中的Watcher对象进行更新。Watcher对象收到更新通知后，会触发更新函数。更新函数会重新计算虚拟DOM并与实际DOM进行对比，找到差异并进行更新。通过这种方式，Vue实现了数据和视图之间的双向绑定，当数据发生变化时，视图会自动更新；反之，当用户与视图进行交互时，数据也会相应地进行更新。<br><br><strong>解析：</strong><br><br>Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：<br><br>1. 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化<br>2. compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图<br>3. Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。<br>4. MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。<br><br>![img](https://secure2.wostatic.cn/static/i4qtrErQcecCsqrJp1i45x/image.png?auth_key=1768103830-fbVQCfvY7txmjfZiyXVpca-0-5867ae55f8e65acc241a1289e2840dc7)",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014837,
    "title": "3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？",
    "content": "<strong>回答：</strong><br><br>有一些对属性的操作，使用这种方法无法拦截，比如说<strong>通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题</strong>。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。<strong>使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，</strong>因为这是 ES6 的语法。<br><br><strong>解析：</strong><br><br>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。<br><br>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014838,
    "title": "4. MVVM、MVC、MVP的区别",
    "content": "<strong>回答：</strong><br><br>三者都是软件架构模式，核心是分离数据（Model）和视图（View），但差异在于中间层的职责和数据流向不同。<br><br>MVC（Model-View-Controller） “首先看中间层职责：MVC的中间层是控制器（Controller） ，主要负责接收用户在视图上的操作请求，然后调用模型处理数据，处理完再告诉视图更新数据。<br><br>MVP（Model-View-Presenter） “MVP的中间层是<strong> presenter（Presenter） ，是视图和模型之间的 唯一桥梁</strong>，所有交互都必须经过它。<br><br>MVVM<br><br>“MVVM的中间层是视图模型（ViewModel） ，它最核心的特点就是自带双向数据绑定能力，具体来说，数据流向是双向自动同步的：当用户在视图上操作（比如在输入框里打字），这个变化会 自动同步 到ViewModel里的数据；反过来，如果数据变了视图也会自动更新 ，完全不需要开发者手动去操作DOM。<br><br><strong>解析：</strong><br><br>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。<br><br>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。<br><br><strong>（1）MVC</strong><br><br>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。<br><br>![img](https://secure2.wostatic.cn/static/iuRg6718W8z6wqzqNgTj6z/2.png?auth_key=1768103830-kncf6ZjsJt6zcMHZKCG5hX-0-fc8ac00465cff781f4b7215829f8c704)<br><br>（2）MVVM<br><br>MVVM 分为 Model、View、ViewModel：<br><br><li>Model代表数据模型，数据和业务逻辑都在Model层中定义；</li><br><li>View代表UI视图，负责数据的展示；</li><br><li>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</li><br><br>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。<br><br>这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。<br><br>![img](https://secure2.wostatic.cn/static/braJGpMfhHPUsxua6uymQn/2.png?auth_key=1768103830-xAEE1ma7Utya72FwF2Xg2u-0-dc2f1b7a2133c27468cba339206caaec)<br><br><strong>（3）MVP</strong><br><br>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014839,
    "title": "5. Computed 和 Watch 的区别",
    "content": "<strong>回答：</strong><br><br>Computed和Watch都是Vue中用于响应式数据处理的API，但定位不同：<br><br>Computed是 计算属性 ，它基于依赖数据计算出一个结果，并且有缓存——只有依赖变了才会重新计算，适合像拼接名字、过滤列表这样的场景，能提升性能。<br><br>Watch是 监听器 ，它没有缓存，当监听的数据变化时会立即执行回调，可以处理异步操作，比如监听搜索框变化发起API请求，或者记录数据变化日志<br><br><strong>解析：</strong><br><br><strong>对于Computed：</strong><br><br><li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li><br><li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li><br><li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li><br><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li><br><li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li><br><br><strong>对于Watch：</strong><br><br><li>它不支持缓存，数据变化时，它就会触发相应的操作</li><br><li>支持异步监听</li><br><li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li><br><li>当一个属性发生变化时，就需要执行相应的操作</li><br><li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：</li><br><br>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。<br><br><strong>总结：</strong><br><br><li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</li><br><li>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li><br><br><strong>运用场景：</strong><br><br><li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。</li><br><li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014840,
    "title": "6. Computed 和 Methods 的区别",
    "content": "<strong>回答：</strong><br><br>Computed ：有缓存，依赖数据不变时，多次访问直接返回缓存结果，只在依赖变化时重新计算。<br><br>Methods ：无缓存，每次调用都会重新执行函数逻辑。<br><br><strong>解析：</strong><br><br>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的<br><br><strong>不同点：</strong><br><br><li>computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</li><br><li>method 调用总会执行该函数。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014841,
    "title": "7. slot是什么？有什么作用？原理是什么？",
    "content": "<strong>回答：</strong><br><br>Slot 是 Vue 的 内容分发机制 ，允许父组件向子组件传递自定义内容，使子组件结构更灵活。<br><br>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。<br><br><strong>解析：</strong><br><br>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。<br><br><li>默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li><br><li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li><br><li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li><br><br>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014842,
    "title": "过滤器的作用，如何实现一个过滤器",
    "content": "<strong>回答：</strong><br><br>过滤器是 Vue 中 用于格式化数据显示 的工具函数， 不修改原数据 ，仅改变渲染时的输出结果。<br><br><strong>解析：</strong><br><br>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用<code>filters</code>来过滤数据，<code>filters</code>不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 <code>computed</code> ，方法 <code>methods</code> 都是通过修改数据来处理数据格式的输出显示）。<br><br><strong>使用场景：</strong><br><br><li>需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。</li><br><li>比如后端返回一个 <strong>年月日的日期字符串</strong>，前端需要展示为 <strong>多少天前</strong> 的数据格式，此时就可以用<code>fliters</code>过滤器来处理数据。</li><br><br>过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在<strong>插值表达式</strong> <code><strong>{{ }}</strong></code> 和 <code><strong>v-bind</strong></code> <strong>表达式</strong> 中，然后放在操作符“ <code><strong>|</strong></code> ”后面进行指示。<br><br>例如，在显示金额，给商品价格添加单位：<br><br><pre><code class=\"language-JavaScript\"><li>商品价格：{{item.price | filterPrice}}</li><br><br> filters: {<br>    filterPrice (price) {<br>      return price ? ('￥' + price) : '--'<br>    }<br>  }<br></code></pre>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014843,
    "title": "9. 如何保存页面的当前的状态",
    "content": "<strong>回答：</strong>优先使用 Vue 提供的 keep-alive ；需持久化或跨页传值时，根据数据类型选择 Storage 或路由传值。<br><br><strong>解析：</strong><br><br>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：<br><br><li>前组件会被卸载</li><br><li>前组件不会被卸载</li><br><br>那么可以按照这两种情况分别得到以下方法：<br><br><strong>组件会被卸载：</strong><br><br><strong>（1）将状态存储在LocalStorage / SessionStorage</strong><br><br>只需要在组件即将被销毁的生命周期中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。<br><br>比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。<br><br>##### 优点<br><br><li>兼容性好，不需要额外库或工具。</li><br><li>简单快捷，基本可以满足大部分需求。</li><br><br>##### 缺点<br><br><li>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li><br><li>如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li><br><br><strong>（2）路由传值</strong><br><br>通过 vue-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。<br><br>在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。<br><br>##### 优点<br><br><li>简单快捷，不会污染 LocalStorage / SessionStorage。</li><br><li>可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）</li><br><br>##### 缺点<br><br><li>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li><br><br><strong>组件不会被卸载：</strong><br><br><strong>（1）单页面渲染</strong><br><br>要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。<br><br>##### 优点<br><br><li>代码量少</li><br><li>不需要考虑状态传递过程中的错误</li><br><br>##### 缺点<br><br><li>增加 A 组件维护成本</li><br><li>需要传入额外的 prop 到 B 组件</li><br><li>无法利用路由定位页面</li><br><br>除此之外，在Vue中，还可以是用<strong><code>keep-alive</code></strong>来缓存页面，当组件在keep-alive内被切换时组件的<strong>activated、deactivated</strong>这两个生命周期钩子函数会被执行<br><br>被包裹在keep-alive中的组件的状态将会被保留：<br><br><pre><code class=\"language-JavaScript\"><keep-alive><br>  <router-view v-if=\"$route.meta.keepAlive\"></router-view><br></kepp-alive><br></code></pre><br><br><strong>router.js</strong><br><br><pre><code class=\"language-JavaScript\">{<br>      path: '/',<br>      name: 'xxx',<br>      component: ()=>import('../src/views/xxx.vue'),<br>      meta:{<br>        keepAlive: true // 需要被缓存<br>      }<br>},<br></code></pre>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014844,
    "title": "10. 常见的事件修饰符及其作用",
    "content": "<li><code>.stop</code>：等同于 JavaScript 中的 <code>event.stopPropagation()</code> ，防止事件冒泡；</li><br><li><code>.prevent</code> ：等同于 JavaScript 中的 <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li><br><li><code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</li><br><li><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li><br><li><code>.once</code> ：只会触发一次。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014845,
    "title": "11. v-if、v-show、v-html 的原理",
    "content": "<li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li><br><li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；</li><br><li>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014846,
    "title": "13. v-if和v-show的区别",
    "content": "<li><strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li><br><li><strong>编译过程</strong>：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li><br><li><strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li><br><li><strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li><br><li><strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014847,
    "title": "v-model 是如何实现的，语法糖实际是什么？",
    "content": "<strong>回答：</strong><br><br>\"v-model 本质是 v-bind + v-on 的语法糖，通过双向绑定实现数据与视图同步\"<br><br><strong>解析：</strong><br><br><strong>（1）作用在表单元素上</strong><br><br>动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：<br><br><pre><code class=\"language-JavaScript\"><input v-model=\"sth\" /><br>//  等同于<br><input <br>    v-bind:value=\"message\" <br>    v-on:input=\"message=$event.target.value\"<br>><br>//$event 指代当前触发的事件对象;<br>//$event.target 指代当前触发的事件对象的dom;<br>//$event.target.value 就是当前dom的value值;<br>//在@input方法中，value => sth;<br>//在:value中,sth => value;<br></code></pre><br><br><strong>（2）作用在组件上</strong><br><br>在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件<br><br><strong>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。</strong> 因此父组件 v-model 语法糖本质上可以修改为：<br><br><pre><code class=\"language-JavaScript\"><child :value=\"message\"  @input=\"function(e){message = e}\"></child><br></code></pre><br><br>在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。<br><br>例子：<br><br><pre><code class=\"language-JavaScript\">// 父组件<br><aa-input v-model=\"aa\"></aa-input><br>// 等价于<br><aa-input v-bind:value=\"aa\" v-on:input=\"aa=$event.target.value\"></aa-input><br><br>// 子组件：<br><input v-bind:value=\"aa\" v-on:input=\"onmessage\"></aa-input><br><br>props:{value:aa,}<br>methods:{<br>    onmessage(e){<br>        $emit('input',e.target.value)<br>    }<br>}<br></code></pre><br><br>默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据emit 出去，在父组件接收。父组件设置v-model的值为input事件在子组件中通过 emit传递过来的值。",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014848,
    "title": "v-model 可以被用在自定义组件上吗？如果可以，如何使用？",
    "content": "可以。v-model 实际上是一个语法糖，如：<br><br><pre><code class=\"language-JavaScript\"><input v-model=\"searchText\"><br></code></pre><br><br>实际上相当于：<br><br><pre><code class=\"language-JavaScript\"><input<br>  v-bind:value=\"searchText\"<br>  v-on:input=\"searchText = $event.target.value\"<br>><br></code></pre><br><br>用在自定义组件上也是同理：<br><br><pre><code class=\"language-JavaScript\"><custom-input v-model=\"searchText\"><br></code></pre><br><br>相当于：<br><br><pre><code class=\"language-JavaScript\"><custom-input<br>  v-bind:value=\"searchText\"<br>  v-on:input=\"searchText = $event\"<br>></custom-input><br></code></pre><br><br>显然，custom-input 与父组件的交互如下：<br><br>1. 父组件将<code>searchText</code>变量传入custom-input 组件，使用的 prop 名为<code>value</code>；<br>2. custom-input 组件向父组件传出名为<code>input</code>的事件，父组件将接收到的值赋值给<code>searchText</code>；<br><br>所以，custom-input 组件的实现应该类似于这样：<br><br><pre><code class=\"language-JavaScript\">Vue.component('custom-input', {<br>  props: ['value'],<br>  template: <code><br>    <input<br>      v-bind:value=\"value\"<br>      v-on:input=\"$emit('input', $event.target.value)\"<br>    ><br>  </code><br>})<br></code></pre>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014849,
    "title": "16. data为什么是一个函数而不是对象",
    "content": "回答：<br><br>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。<br><br>而在Vue中，我们更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。<br><br>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当我们每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014850,
    "title": "17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？",
    "content": "<strong>回答：</strong><br><br>keep-alive 是 Vue 的内置抽象组件，核心作用是缓存组件实例以避免频繁创建/销毁带来的性能损耗；它通过内部维护的 cache 对象和 keys 集合实现缓存系统，拦截组件生命周期（离开视图时不执行 destroyed 而是移至缓存，重新进入时不执行 created/mounted 而是从缓存恢复），并扩展了 activated 和 deactivated 钩子；具体缓存的是完整的组件实例对象，包括组件状态、渲染的 DOM 节点和响应式数据等，同时支持通过 include/exclude/max 等属性控制缓存范围和数量。<br><br><strong>解析：</strong><br><br>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。<br><br><strong>（1）</strong> <strong>keep-alive</strong><br><br>keep-alive有以下三个属性：<br><br><li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li><br><li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li><br><li>max 数字，最多可以缓存多少组件实例。</li><br><br>注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。<br><br><strong>主要流程</strong><br><br>1. 判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。<br>2. 获取组件实例 key ，如果有获取实例的 key，否则重新生成。<br>3. key生成规则，cid +\"∶∶\"+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。<br>4. 如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。<br><br><strong>（2）keep-alive 的实现</strong><br><br><pre><code class=\"language-JavaScript\">const patternTypes: Array<Function> = [String, RegExp, Array] // 接收：字符串，正则，数组<br><br>export default {<br>  name: 'keep-alive',<br>  abstract: true, // 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br><br>  props: {<br>    include: patternTypes, // 匹配的组件，缓存<br>    exclude: patternTypes, // 不去匹配的组件，不缓存<br>    max: [String, Number], // 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限<br>  },<br><br>  created() {<br>    // 用于初始化缓存虚拟DOM数组和vnode的key<br>    this.cache = Object.create(null)<br>    this.keys = []<br>  },<br><br>  destroyed() {<br>    // 销毁缓存cache的组件实例<br>    for (const key in this.cache) {<br>      pruneCacheEntry(this.cache, key, this.keys)<br>    }<br>  },<br><br>  mounted() {<br>    // prune 削减精简[v.]<br>    // 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容<br>    this.$watch('include', (val) => {<br>      pruneCache(this, (name) => matches(val, name))<br>    })<br>    this.$watch('exclude', (val) => {<br>      pruneCache(this, (name) => !matches(val, name))<br>    })<br>  },<br>}<br></code></pre><br><br><strong>render函数：</strong><br><br>1. 会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件<br>2. keep-alive 只对第一个组件有效，所以获取第一个子组件。<br>3. 和 keep-alive 搭配使用的一般有：动态组件 和router-view<br><br><pre><code class=\"language-JavaScript\">render () {<br>  //<br>  function getFirstComponentChild (children: ?Array<VNode>): ?VNode {<br>    if (Array.isArray(children)) {<br>  for (let i = 0; i < children.length; i++) {<br>    const c = children[i]<br>    if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {<br>      return c<br>    }<br>  }<br>  }<br>  }<br>  const slot = this.$slots.default // 获取默认插槽<br>  const vnode: VNode = getFirstComponentChild(slot)// 获取第一个子组件<br>  const componentOptions: ?VNodeComponentOptions = vnode && vnode.componentOptions // 组件参数<br>  if (componentOptions) { // 是否有组件参数<br>    // check pattern<br>    const name: ?string = getComponentName(componentOptions) // 获取组件名<br>    const { include, exclude } = this<br>    if (<br>      // not included<br>      (include && (!name || !matches(include, name))) ||<br>      // excluded<br>      (exclude && name && matches(exclude, name))<br>    ) {<br>      // 如果不匹配当前组件的名字和include以及exclude<br>      // 那么直接返回组件的实例<br>      return vnode<br>    }<br><br>    const { cache, keys } = this<br><br>    // 获取这个组件的key<br>    const key: ?string = vnode.key == null<br>      // same constructor may get registered as different local components<br>      // so cid alone is not enough (#3269)<br>      ? componentOptions.Ctor.cid + (componentOptions.tag ? <code>::${componentOptions.tag}</code> : '')<br>      : vnode.key<br><br>    if (cache[key]) {<br>      // LRU缓存策略执行<br>      vnode.componentInstance = cache[key].componentInstance // 组件初次渲染的时候componentInstance为undefined<br><br>      // make current key freshest<br>      remove(keys, key)<br>      keys.push(key)<br>      // 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面<br>    } else {<br>      // 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除<br>      // 使用时间间隔最长的一个<br>      cache[key] = vnode<br>      keys.push(key)<br>      // prune oldest entry<br>      if (this.max && keys.length > parseInt(this.max)) {<br>        pruneCacheEntry(cache, keys[0], keys, this._vnode)<br>      }<br>    }<br>    // 将组件的keepAlive属性设置为true<br>    vnode.data.keepAlive = true // 作用：判断是否要执行组件的created、mounted生命周期函数<br>  }<br>  return vnode || (slot && slot[0])<br>}<br></code></pre><br><br>keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。<br><br><strong>实现步骤：</strong><br><br>1. 获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名<br>2. 通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode<br>3. 需要缓存，判断他当前是否在缓存数组里面：<br><br><li>存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</li><br><li>不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</li><br><br>1. 最后将这个组件的 keepAlive 设置为 true<br><br><strong>（3）keep-alive 本身的创建过程和 patch 过程</strong><br><br>缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。<br><br><strong>首次渲染</strong><br><br><li>组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</li><br><br><pre><code class=\"language-JavaScript\">// core/instance/lifecycle<br>function initLifecycle (vm: Component) {<br>  const options = vm.$options<br><br>  // locate first non-abstract parent<br>  let parent = options.parent<br>  if (parent && !options.abstract) { // 判断组件的abstract属性，才往父组件里面挂载DOM<br>    while (parent.$options.abstract && parent.$parent) {<br>      parent = parent.$parent<br>    }<br>    parent.$children.push(vm)<br>  }<br><br>  vm.$parent = parent<br>  vm.$root = parent ? parent.$root : vm<br><br>  vm.$children = []<br>  vm.$refs = {}<br><br>  vm._watcher = null<br>  vm._inactive = null<br>  vm._directInactive = false<br>  vm._isMounted = false<br>  vm._isDestroyed = false<br>  vm._isBeingDestroyed = false<br>}<br></code></pre><br><br><li>判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</li><br><br><pre><code class=\"language-JavaScript\">// core/vdom/create-component<br>init (vnode: VNodeWithData, hydrating: boolean): ?boolean {<br>    if (<br>      vnode.componentInstance &&<br>      !vnode.componentInstance._isDestroyed &&<br>      vnode.data.keepAlive<br>    ) { // componentInstance在初次是undefined!!!<br>      // kept-alive components, treat as a patch<br>      const mountedNode: any = vnode // work around flow<br>      componentVNodeHooks.prepatch(mountedNode, mountedNode) // prepatch函数执行的是组件更新的过程<br>    } else {<br>      const child = vnode.componentInstance = createComponentInstanceForVnode(<br>        vnode,<br>        activeInstance<br>      )<br>      child.$mount(hydrating ? vnode.elm : undefined, hydrating)<br>    }<br>  },<br></code></pre><br><br>prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入<br><br><strong>（4）LRU （least recently used）缓存策略</strong><br><br>LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。<br><br>LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 <strong>\"如果数据最近被访问过，那么将来被访问的几率也更高\"</strong>。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶<br><br><li>新数据插入到链表头部</li><br><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li><br><li>链表满的时候，将链表尾部的数据丢弃。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014851,
    "title": "$nextTick 原理及作用",
    "content": "<strong>回答：</strong><br><br>nextTick是Vue提供的异步API，核心作用是确保回调函数在DOM更新完成后执行，避免因Vue异步批量更新机制导致获取到旧DOM状态的问题；其原理基于浏览器事件循环，Vue将响应式数据变化触发的DOM更新操作放入异步队列，优先通过微任务执行，nextTick是Vue提供的异步API，核心作用是确保回调函数在DOM更新完成后执行，避免因Vue异步批量更新机制导致获取到旧DOM状态的问题；其原理基于浏览器事件循环，Vue将响应式数据变化触发的DOM更新操作放入异步队列，优先通过微任务执行，nextTick是Vue提供的异步API，核心作用是确保回调函数在DOM更新完成后执行，避免因Vue异步批量更新机制导致获取到旧DOM状态的问题；其原理基于浏览器事件循环，Vue将响应式数据变化触发的DOM更新操作放入异步队列，优先通过微任务执行，nextTick的回调会被追加到该队列末尾，从而保证在当前一轮数据更新导致的DOM操作全部完成后执行，常用于数据修改后需要操作新DOM结构或获取更新后DOM尺寸等场景<br><br><strong>解析：</strong><br><br>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。<br><br>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。<br><br>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理<br><br>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶<br><br><li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染</li><br><li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li><br><br>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。<br><br>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在<code>$nextTick</code>中。<br><br><pre><code class=\"language-JavaScript\">this.$nextTick(() => {<br>    // 获取数据的操作...<br>})<br></code></pre><br><br>所以，在以下情况下，会用到nextTick：<br><br><li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在<code>nextTick()</code>的回调函数中。</li><br><li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。</li><br><br>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在<code>nextTick()</code>的回调函数中。",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014852,
    "title": "*19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？**",
    "content": "<strong>回答：</strong><br><br>Vue 中，若直接给 data 中的对象添加新属性（如 this.user.age = 18 ），该属性不会成为响应式 ，修改时无法触发视图更新；这是因为 Vue 在初始化阶段会通过 Object.defineProperty 为已声明的属性添加 getter/setter 以实现响应式，而新添加的属性未经过此处理。解决方法有两种：一是使用 Vue.set方法手动为新属性添加响应式能力；二是直接重新赋值整个对象（如 this.user = { ...this.user, age: 18 } ），让 Vue 重新处理新对象的所有属性，使其成为响应式。<br><br><strong>解析：</strong><br><br><pre><code class=\"language-JavaScript\"><template> <br>   <div><br>      <ul><br>         <li v-for=\"value in obj\" :key=\"value\"> {{value}} </li> <br>      </ul> <br>      <button @click=\"addObjB\">添加 obj.b</button> <br>   </div><br></template><br><br><script><br>    export default { <br>       data () { <br>          return { <br>              obj: { <br>                  a: 'obj.a' <br>              } <br>          } <br>       },<br>       methods: { <br>          addObjB () { <br>              this.obj.b = 'obj.b' <br>              console.log(this.obj) <br>          } <br>      }<br>   }<br></script><br></code></pre><br><br>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api <strong>$set()：</strong><br><br><pre><code class=\"language-JavaScript\">addObjB () (<br>   this.$set(this.obj, 'b', 'obj.b')<br>   console.log(this.obj)<br>}<br></code></pre><br><br>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014853,
    "title": "20. Vue中封装的数组方法有哪些，其如何实现页面更新",
    "content": "<strong>回答：</strong><br><br>Vue 因 Object.defineProperty 无法直接监听数组变化，通过 重写 7 个可变数组方法 （push/pop/shift/unshift/splice/sort/reverse）实现响应式：基于原生数组原型创建新原型，在重写的方法中先执行原生逻辑，对 push/unshift/splice 新增的元素进行响应式处理，最后通知依赖更新，从而触发视图实时刷新。<br><br><strong>解析：</strong><br><br>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。<br><br><pre><code class=\"language-JavaScript\">// 以下方法对数组的修改都会触发视图更新<br>push()<br>pop()<br>shift()<br>unshift()<br>splice()<br>sort()<br>reverse()<br></code></pre><br><br>那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：<br><br><pre><code class=\"language-JavaScript\">// 缓存数组原型<br>const arrayProto = Array.prototype;<br>// 实现 arrayMethods.__proto__ === Array.prototype<br>export const arrayMethods = Object.create(arrayProto);<br>// 需要进行功能拓展的方法<br>const methodsToPatch = [<br>  \"push\",<br>  \"pop\",<br>  \"shift\",<br>  \"unshift\",<br>  \"splice\",<br>  \"sort\",<br>  \"reverse\"<br>];<br><br>/*<em><br> </em> Intercept mutating methods and emit events<br> */<br>methodsToPatch.forEach(function(method) {<br>  // 缓存原生数组方法<br>  const original = arrayProto[method];<br>  def(arrayMethods, method, function mutator(...args) {<br>    // 执行并缓存原生数组功能<br>    const result = original.apply(this, args);<br>    // 响应式处理<br>    const ob = this.__ob__;<br>    let inserted;<br>    switch (method) {<br>    // push、unshift会新增索引，所以要手动observer<br>      case \"push\":<br>      case \"unshift\":<br>        inserted = args;<br>        break;<br>      // splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。<br>      case \"splice\":<br>        inserted = args.slice(2);<br>        break;<br>    }<br>    // <br>    if (inserted) ob.observeArray(inserted);// 获取插入的值，并设置响应式监听<br>    // notify change<br>    ob.dep.notify();// 通知依赖更新<br>    // 返回原生数组方法的执行结果<br>    return result;<br>  });<br>});<br></code></pre><br><br>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014854,
    "title": "21. Vue 单页应用与多页应用的区别",
    "content": "<strong>回答：</strong><br><br>Vue单页应用（SPA）与多页应用（MPA）的核心区别：<br><br>1. 页面结构 ：SPA仅有1个主HTML文件，MPA包含多个独立HTML文件；<br>2. 加载机制 ：SPA首次加载慢但后续切换快（仅更新数据），MPA首次加载快但页面跳转需重新加载资源；<br>3. 路由实现 ：SPA用前端路由（如Vue Router），MPA依赖后端路由；<br>4. SEO ：SPA需通过SSR等优化，MPA天然友好；<br>5. 适用场景 ：SPA适合交互密集型应用（如管理系统），MPA适合内容展示类网站（如企业官网）。<br><br><strong>解析：</strong><br><br><strong>概念：</strong><br><br><li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li><br><li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li><br><br><strong>区别：</strong><br><br>![img](https://secure2.wostatic.cn/static/7L77dgx3bTEYZdNosCpFsC/image.png?auth_key=1768103892-oAA38WC9Js4cL9nRdfH9yv-0-390a22725cffe722c2b8afddb2469db0)",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014855,
    "title": "22. Vue template 到 render 的过程",
    "content": "<strong>回答：</strong><br><br>Vue 模板（template）到渲染函数（render）的过程分为三个核心阶段：首先， 解析器将模板字符串逐字符解析，生成包含标签结构、属性、指令（如 v-if/v-for）等信息转化成抽象语法树（AST）；接着， 转换器 对 AST 进行优化，处理指令逻辑（如将 v-model 转换为 value 绑定与 input 事件）、标记静态节点（避免重复更新）、解析组件引用等；最后， 代码生成器 将优化后的 AST 转换为字符串形式的渲染函数，该函数执行时会返回描述 DOM 结构的虚拟 DOM（VNode），供 Vue 后续用于页面渲染与更新。<br><br><strong>解析：</strong><br><br>vue的模版编译过程主要如下：<strong>template -> ast -> render函数</strong><br><br>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：<br><br><pre><code class=\"language-JavaScript\">// 将模板编译为render函数<br>const { render, staticRenderFns } = compileToFunctions(template,options//省略}, this)<br></code></pre><br><br>CompileToFunctions中的主要逻辑如下∶<br><br><strong>（1）调用parse方法将template转化为ast（抽象语法树）</strong><br><br><pre><code class=\"language-JavaScript\">constast = parse(template.trim(), options)<br></code></pre><br><br><li><strong>parse的目标</strong>：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</li><br><li><strong>解析过程</strong>：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</li><br><br>AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本<br><br><strong>（2）对静态节点做优化</strong><br><br><pre><code class=\"language-JavaScript\">optimize(ast,options)<br></code></pre><br><br>这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化<br><br>深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。<br><br><strong>（3）生成代码</strong><br><br><pre><code class=\"language-JavaScript\">const code = generate(ast, options)<br></code></pre><br><br>generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 <code>new Function(render)</code> 生成render函数。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014856,
    "title": "23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？",
    "content": "<strong>回答：</strong><br><br>Vue 中 data 属性值改变后，视图 不会立即同步重新渲染 。<br><br>这是因为 Vue 采用了 异步批量更新机制：当数据变化时，Vue 会将 DOM 更新操作放入异步队列，在下一个事件循环的微任务阶段统一执行。若需在 DOM 更新完成后执行操作（如获取更新后的 DOM 尺寸），可使用 this.$nextTick() 方法确保回调在 DOM 更新后执行。<br><br><strong>解析：</strong><br><br>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。<br><br>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014857,
    "title": "简述 mixin、extends 的覆盖逻辑",
    "content": "<strong>（1）mixin 和 extends</strong><br><br>mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。<br><br><li>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li><br><li>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li><br><li>|                        |                                                              |                         |</li><br>| ---------------------- | ------------------------------------------------------------ | ----------------------- |<br>| 属性名称               | 合并策略                                                     | 对应合并函数            |<br>| data                   | mixins/extends只会将自己有的但是组件上没有内容混合到组件上，重复定义默认使用组件上的； 如果data里的值是对象，将递归内部对象继续按照该策略合并 | mergeDataOrFn mergeData |<br>| provide                | 同上                                                         | mergeDataOrFn mergeData |<br>| props                  | mixins/extends只会将自己有的但是组件上没有内容混合到组件上   | extend                  |<br>| methods                | 同上                                                         | extend                  |<br>| inject                 | 同上                                                         | extend                  |<br>| computed               | 同上                                                         | extend                  |<br>| 组件，过滤器，指令属性 | 同上                                                         | extend                  |<br>| el                     | 同上                                                         | defaultStrat            |<br>| propsData              | 同上                                                         | defaultStrat            |<br>| watch                  | 合并watch监控的回调方法，执行顺序是先mixins/extends里watch定义的回调，然后是组件的对调 | strats.watch            |<br>| HOOKS 生命周期钩子     | 同一种钩子的回调函数会被合并成数组，执行顺序是先mixins/extends里定义的钩子函数，然后才是组件里定义的 | mergeHook               |<br><br><strong>（2）mergeOptions 的执行过程</strong><br><br><li>规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</li><br><li>对未合并的选项，进行判断</li><br><br><pre><code class=\"language-JavaScript\">if(!child._base) {<br>    if(child.extends) {<br>        parent = mergeOptions(parent, child.extends, vm)<br>    }<br>    if(child.mixins) {<br>        for(let i = 0, l = child.mixins.length; i < l; i++){<br>            parent = mergeOptions(parent, child.mixins[i], vm)<br>        }<br>    }<br>}<br></code></pre><br><br><li>合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</li><br><li>返回合并结果 options。</li>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014858,
    "title": "描述下Vue自定义指令",
    "content": "<strong>回答：</strong><br><br>Vue 自定义指令用于扩展 DOM 操作，支持全局（ Vue.directive ）或局部（组件 directives 选项）注册，通过 bind （首次绑定）、 inserted （插入 DOM）、 update （组件更新）、 unbind （解绑）等生命周期钩子控制行为<br><br><strong>解析：</strong><br><br>在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。<br><br>一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;<br><br><strong>（1）自定义指令基本内容</strong><br><br><li>全局定义：<code>Vue.directive(\"focus\",{})</code></li><br><br><li>局部定义：<code>directives:{focus:{}}</code></li><br><br><li>钩子函数：指令定义对象提供钩子函数</li><br><br>  o bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。<br><br>  o inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。<br><br>  o update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。<br><br>  o ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。<br><br>  o unbind：只调用一次，指令与元素解绑时调用。<br><br><li>钩子函数参数</li><br><br>  o el：绑定元素<br><br>  o bing： 指令核心对象，描述指令全部信息属性<br><br>  o name<br><br>  o value<br><br>  o oldValue<br><br>  o expression<br><br>  o arg<br><br>  o modifers<br><br>  o vnode  虚拟节点<br><br>  o oldVnode：上一个虚拟节点（更新钩子函数中才有用）<br><br><strong>（2）使用场景</strong><br><br><li>普通DOM元素进行底层操作的时候，可以使用自定义指令</li><br><li>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</li><br><br><strong>（3）使用案例</strong><br><br>初级应用：<br><br><li>鼠标聚焦</li><br><li>下拉菜单</li><br><li>相对时间转换</li><br><li>滚动动画</li><br><br>高级应用：<br><br><li>自定义指令实现图片懒加载</li><br><li>自定义指令集成第三方插件</li>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014859,
    "title": "子组件可以直接改变父组件的数据吗？",
    "content": "<strong>回答：</strong><br><br>在 Vue 中，子组件不能直接修改父组件通过 props 传递的数据（遵循单向数据流原则），需通过 $emit 触发事件，由父组件在内部完成数据修改。<br><br><strong>解析：</strong><br><br>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。<br><br>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。<br><br><strong>只能通过</strong> <code>$emit</code> <strong>派发一个自定义事件，父组件接收到后，由父组件修改。</strong>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014860,
    "title": "Vue是如何收集依赖的？",
    "content": "<strong>回答：</strong><br><br>Vue 通过数据劫持（Vue2用 Object.defineProperty 、Vue3用 Proxy ）拦截数据的 getter / setter ，组件渲染访问数据时触发 getter ，将当前 Watcher（组件/计算属性等）添加到对应数据的 Dep 依赖列表；数据更新时触发 setter ，Dep 通知所有依赖的 Watcher 执行更新，实现响应式。<br><br><strong>解析：</strong><br><br>在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶<br><br><pre><code class=\"language-JavaScript\">function defieneReactive (obj, key, val){<br>  const dep = new Dep();<br>  ...<br>  Object.defineProperty(obj, key, {<br>    ...<br>    get: function reactiveGetter () {<br>      if(Dep.target){<br>        dep.depend();<br>        ...<br>      }<br>      return val<br>    }<br>    ...<br>  })<br>}<br></code></pre><br><br>以上只保留了关键代码，主要就是 <code>const dep = new Dep()</code>实例化一个 Dep 的实例，然后在 get 函数中通过 <code>dep.depend()</code> 进行依赖收集。<br><br><strong>（1）Dep</strong><br><br>Dep是整个依赖收集的核心，其关键代码如下：<br><br><pre><code class=\"language-JavaScript\">class Dep {<br>  static target;<br>  subs;<br><br>  constructor () {<br>    ...<br>    this.subs = [];<br>  }<br>  addSub (sub) {<br>    this.subs.push(sub)<br>  }<br>  removeSub (sub) {<br>    remove(this.sub, sub)<br>  }<br>  depend () {<br>    if(Dep.target){<br>      Dep.target.addDep(this)<br>    }<br>  }<br>  notify () {<br>    const subs = this.subds.slice();<br>    for(let i = 0;i < subs.length; i++){<br>      subs[i].update()<br>    }<br>  }<br>}<br></code></pre><br><br>Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶<br><br><strong>（2）Watcher</strong><br><br><pre><code class=\"language-JavaScript\">class Watcher {<br>  getter;<br>  ...<br>  constructor (vm, expression){<br>    ...<br>    this.getter = expression;<br>    this.get();<br>  }<br>  get () {<br>    pushTarget(this);<br>    value = this.getter.call(vm, vm)<br>    ...<br>    return value<br>  }<br>  addDep (dep){<br>        ...<br>    dep.addSub(this)<br>  }<br>  ...<br>}<br>function pushTarget (_target) {<br>  Dep.target = _target<br>}<br></code></pre><br><br>Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。<br><br><strong>（3）过程</strong><br><br>在实例化 Vue 时，依赖收集的相关过程如下∶<br><br>初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。<br><br>初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，<br><br><pre><code class=\"language-JavaScript\">updateComponent = () => {<br>  vm._update(vm._render())<br>}<br>new Watcher(vm, updateComponent)<br></code></pre><br><br>get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。<br><br>this.getter.call（vm，vm），这里的 getter 会执行 vm.render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm. render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014861,
    "title": "28. 对 React 和 Vue 的理解，它们的异同",
    "content": "<strong>回答：</strong><br><br>React 和 Vue 均为现代前端框架，核心相似点是：采用组件化开发模式，利用虚拟 DOM 优化渲染性能，支持服务器端渲染（SSR），并提供状态管理方案（React 有 Redux/Context、Vue 有 Vuex/Pinia）。<br><br>主要差异在于设计理念与实现细节：React 强调函数式编程与单向数据流，通过 JSX 统一逻辑与视图，状态更新需手动触发（如 setState / useState ）；Vue 采用渐进式设计与声明式语法（支持模板与 JSX），通过 Object.defineProperty （Vue 2）或 Proxy （Vue 3）实现自动响应式，数据变化时视图自动更新<br><br><strong>解析：</strong><br><br><strong>相似之处：</strong><br><br><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li><br><li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li><br><li>都使用了Virtual DOM（虚拟DOM）提高重绘性能；</li><br><li>都有props的概念，允许组件间的数据传递；</li><br><li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li><br><br><strong>不同之处 ：</strong><br><br><strong>1）数据流</strong><br><br>Vue默认支持数据双向绑定，而React一直提倡单向数据流<br><br><strong>2）虚拟DOM</strong><br><br>Vue2.x开始引入\"Virtual DOM\"，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。<br><br><li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li><br><li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li><br><br><strong>3）组件化</strong><br><br>React与Vue最大的不同是模板的编写。<br><br><li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li><br><li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li><br><br>具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。<br><br><strong>4）监听数据变化的实现原理不同</strong><br><br><li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><br><li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li><br><br><strong>5）高阶组件</strong><br><br>react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。<br><br>高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。<br><br><strong>6）构建工具</strong><br><br>两者都有自己的构建工具：<br><br><li>React ==> Create React APP</li><br><li>Vue ==> vue-cli</li><br><br><strong>7）跨平台</strong><br><br><li>React ==> React Native</li><br><li>Vue ==> Weex</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014862,
    "title": "29. Vue的优点",
    "content": "<strong>回答：</strong><br><br>Vue是轻量级前端框架（仅几十kb），具有中文文档易学习的优势；支持双向数据绑定与组件化开发（适合单页面应用），实现视图、数据、结构分离；通过虚拟DOM减少原生DOM操作，性能更优，运行速度快于React。<br><br><li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 <code>kb</code> ；</li><br><li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li><br><li>双向数据绑定：保留了 <code>angular</code> 的特点，在数据操作方面更为简单；</li><br><li>组件化：保留了 <code>react</code> 的优点，实现了 <code>html</code> 的封装和重用，在构建单页面应用方面有着独特的优势；</li><br><li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li><br><li>虚拟DOM：<code>dom</code> 操作是非常耗费性能的，不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作，但具体操作的还是 <code>dom</code> 不过是换了另一种方式；</li><br><li>运行速度更快：相比较于 <code>react</code> 而言，同样是操作虚拟 <code>dom</code>，就性能而言， <code>vue</code> 存在很大的优势。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014864,
    "title": "assets和static的区别",
    "content": "<strong>回答：</strong><br><br>Vue项目中 assets 与 static 的核心区别：<br><br>1. 处理方式 ： assets 会被Webpack打包压缩、加哈希优化； static 直接复制，不经过构建处理。<br>2. 引用方式 ： assets 用相对路径或 import 引入； static 用绝对路径（如 /static/xx.png ）。<br>3. 用途 ： assets 存放需优化的内部资源（如组件图片、样式）； static 存放无需处理的第三方文件或大资源。<br>4. 打包位置 ： assets 在 dist/assets 目录（文件名带哈希）； static 在 dist/static 目录（保持原名）。<br><br><strong>解析：</strong><br><br><strong>相同点：</strong> <code>assets</code> 和 <code>static</code> 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点<br><br><strong>不相同点：</strong><code>assets</code> 中存放的静态资源文件在项目打包时，也就是运行 <code>npm run build</code> 时会将 <code>assets</code> 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器。<code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间。<br><br><strong>建议：</strong> 将项目中 <code>template</code>需要的样式文件js文件等都可以放置在 <code>assets</code> 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014865,
    "title": "delete和Vue.delete删除数组的区别",
    "content": "<li><code>delete</code> 只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li><br><li><code>Vue.delete</code> 直接删除了数组 改变了数组的键值。</li>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014866,
    "title": "32. vue如何监听对象或者数组某个属性的变化",
    "content": "<strong>回答：</strong><br><br>Vue通过响应式机制监听对象/数组变化：<br><br>1. 对象 ：默认监听已有属性，新增属性在Vue2中用 Vue.set(this.obj, 'newKey', val) ，Vue3因Proxy支持可直接赋值；<br>2. 数组 ：Vue2中索引/长度变化需用 Vue.set(this.arr, index, val) 或 splice ，Vue3直接支持；<br>3. 特定属性监听 ：用 watch 配置，深层属性加 deep: true ，或通过计算属性转换后监听具体值。<br><br><strong>解析：</strong><br><br>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。<br><br>解决方式：<br><br><li>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</li><br><br><pre><code class=\"language-JavaScript\">this.$set(this.arr, 0, \"OBKoro1\"); // 改变数组<br>this.$set(this.obj, \"c\", \"OBKoro1\"); // 改变对象<br></code></pre><br><br><li>调用以下几个数组的方法</li><br><br><pre><code class=\"language-JavaScript\">splice()、 push()、pop()、shift()、unshift()、sort()、reverse()<br></code></pre><br><br>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作<br><br>vm.<code>$set</code> 的实现原理是：<br><br><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li><br><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014867,
    "title": "什么是 mixin ？",
    "content": "<strong>回答：</strong><br><br>Mixin 是前端框架（如 Vue、React）中用于 代码复用 的机制，本质是包含可复用逻辑（方法、数据、生命周期钩子等）的对象。开发者将通用功能（如表单验证、数据请求）抽离到 mixin 中，再通过混入方式在多个组件中共享，减少重复代码。<br><br><li>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li><br><li>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li><br><li>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014868,
    "title": "34. Vue模版编译原理",
    "content": "<strong>回答：</strong><br><br>Vue 模板编译是将声明式模板转换为命令式渲染逻辑的过程，核心分三步：首先通过解析器将模板字符串解析为包含标签、指令、表达式等结构转化成抽象语法树（AST）；接着优化器标记模板中的静态节点（如纯文本、固定属性），避免重复渲染以提升性能；最后代码生成器将优化后的 AST 转换为render函数，执行后返回虚拟DOM（VNode），最终通过 patch 过程渲染到真实 DOM，实现高效的页面更新。<br><br><strong>解析：</strong><br><br>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。<br><br><li><strong>解析阶段</strong>：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li><br><li><strong>优化阶段</strong>：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li><br><li><strong>生成阶段</strong>：将最终的AST转化为render函数字符串。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014869,
    "title": "35. 对SSR的理解",
    "content": "<strong>回答：</strong><br><br>服务端渲染（SSR）是指页面HTML结构在服务器生成后直接发送给浏览器，区别于客户端渲染需加载JS后动态生成DOM的方式。<br><br><strong>解析：</strong><br><br>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端<br><br>SSR的优势：<br><br><li>更好的SEO</li><br><li>首屏加载速度更快</li><br><br>SSR的缺点：<br><br><li>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</li><br><li>当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</li><br><li>更多的服务端负载。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014870,
    "title": "36. Vue的性能优化有哪些",
    "content": "<strong>（1）编码阶段</strong><br><br><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><br><li>v-if和v-for不能连用</li><br><li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li><br><li>SPA 页面采用keep-alive缓存组件</li><br><li>在更多的情况下，使用v-if替代v-show</li><br><li>key保证唯一</li><br><li>使用路由懒加载、异步组件</li><br><li>防抖、节流</li><br><li>第三方模块按需导入</li><br><li>长列表滚动到可视区域动态加载</li><br><li>图片懒加载</li><br><br><strong>（2）SEO优化</strong><br><br><li>预渲染</li><br><li>服务端渲染SSR</li><br><br><strong>（3）打包优化</strong><br><br><li>压缩代码</li><br><li>Tree Shaking/Scope Hoisting</li><br><li>使用cdn加载第三方模块</li><br><li>多线程打包happypack</li><br><li>splitChunks抽离公共文件</li><br><li>sourceMap优化</li><br><br><strong>（4）用户体验</strong><br><br><li>骨架屏</li><br><li>PWA</li><br><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014871,
    "title": "37. 对 SPA 单页面的理解，它的优缺点分别是什么？",
    "content": "<strong>回答：</strong><br><br>SPA（单页面应用）是指仅在初始化时加载完整资源，之后通过路由机制动态切换页面内容，无需重新加载整个页面的Web应用。<br><br>优点 ：<br><br><li>用户体验流畅，交互无刷新延迟；</li><br><li>服务器压力小，只需要提供数据接口；</li><br><li>前后端分离，职责清晰易维护。</li><br><br>缺点 ：<br><br><li>首次加载耗时较长，需一次性加载核心资源；</li><br><li>需自行管理路由堆栈，实现浏览器前进后退功能；</li><br><li>动态内容不利于搜索引擎抓取，SEO优化难度大。</li><br><br><strong>解析；</strong><br><br>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。<br><br><strong>优点：</strong><br><br><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><br><li>基于上面一点，SPA 相对对服务器压力小；</li><br><li>前后端职责分离，架构清晰·，前端进行交互逻辑，后端负责数据处理；</li><br><br><strong>缺点：</strong><br><br><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><br><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><br><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014872,
    "title": "template和jsx的有什么分别？",
    "content": "<strong>回答：</strong><br><br>template与JSX是前端框架中两种核心视图描述方式，核心区别如下：<br><br>template（Vue主流） ：<br><br><li>类HTML语法（如 <div>{{ msg }}</div> ），接近原生，易读易学；</li><br><li>由框架编译为渲染render函数后生成虚拟DOM；</li><br><li>语法受限但开发高效，适合快速构建标准界面。</li><br><br>JSX（React主流） ：<br><br><li>JavaScript语法扩展（如 <div>{msg}</div> ），允许嵌入完整JS逻辑；</li><br><li>通过Babel转译为 React.createElement() 直接生成虚拟DOM；</li><br><li>灵活性强，可处理复杂交互，但需熟悉JS语法。</li><br><br><strong>解析：</strong><br><br>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。<br><br>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014873,
    "title": "vue初始化页面闪动问题",
    "content": "<strong>回答：</strong><br><br>Vue实例挂载前，浏览器会先解析并渲染原始HTML，此时Vue尚未完成数据绑定和模板编译，导致原始模板代码短暂可见。<br><br><strong>解析：</strong><br><br>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。<br><br>首先：在css里加上以下代码：<br><br><pre><code class=\"language-JavaScript\">[v-cloak] {<br>    display: none;<br>}<br></code></pre><br><br>如果没有彻底解决问题，则在根元素加上<code>style=\"display: none;\" :style=\"{display: 'block'}\"</code>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014874,
    "title": "extend 有什么作用",
    "content": "这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。<br><br><pre><code class=\"language-JavaScript\">// 创建组件构造器<br>let Component = Vue.extend({<br>  template: '<div>test</div>'<br>})<br>// 挂载到 #app 上<br>new Component().$mount('#app')<br>// 除了上面的方式，还可以用来扩展已有的组件<br>let SuperComponent = Vue.extend(Component)<br>new SuperComponent({<br>    created() {<br>        console.log(1)<br>    }<br>})<br>new SuperComponent().$mount('#app')<br></code></pre>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014875,
    "title": "42. **MVVM**的优缺点 **?**",
    "content": "<strong>回答：</strong><br><br>MVVM是前端数据驱动架构模式，核心优势是通过ViewModel实现数据与视图双向绑定，减少手动DOM操作、提升开发效率，且Model/View/ViewModel职责分离，代码模块化易维护；但复杂应用下数据绑定可能带来性能开销，对新手有学习门槛，且自动绑定可能增加调试难度。<br><br><strong>解析：</strong><br><br>优点:<br><br><li>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的\"View\"上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑</li><br><li>提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码</li><br><li>⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放</li><br><br>缺点:<br><br><li>Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的</li><br><li>⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存</li><br><li>对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014876,
    "title": "43. **v-if和**v-for哪个优先级更高？如果同时出现，应如何优化？",
    "content": "v-for优先于v-if被解析，如果同时出现，每次渲染都会<strong>先执行循环再判断条件</strong>，无论如何循环都不可避免，浪费了性能。<br><br>要避免出现这种情况，则在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环。如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014877,
    "title": "44. 对Vue组件化的理解",
    "content": "<strong>回答：</strong><br><br>Vue组件化是将UI拆分为 独立、可复用模块 的开发模式，核心通过单文件组件（.vue）封装模板、逻辑、样式，实现代码模块化；其价值在于提高复用性、可维护性和开发效率<br><br><strong>解析：</strong><br><br>1. 组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；<br>2. 组件化开发能大幅提高应用开发效率、测试性、复用性等；<br>3. 组件使用按分类有：页面组件、业务组件、通用组件；<br>4. vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于VueComponent，扩展于Vue；<br>5. vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等；6.合理的划分组件，有助于提升应用性能；<br>6. 组件应该是高内聚、低耦合的；<br>7. 遵循单向数据流的原则。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014878,
    "title": "45. 对vue设计原则的理解",
    "content": "<strong>回答：</strong><br><br>Vue的设计原则的核心是渐进式框架 ；通过响应式系统 （数据劫持）实现数据与视图自动同步，减少手动DOM操作；基于组件化思想封装可复用模块，提升代码可维护性；<br><br><strong>解析：</strong><br><br>1. <strong>渐进式JavaScript框架</strong>：与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动。<br>2. <strong>易用性</strong>：vue提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js、html和css就能轻松编写vue应用。<br>3. <strong>灵活性</strong>：渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能；随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli等库和工具，不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。<br>4. <strong>高效性：</strong> 超快的虚拟DOM和diﬀ算法使我们的应用拥有最佳的性能表现。追求高效的过程还在继续，vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014879,
    "title": "46. 常见的Vue性能优化方法",
    "content": "<strong>回答：</strong><br><br>Vue性能优化可从多层面入手，核心方法包括：渲染层面（v-for用唯一key提升复用，避免v-if与v-for同用）、组件层面（keep-alive缓存页面，路由懒加载）、响应式层面（非必要数据用shallowRef/Object.freeze减少响应式开销）、构建层面（代码分割、资源压缩减小打包体积），通过这些方式可有效提升应用运行效率。<br><br><strong>解析：</strong><br><br>1. 路由懒加载<br><br><pre><code class=\"language-Vue\">const router = new VueRouter({ routes: [<br>    { path: '/foo', component: () => import('./Foo.vue') }<br>  ]<br>})<br></code></pre><br><br>1. keep-alive缓存页面<br><br><pre><code class=\"language-Vue\"><template><br>  <div id=\"app\"><br>    <keep-alive><br>      <router-view/><br>    </keep-alive><br>  </div><br></template><br></code></pre><br><br>1. 使用v-show复用DOM<br><br><pre><code class=\"language-Vue\"><template><br>  <div class=\"cell\"><br>     <!--这种情况用v-show复用DOM，比v-if效果好--><br>     <div v-show=\"value\" class=\"on\"><br>        <Heavy :n=\"10000\"/><br>     </div><br>     <section v-show=\"!value\" class=\"off\"><br>        <Heavy :n=\"10000\"/><br>     </section><br>  </div><br></template><br></code></pre><br><br>1. v-for 遍历避免同时使用 v-if<br><br><pre><code class=\"language-Vue\"><template><br>  <ul><br>    <li v-for=\"user in activeUsers\" :key=\"user.id\"><br>      {{ user.name }}<br>    </li><br>  </ul><br></template><br><br><script><br>export default { <br>  computed: {<br>    activeUsers: function () {<br>      return this.users.filter(function (user) { <br>        return user.isActive<br>      })<br>    }<br>  }<br>}<br></script><br></code></pre><br><br>1. 长列表性能优化<br><br><pre><code class=\"language-Vue\">// 如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化<br>export default { <br>  data: () => ({<br>    users: []<br>  }),<br>  async created() {<br>    const users = await axios.get(\"/api/users\"); <br>    this.users = Object.freeze(users);<br>  }  <br>};<br><br>// 如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容<br><recycle-scroller class=\"items\" :items=\"items\" :item-size=\"24\"><br>  <template v-slot=\"{ item }\"><br>     <FetchItemView :item=\"item\" @vote=\"voteItem(item)\"/><br>  </template><br></recycle-scroller><br></code></pre><br><br>1. 事件的销毁<br><br>Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。<br><br><pre><code class=\"language-Vue\">created() {<br>  this.timer = setInterval(this.refresh, 2000)<br>},<br>beforeDestroy() { <br>  clearInterval(this.timer)<br>}<br></code></pre><br><br>1. 图片懒加载<br><br>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。<br><br><pre><code class=\"language-Vue\"><img v-lazy=\"/static/img/1.png\"><br></code></pre><br><br>1. 第三方插件按需引入<br><br>像element-ui这样的第三方组件库可以按需引入避免体积太大。<br><br><pre><code class=\"language-Vue\">import Vue from 'vue';<br>import { Button, Select } from 'element-ui';<br><br>Vue.use(Button) Vue.use(Select)<br></code></pre><br><br>1. 无状态的组件标记为函数式组件<br><br><pre><code class=\"language-Vue\"><template functional><br>  <div class=\"cell\"><br>    <div v-if=\"props.value\" class=\"on\"></div><br>    <section v-else class=\"off\"></section><br>  </div><br></template><br><br><script><br>  export default { props: ['value'] }<br></script><br></code></pre><br><br>1. 子组件分隔<br><br><pre><code class=\"language-Vue\"><template><br>  <div><br>    <ChildComp/><br>  </div><br></template><br><br><script><br>  export default { <br>    components: {<br>      ChildComp: { <br>        methods: {<br>          heavy () { /<em> 耗时任务 </em>/ }<br>        },<br>        render (h) {<br>          return h('div', this.heavy())<br>        }<br>      }<br>    }<br>  }<br></script><br></code></pre><br><br>1. 变量本地化<br><br><pre><code class=\"language-Vue\"><template><br>  <div :style=\"{ opacity: start / 300 }\"><br>    {{ result }}<br>  </div><br></template><br><br><script><br>import { heavy } from '@/utils'<br><br>export default { <br>  props: ['start'], <br>  computed: {<br>    base () { <br>      return 42 <br>    }, <br>    result () {<br>      const base = this.base // 不要频繁引用this.base<br>      let result = this.start<br>      for (let i = 0; i < 1000; i++) { <br>        result += heavy(base)<br>      }<br>      return result<br>    }<br>  }<br>}<br></script><br></code></pre>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014881,
    "title": "47. v-model的实现原理",
    "content": "vue中v-model可以实现数据的双向绑定，但是为什么这个指令就可以实现数据的双向绑定呢？其实v-model是vue的一个语法糖。即利用v-model绑定数据后，既绑定了数据，又添加了一个input事件监听。<br><br>实现原理：<br><br><li>v-bind绑定响应数据</li><br><li>触发input事件并传递数据</li><br><br>示例：<br><br><pre><code class=\"language-HTML\"><input v-model=\"text\"></input><br>// 等价于：<br><input :value=\"text\" @input=\"text = $event.target.value\"></input><br>// 组件中使用：<br><custom-input :value=\"text\" @input=\"$event\"></custom-input><br>// 根据v-model原理模拟：<br><input type=\"text\" id=\"ipt1\"><br><input type=\"text\" id=\"ipt2\"><br><script><br>    var ipt1=document.getElementById('ipt1');<br>    var ipt2=document.getElementById('ipt2');<br>    ipt1.addEventListener(\"input\",function(){<br>        ipt2.value=ipt1.value;<br>    })<br></script><br></code></pre>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014882,
    "title": "实现svg图标组件化",
    "content": "<li>安装插件，能够以组件的形式在项目中引用这些图标</li><br><br><pre><code class=\"language-Bash\">pnpm install vite-plugin-svg-icons -D<br>import 'virtual:svg-icons-register'<br></code></pre><br><br><li>配置插件（vite.config.js）</li><br><br><pre><code class=\"language-TypeScript\">import path from 'path';<br>import Vue from '@vitejs/plugin-vue';<br>import { createSvgIconsPlugin } from 'vite-plugin-svg-icons';<br><br>export function createVitePlugins(command: 'build' | 'serve') {<br>  return [<br>    Vue({<br>      include: [/\\.vue$/, /\\.md$/],<br>    }),<br>    createSvgIconsPlugin({<br>      iconDirs: [path.resolve(process.cwd(), 'src/assets/icons')],<br>      svgoOptions: command === 'build',<br>    }),<br>  ];<br>}<br>// 注意 __dirname 和 process.cwd() 的区别<br></code></pre><br><br><li>创建Svg组件并全局引入</li><br><br><pre><code class=\"language-Vue\"><template><br>  <svg class=\"svg-icon\" aria-hidden=\"true\" :style=\"{ fontSize: <code>${size}px</code>, color }\"><br>    <use :xlink:href=\"iconName\" :fill=\"color\" /><br>  </svg><br></template><br><br><script setup lang=\"ts\"><br>interface Props {<br>  name: string | null;<br>  size?: string | number;<br>  color?: string;<br>  cursor?: string;<br>}<br>const props = withDefaults(defineProps<Props>(), {<br>  size: '16',<br>  color: '',<br>});<br>const iconName = computed(() => <code>#icon-${props.name}</code>);<br>const cursor = computed(() => props.cursor || null);<br></script><br><br><style scoped lang=\"less\"><br>.svg-icon {<br>  flex-shrink: 0;<br>  position: relative;<br>  width: 1em;<br>  height: 1em;<br>  vertical-align: -2px;<br>  transition: opacity 0.3s;<br>  cursor: v-bind(cursor);<br>  fill: currentcolor;<br>  &:focus {<br>    outline: none;<br>  }<br>}<br></style><br></code></pre><br><br><li>使用svg组件</li><br><br><pre><code class=\"language-Vue\">// 这里的magic应该是配置文件中配置的路径src/assets/icons下的图标的名字<br><svg-icon name=\"magic\" size=\"20\" cursor=\"pointer\" color=\"#ed7863\" /><br></code></pre><br><br><h2>二、生命周期</h2>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014883,
    "title": "1. 说一下Vue的生命周期",
    "content": "Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。<br><br>![img](https://secure2.wostatic.cn/static/6DQAusfwkkzVpXSVkJFWc/image.png)<br><br><strong>创建阶段：</strong>初始化响应式数据和事件。<br><br><li><strong>beforeCreate（创建前）</strong>：实例刚创建，<strong>数据data和事件methods还未初始化</strong>。</li><br><li><strong>created（创建后）</strong> ：<strong>实例创建完成</strong>。数据data已响应式化，事件methods已配置，<strong>可在此发起异步请求</strong>。<strong>但未挂载，DOM 不存在</strong>。</li><br><br><strong>挂载阶段：</strong>将模板编译渲染成真实 DOM 并插入页面。<br><br><li><strong>beforeMount（挂载前）</strong>：模板已编译，<strong>但尚未将渲染内容挂载到页面上</strong>。</li><br><li><strong>mounted（挂载后）</strong>： <strong>实例已挂载到页面</strong>，真实 DOM 已生成并可访问，<strong>可在此进行 DOM 操作或访问$refs</strong>。</li><br><br><strong>更新阶段：</strong>当数据变化时，虚拟 DOM 重新渲染。<br><br><li><strong>beforeUpdate（更新前）</strong>：数据发生变化，<strong>但虚拟 DOM 尚未重新渲染</strong>。</li><br><li><strong>updated（更新后）</strong> ：数据更改导致虚拟 DOM 重新渲染，可在此操作更新后的 DOM。</li><br><br><strong>销毁阶段：</strong>实例被销毁。<br><br><li><strong>beforeDestroy（销毁前）</strong>：<strong>实例即将被销毁</strong>，此刻实例仍完全可用。</li><br><li><strong>destroyed（销毁后）</strong>：<strong>实例已销毁</strong>，所有指令被解绑，事件监听器被移除，子实例也被销毁。<strong>在此进行最终的清理工作</strong></li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014884,
    "title": "Vue 子组件和父组件生命周期的执行顺序",
    "content": "<strong>加载渲染过程：</strong><br><br>父 beforeCreate->父 created->父 beforeMount-> 子 beforeCreate->子 created->子 beforeMount->子 mounted ->父 mounted<br><br><strong>更新过程：</strong><br><br>父 beforeUpdate-> 子 beforeUpdate->子 updated ->父 updated<br><br><strong>销毁过程：</strong><br><br>父 beforeUnmount-> <strong>子 beforeUnmount->子 unmounted</strong> ->父 unmounted",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014885,
    "title": "3. created和mounted的区别",
    "content": "<strong>回答：</strong><br><br>created 和 mounted 的核心区别在于 执行时机和可访问的资源 ：created 是组件创建完成后执行（数据层初始化完成，DOM 尚未生成，无法操作DOM），mounted 是DOM挂载完成后执行，可操作真实DOM。<br><br><li>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li><br><li>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014886,
    "title": "4. 一般在哪个生命周期请求异步数据",
    "content": "<strong>回答：</strong><br><br>在 created 钩子函数中调用异步请求，能更快获取到服务端数据，减少页面加载时间，用户体验更好；<br><br><strong>解析：</strong><br><br>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。<br><br>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：<br><br><li>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li><br><li>SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014887,
    "title": "5. keep-alive 中的生命周期哪些",
    "content": "<strong>回答：</strong><br><br>组件被激活触发activated，组件被停用时触发deactivated。<br><br>keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。<br><br>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。<br><br>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。<br><br><h2>*三、组件通信</h2><br><br>组件通信的方式如下：<br><br>![img](https://secure2.wostatic.cn/static/pDHoqGAQRy9keroEcbYSwh/image.png)",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014888,
    "title": "（1） props  /  $emit",
    "content": "父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信<br><br>##### 1. 父组件向子组件传值<br><br><li><code>props</code>只能是父组件向子组件进行传值，<code>props</code>使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。</li><br><li><code>props</code> 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。</li><br><li><code>props</code>属性名规则：若在<code>props</code>中使用驼峰形式，模板中需要使用短横线的形式</li><br><br><pre><code class=\"language-JavaScript\">// 父组件<br><template><br>    <div id=\"father\"><br>        <son :msg=\"msgData\" :fn=\"myFunction\"></son><br>    </div><br></template><br><br><script><br>import son from \"./son.vue\";<br>export default {<br>    name: father,<br>    data() {<br>        msgData: \"父组件数据\";<br>    },<br>    methods: {<br>        myFunction() {<br>            console.log(\"vue\");<br>        }<br>    },<br>    components: {<br>        son<br>    }<br>};<br></script><br>// 子组件<br><template><br>    <div id=\"son\"><br>        <p>{{msg}}</p><br>        <button @click=\"fn\">按钮</button><br>    </div><br></template><br><script><br>export default {<br>    name: \"son\",<br>    props: [\"msg\", \"fn\"]<br>};<br></script><br></code></pre><br><br>##### 2. 子组件向父组件传值<br><br><li><code>$emit</code>绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过<code>v-on</code>监听并接收参数。</li><br><br><pre><code class=\"language-JavaScript\">// 父组件<br><template><br>  <div class=\"section\"><br>    <com-article :articles=\"articleList\" @onEmitIndex=\"onEmitIndex\"></com-article><br>    <p>{{currentIndex}}</p><br>  </div><br></template><br><br><script><br>import comArticle from './test/article.vue'<br>export default {<br>  name: 'comArticle',<br>  components: { comArticle },<br>  data() {<br>    return {<br>      currentIndex: -1,<br>      articleList: ['红楼梦', '西游记', '三国演义']<br>    }<br>  },<br>  methods: {<br>    onEmitIndex(idx) {<br>      this.currentIndex = idx<br>    }<br>  }<br>}<br></script><br>//子组件<br><template><br>  <div><br>    <div v-for=\"(item, index) in articles\" :key=\"index\" @click=\"emitIndex(index)\">{{item}}</div><br>  </div><br></template><br><br><script><br>export default {<br>  props: ['articles'],<br>  methods: {<br>    emitIndex(index) {<br>      this.$emit('onEmitIndex', index) // 触发父组件的方法，并传递参数index<br>    }<br>  }<br>}<br></script><br></code></pre>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014889,
    "title": "（2）eventBus事件总线（$emit / $on）",
    "content": "<code>eventBus</code>事件总线适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，使用步骤如下：<br><br><strong>（1）创建事件中心管理组件之间的通信</strong><br><br><pre><code class=\"language-JavaScript\">// event-bus.js<br><br>import Vue from 'vue'<br>export const EventBus = new Vue()<br></code></pre><br><br><strong>（2）发送事件</strong><br><br>假设有两个兄弟组件<code>firstCom</code>和<code>secondCom</code>：<br><br><pre><code class=\"language-JavaScript\"><template><br>  <div><br>    <first-com></first-com><br>    <second-com></second-com><br>  </div><br></template><br><br><script><br>import firstCom from './firstCom.vue'<br>import secondCom from './secondCom.vue'<br>export default {<br>  components: { firstCom, secondCom }<br>}<br></script><br></code></pre><br><br>在<code>firstCom</code>组件中发送事件：<br><br><pre><code class=\"language-JavaScript\"><template><br>  <div><br>    <button @click=\"add\">加法</button>    <br>  </div><br></template><br><br><script><br>import {EventBus} from './event-bus.js' // 引入事件中心<br><br>export default {<br>  data(){<br>    return{<br>      num:0<br>    }<br>  },<br>  methods:{<br>    add(){<br>      EventBus.$emit('addition', {<br>        num:this.num++<br>      })<br>    }<br>  }<br>}<br></script><br></code></pre><br><br><strong>（3）接收事件</strong><br><br>在<code>secondCom</code>组件中发送事件：<br><br><pre><code class=\"language-JavaScript\"><template><br>  <div>求和: {{count}}</div><br></template><br><br><script><br>import { EventBus } from './event-bus.js'<br>export default {<br>  data() {<br>    return {<br>      count: 0<br>    }<br>  },<br>  mounted() {<br>    EventBus.$on('addition', param => {<br>      this.count = this.count + param.num;<br>    })<br>  }<br>}<br></script><br></code></pre><br><br>在上述代码中，这就相当于将<code>num</code>值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。<br><br>虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014890,
    "title": "（3）依赖注入（provide/ inject）",
    "content": "这种方式就是Vue中的<strong>依赖注入</strong>，该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。<br><br><code>provide / inject</code>是Vue提供的两个钩子，和<code>data</code>、<code>methods</code>是同级的。并且<code>provide</code>的书写形式和<code>data</code>一样。<br><br><li><code>provide</code> 钩子用来发送数据或方法</li><br><li><code>inject</code>钩子用来接收数据或方法</li><br><br>在父组件中：<br><br><pre><code class=\"language-JavaScript\">provide() {<br> return {<br>    num: this.num<br>  };<br>}<br></code></pre><br><br>在子组件中：<br><br><pre><code class=\"language-JavaScript\">inject: ['num']<br></code></pre><br><br>还可以这样写，这样写就可以访问父组件中的所有属性：<br><br><pre><code class=\"language-JavaScript\">provide() {<br> return {<br>    app: this<br>  };<br>}<br>data() {<br> return {<br>    num: 1<br>  };<br>}<br><br>inject: ['app']<br>console.log(this.app.num)<br></code></pre><br><br><strong>注意：</strong> 依赖注入所提供的属性是<strong>非响应式</strong>的。",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014891,
    "title": "（3）ref / $refs",
    "content": "这种方式也是实现<strong>父子组件</strong>之间的通信。<br><br><code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。<br><br>在子组件中：<br><br><pre><code class=\"language-JavaScript\">export default {<br>  data () {<br>    return {<br>      name: 'JavaScript'<br>    }<br>  },<br>  methods: {<br>    sayHello () {<br>      console.log('hello')<br>    }<br>  }<br>}<br></code></pre><br><br>在父组件中：<br><br><pre><code class=\"language-JavaScript\"><template><br>  <child ref=\"child\"></component-a><br></template><br><script><br>  import child from './child.vue'<br>  export default {<br>    components: { child },<br>    mounted () {<br>      console.log(this.$refs.child.name);  // JavaScript<br>      this.$refs.child.sayHello();  // hello<br>    }<br>  }<br></script><br></code></pre>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014892,
    "title": "（4）$parent / $children",
    "content": "<li>使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</li><br><li>使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</li><br><br>在子组件中：<br><br><pre><code class=\"language-JavaScript\"><template><br>  <div><br>    <span>{{message}}</span><br>    <p>获取父组件的值为:  {{parentVal}}</p><br>  </div><br></template><br><br><script><br>export default {<br>  data() {<br>    return {<br>      message: 'Vue'<br>    }<br>  },<br>  computed:{<br>    parentVal(){<br>      return this.$parent.msg;<br>    }<br>  }<br>}<br></script><br></code></pre><br><br>在父组件中：<br><br><pre><code class=\"language-JavaScript\">// 父组件中<br><template><br>  <div class=\"hello_world\"><br>    <div>{{msg}}</div><br>    <child></child><br>    <button @click=\"change\">点击改变子组件值</button><br>  </div><br></template><br><br><script><br>import child from './child.vue'<br>export default {<br>  components: { child },<br>  data() {<br>    return {<br>      msg: 'Welcome'<br>    }<br>  },<br>  methods: {<br>    change() {<br>      // 获取到子组件<br>      this.$children[0].message = 'JavaScript'<br>    }<br>  }<br>}<br></script><br></code></pre><br><br>在上面的代码中，子组件获取到了父组件的<code>parentVal</code>值，父组件改变了子组件中<code>message</code>的值。<br><br><strong>需要注意：</strong><br><br><li>通过<code>$parent</code>访问到的是上一级父组件的实例，可以使用<code>$root</code>来访问根组件的实例</li><br><li>在组件中使用<code>$children</code>拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li><br><li>在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组</li><br><li><code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></li>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014893,
    "title": "（5）$attrs / $listeners",
    "content": "考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？<br><br>如果是用<code>props/$emit</code>来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。<br><br>针对上述情况，Vue引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。<br><br>先来看一下<code>inheritAttrs</code>，它的默认值true，继承所有的父组件属性除<code>props</code>之外的所有属性；<code>inheritAttrs：false</code> 只继承class属性 。<br><br><li><code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li><br><li><code>$listeners</code>：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=\"$listeners\"</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li><br><br>A组件（<code>APP.vue</code>）：<br><br><pre><code class=\"language-JavaScript\"><template><br>    <div id=\"app\"><br>        //此处监听了两个事件，可以在B组件或者C组件中直接触发 <br>        <child1 :p-child1=\"child1\" :p-child2=\"child2\" @test1=\"onTest1\" @test2=\"onTest2\"></child1><br>    </div><br></template><br><script><br>import Child1 from './Child1.vue';<br>export default {<br>    components: { Child1 },<br>    methods: {<br>        onTest1() {<br>            console.log('test1 running');<br>        },<br>        onTest2() {<br>            console.log('test2 running');<br>        }<br>    }<br>};<br></script><br></code></pre><br><br>B组件（<code>Child1.vue</code>）：<br><br><pre><code class=\"language-JavaScript\"><template><br>    <div class=\"child-1\"><br>        <p>props: {{pChild1}}</p><br>        <p>$attrs: {{$attrs}}</p><br>        <child2 v-bind=\"$attrs\" v-on=\"$listeners\"></child2><br>    </div><br></template><br><script><br>import Child2 from './Child2.vue';<br>export default {<br>    props: ['pChild1'],<br>    components: { Child2 },<br>    inheritAttrs: false,<br>    mounted() {<br>        this.$emit('test1'); // 触发APP.vue中的test1方法<br>    }<br>};<br></script><br></code></pre><br><br>C 组件 (<code>Child2.vue</code>)：<br><br><pre><code class=\"language-JavaScript\"><template><br>    <div class=\"child-2\"><br>        <p>props: {{pChild2}}</p><br>        <p>$attrs: {{$attrs}}</p><br>    </div><br></template><br><script><br>export default {<br>    props: ['pChild2'],<br>    inheritAttrs: false,<br>    mounted() {<br>        this.$emit('test2');// 触发APP.vue中的test2方法<br>    }<br>};<br></script><br></code></pre><br><br>在上述代码中：<br><br><li>C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li><br><li>在B组件中通过v-bind 绑定<code>$attrs</code>属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）</li>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014894,
    "title": "（6）总结",
    "content": "<strong>（1）父子组件间通信</strong><br><br><li>子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li><br><li>通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。</li><br><li>使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。</li><br><br><strong>（2）兄弟组件间通信</strong><br><br><li>使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li><br><li>通过 parent/parent/parent/refs 来获取到兄弟组件，也可以进行通信。</li><br><br><strong>（3）任意组件之间</strong><br><br><li>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li><br><br>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。<br><br><h2>四、路由</h2>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014895,
    "title": "Vue-Router 的懒加载如何实现",
    "content": "<strong>回答：</strong><br><br>Vue-Router 的懒加载通过 动态导入（Dynamic Import） 实现，核心是利用 ES6 的 import() 函数按需加载组件，减小初始打包体积，提升首屏加载速度。<br><br><strong>解析：</strong><br><br>非懒加载：<br><br><pre><code class=\"language-JavaScript\">import List from '@/components/list.vue'<br>const router = new VueRouter({<br>  routes: [<br>    { path: '/list', component: List }<br>  ]<br>})<br></code></pre><br><br>（1）方案一(常用)：使用箭头函数+import动态加载<br><br><pre><code class=\"language-JavaScript\">const List = () => import('@/components/list.vue')<br>const router = new VueRouter({<br>  routes: [<br>    { path: '/list', component: List }<br>  ]<br>})<br></code></pre><br><br>（2）方案二：使用箭头函数+require动态加载<br><br><pre><code class=\"language-JavaScript\">const router = new Router({<br>  routes: [<br>   {<br>     path: '/list',<br>     component: resolve => require(['@/components/list'], resolve)<br>   }<br>  ]<br>})<br></code></pre><br><br>（3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。<br><br><pre><code class=\"language-JavaScript\">// r就是resolve<br>const List = r => require.ensure([], () => r(require('@/components/list')), 'list');<br>// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 <br>const router = new Router({<br>  routes: [<br>  {<br>    path: '/list',<br>    component: List,<br>    name: 'list'<br>  }<br> ]<br>}))<br></code></pre>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014896,
    "title": "2. 路由的hash和history模式的区别",
    "content": "<strong>回答：</strong><br><br>Vue Router 的 hash 模式和 history 模式是两种路由实现方式，核心区别如下：hash 模式 URL 带 # （如 #/home ），监听window.onhashchange事件，history 模式 URL 与普通网页一致（如 /home ），调用history.pushState()并监听popstate事件<br><br>Vue-Router有两种模式：<strong>hash模式</strong>和<strong>history模式</strong>。默认的路由模式是hash模式。<br><br>![img](https://secure2.wostatic.cn/static/a9oSbhQogHXp7NHwqwPe1F/image.png)<br><br><h4>1. hash模式</h4><br><br><strong>简介：</strong> hash模式是开发中默认的模式，它的URL带着一个#，例如：[http://www.abc.com/#/vue，它的hash值就是](http://www.abc.com/#/vue，它的hash值就是<code>#/vue</code>。)[<code>#/vue</code>](http://www.abc.com/#/vue，它的hash值就是<code>#/vue</code>。)[。](http://www.abc.com/#/vue，它的hash值就是<code>#/vue</code>。)<br><br><strong>特点</strong>：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。<br><br><strong>原理：</strong> hash模式的主要原理就是<strong>onhashchange()事件</strong>：<br><br><pre><code class=\"language-JavaScript\">window.onhashchange = function(event){<br>  console.log(event.oldURL, event.newURL);<br>  let hash = location.hash.slice(1);<br>}<br></code></pre><br><br>使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。<br><br><h4>2. history模式</h4><br><br><strong>简介：</strong> history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。<br><br><strong>特点：</strong> 当使用history模式时，URL就像这样：http://abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。<br><br><strong>API：</strong> history api可以分为两大部分，切换历史状态和修改历史状态：<br><br><li><strong>修改历史状态</strong>：包括了 HTML5 History Interface 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。</li><br><li><strong>切换历史状态：</strong> 包括<code>forward()</code>、<code>back()</code>、<code>go()</code>三个方法，对应浏览器的前进，后退，跳转操作。</li><br><br>虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。<br><br>如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：<br><br><pre><code class=\"language-JavaScript\">const router = new VueRouter({<br>  mode: 'history',<br>  routes: [...]<br>})<br></code></pre><br><br><h4>3. 两种模式对比</h4><br><br>调用 history.pushState() 相比于直接修改 hash，存在以下优势:<br><br><li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li><br><li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li><br><li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li><br><li>pushState() 可额外设置 title 属性供后续使用。</li><br><li>hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。</li><br><br>hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014897,
    "title": "3. 如何获取页面的hash变化",
    "content": "<strong>（1）监听$route的变化</strong><br><br><pre><code class=\"language-JavaScript\">// 监听,当路由发生变化的时候执行<br>watch: {<br>  $route: {<br>    handler: function(val, oldVal){<br>      console.log(val);<br>    },<br>    // 深度观察监听<br>    deep: true<br>  }<br>},<br></code></pre><br><br><strong>（2）window.location.hash读取#值</strong><br><br>window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014898,
    "title": "4. route和router 的区别",
    "content": "<li>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</li><br><li>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014899,
    "title": "如何定义动态路由？如何获取传过来的动态参数？",
    "content": "<strong>（1）param方式</strong><br><br><li>配置路由格式：<code>/router/:id</code></li><br><li>传递的方式：在path后面跟上对应的值</li><br><li>传递后形成的路径：<code>/router/123</code></li><br><br>1）路由定义<br><br><pre><code class=\"language-JavaScript\">//在APP.vue中<br><router-link :to=\"'/user/'+userId\" replace>用户</router-link>    <br><br>//在index.js<br>{<br>   path: '/user/:userid',<br>   component: User,<br>},<br></code></pre><br><br>2）路由跳转<br><br><pre><code class=\"language-JavaScript\">// 方法1：<br><router-link :to=\"{ name: 'users', params: { uname: wade }}\">按钮</router-link<br><br>// 方法2：<br>this.$router.push({name:'users',params:{uname:wade}})<br><br>// 方法3：<br>this.$router.push('/user/' + wade)<br></code></pre><br><br>3）参数获取<br><br>通过 <code>$route.params.userid</code> 获取传递的值<br><br><strong>（2）query方式</strong><br><br><li>配置路由格式：<code>/router</code>，也就是普通配置</li><br><li>传递的方式：对象中使用query的key作为传递方式</li><br><li>传递后形成的路径：<code>/route?id=123</code></li><br><br>1）路由定义<br><br><pre><code class=\"language-JavaScript\">//方式1：直接在router-link 标签上以对象的形式<br><router-link :to=\"{path:'/profile',query:{name:'why',age:28,height:188}}\">档案</router-link><br><br>// 方式2：写成按钮以点击事件形式<br><button @click='profileClick'>我的</button>    <br><br>profileClick(){<br>  this.$router.push({<br>    path: \"/profile\",<br>    query: {<br>        name: \"kobi\",<br>        age: \"28\",<br>        height: 198<br>    }<br>  });<br>}<br></code></pre><br><br>2）跳转方法<br><br><pre><code class=\"language-JavaScript\">// 方法1：<br><router-link :to=\"{ name: 'users', query: { uname: james }}\">按钮</router-link><br><br>// 方法2：<br>this.$router.push({ name: 'users', query:{ uname:james }})<br><br>// 方法3：<br><router-link :to=\"{ path: '/user', query: { uname:james }}\">按钮</router-link><br><br>// 方法4：<br>this.$router.push({ path: '/user', query:{ uname:james }})<br><br>// 方法5：<br>this.$router.push('/user?uname=' + jsmes)<br></code></pre><br><br>3）获取参数<br><br><pre><code class=\"language-JavaScript\">通过$route.query 获取传递的值<br></code></pre>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014900,
    "title": "Vue-router 路由钩子在生命周期的体现",
    "content": "一、Vue-Router导航守卫<br><br>有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。<br><br>为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的<br><br>1. 全局路由钩子<br><br>全局有三个路由钩子;<br><br><li>router.beforeEach 全局前置守卫 进入路由之前</li><br><li>router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用</li><br><li>router.afterEach 全局后置钩子 进入路由之后</li><br><br>具体使用∶<br><br><li>beforeEach（判断是否登录了，没登录就跳转到登录页）</li><br><br><pre><code class=\"language-JavaScript\">router.beforeEach((to, from, next) => {  <br>    let ifInfo = Vue.prototype.$common.getSession('userData');  // 判断是否登录的存储信息<br>    if (!ifInfo) { <br>        // sessionStorage里没有储存user信息    <br>        if (to.path == '/') { <br>            //如果是登录页面路径，就直接next()      <br>            next();    <br>        } else { <br>            //不然就跳转到登录      <br>            Message.warning(\"请重新登录！\");     <br>            window.location.href = Vue.prototype.$loginUrl;    <br>        }  <br>    } else {    <br>        return next();  <br>    }<br>})<br></code></pre><br><br><li>afterEach （跳转之后滚动条回到顶部）</li><br><br><pre><code class=\"language-JavaScript\">router.afterEach((to, from) => {  <br>    // 跳转之后滚动条回到顶部  <br>    window.scrollTo(0,0);<br>});<br></code></pre><br><br>1. 单个路由独享钩子<br><br><strong>beforeEnter</strong><br><br>如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next<br><br><pre><code class=\"language-JavaScript\">export default [    <br>    {        <br>        path: '/',        <br>        name: 'login',        <br>        component: login,        <br>        beforeEnter: (to, from, next) => {          <br>            console.log('即将进入登录页面')          <br>            next()        <br>        }    <br>    }<br>]<br></code></pre><br><br>1. 组件内钩子<br><br>beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave<br><br>这三个钩子都有三个参数∶to、from、next<br><br><li>beforeRouteEnter∶ 进入组件前触发</li><br><li>beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用</li><br><li>beforeRouteLeave∶ 离开组件被调用</li><br><br>注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：<br><br><pre><code class=\"language-JavaScript\">beforeRouteEnter(to, from, next) {      <br>    next(target => {        <br>        if (from.path == '/classProcess') {          <br>            target.isFromProcess = true        <br>        }      <br>    })    <br>}<br></code></pre><br><br>二、Vue路由钩子在生命周期函数的体现<br><br>1. 完整的路由导航解析流程（不包括其他生命周期）<br><br><li>触发进入其他路由。</li><br><li>调用要离开路由的组件守卫beforeRouteLeave</li><br><li>调用局前置守卫∶ beforeEach</li><br><li>在重用的组件里调用 beforeRouteUpdate</li><br><li>调用路由独享守卫 beforeEnter。</li><br><li>解析异步路由组件。</li><br><li>在将要进入的路由组件中调用 beforeRouteEnter</li><br><li>调用全局解析守卫 beforeResolve</li><br><li>导航被确认。</li><br><li>调用全局后置钩子的 afterEach 钩子。</li><br><li>触发DOM更新（mounted）。</li><br><li>执行beforeRouteEnter 守卫中传给 next 的回调函数</li><br><br>1. 触发钩子的完整顺序<br><br>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶<br><br><li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li><br><li>beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li><br><li>beforeEnter：路由独享守卫</li><br><li>beforeRouteEnter：路由组件的组件进入路由前钩子。</li><br><li>beforeResolve：路由全局解析守卫</li><br><li>afterEach：路由全局后置钩子</li><br><li>beforeCreate：组件生命周期，不能访问tAis。</li><br><li>created;组件生命周期，可以访问tAis，不能访问dom。</li><br><li>beforeMount：组件生命周期</li><br><li>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li><br><li>mounted：访问/操作dom。</li><br><li>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li><br><li>执行beforeRouteEnter回调函数next。</li><br><br>1. 导航行为被触发到导航完成的整个过程<br><br><li>导航行为被触发，此时导航未被确认。</li><br><li>在失活的组件里调用离开守卫 beforeRouteLeave。</li><br><li>调用全局的 beforeEach守卫。</li><br><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><br><li>在路由配置里调用 beforeEnteY。</li><br><li>解析异步路由组件（如果有）。</li><br><li>在被激活的组件里调用 beforeRouteEnter。</li><br><li>调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li><br><li>导航被确认。</li><br><li>调用全局的 afterEach 钩子。</li><br><li>非重用组件，开始组件实例的生命周期：beforeCreate&created、beforeMount&mounted</li><br><li>触发 DOM 更新。</li><br><li>用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li><br><li>导航完成</li>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014901,
    "title": "Vue-router跳转和location.href有什么区别",
    "content": "Vue-router 是专为 Vue 单页应用设计的 前端路由解决方案 ，核心优势是无刷新跳转和完整的路由管理能力；使用了 <code>diff</code> 算法，实现了按需加载，减少了 dom 的消耗，而 location.href 来跳转，简单方便，但是刷新了页面；<br><br><li>使用 <code>location.href= /url </code>来跳转，简单方便，但是刷新了页面；</li><br><li>使用 <code>history.pushState( /url )</code> ，无刷新页面，静态跳转；</li><br><li>引进 router ，然后使用 <code>router.push( /url )</code> 来跳转，使用了 <code>diff</code> 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 <code>history.pushState()</code> 没什么差别的，因为vue-router就是用了 <code>history.pushState()</code> ，尤其是在history模式下。</li>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014902,
    "title": "8. params和query的区别",
    "content": "<strong>回答：</strong><br><br>Vue Router 中 params 和 query 是两种参数传递方式，核心区别体现在： params 作为路由路径的一部分（如 /user/123 ），需在路由配置的 path 中用 : 定义动态占位符（如 /user/:id ），是动态路由的必填项，若通过非路径方式传递则刷新页面后参数会丢失； query 作为 URL 查询参数（如 /user?id=123&name=张三 ），无需在路由 path 中定义，可直接在跳转时附加，所有参数刷新页面后会保留。<br><br><strong>用法</strong>：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 <code>this.$route.query.name</code> 和 <code>this.$route.params.name</code> 。<br><br><strong>url地址显示</strong>：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示<br><br><strong>注意</strong>：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014903,
    "title": "Vue-router 导航守卫有哪些",
    "content": "<li>全局前置/钩子：beforeEach、beforeResolve、afterEach</li><br><li>路由独享的守卫：beforeEnter</li><br><li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014904,
    "title": "10. 对前端路由的理解",
    "content": "<strong>回答：</strong><br><br>前端路由的本质是 URL与前端视图的映射关系管理 ，通过拦截URL变化并由前端控制视图切换，实现了SPA的流畅导航体验。其核心价值在于提升用户体验、优化性能，并成为现代前端框架生态中不可或缺的一部分。<br><br>在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。<br><br>后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 <strong>SPA（单页面应用</strong>）。<br><br>SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：<br><br><li>SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。</li><br><li>由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息</li><br><br>为了解决这个问题，前端路由出现了。<br><br>前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。<br><br>那么如何实现这个目的呢？首先要解决两个问题：<br><br><li>当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。</li><br><li>单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？</li><br><br>从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：<br><br><li>拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。</li><br><li>感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。</li><br><br><h2>五、Vuex</h2>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014905,
    "title": "1. Vuex 的原理",
    "content": "<strong>回答：</strong><br><br>Vuex 是 Vue 官方的集中式状态管理库，通过单一数据源统一存储共享状态，严格要求组件通过 Mutation 同步修改、Action 异步处理，实现了状态变化的更新。<br><br><strong>解析：</strong><br><br>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。<br><br><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><br><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。</li><br><br>![img](https://secure2.wostatic.cn/static/7SoeLrkm7iRd9zekpoYWCr/image.png)<br><br>Vuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。<br><br><strong>（1）核心流程中的主要功能：</strong><br><br><li>Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;</li><br><li>在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;</li><br><li>然后 Mutations 就去改变（Mutate）State 中的数据;</li><br><li>当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。</li><br><br><strong>（2）各模块在核心流程中的主要功能：</strong><br><br><li><code>Vue Components</code>∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li><br><li><code>dispatch</code>∶操作行为触发方法，是唯一能执行action的方法。</li><br><li><code>actions</code>∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li><br><li><code>commit</code>∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li><br><li><code>mutations</code>∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li><br><li><code>state</code>∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li><br><li><code>getters</code>∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li><br><br><strong>总结：</strong><br><br>Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据 State 的变化，渲染到视图上。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014906,
    "title": "2. Vuex中action和mutation的区别",
    "content": "<strong>回答：</strong><br><br>Vuex 中 action 和 mutation 的核心区别在于： mutation 是修改 State 的唯一方法，必须为同步函数，通过 commit 触发并直接修改 State，确保状态变化可追踪； action 专门处理异步逻辑，不能直接修改 State，需在异步操作完成后提交 mutation 更新状态。<br><br><strong>解析：</strong><br><br>mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：<br><br><pre><code class=\"language-JavaScript\">const store = new Vuex.Store({<br>  state: {<br>    count: 1<br>  },<br>  mutations: {<br>    increment (state) {<br>      state.count++      // 变更状态<br>    }<br>  }<br>})<br></code></pre><br><br>当触发一个类型为 increment 的 mutation 时，需要调用此函数：<br><br><pre><code class=\"language-JavaScript\">store.commit('increment')<br></code></pre><br><br>而Action类似于mutation，不同点在于：<br><br><li>Action 可以包含任意异步操作。</li><br><li>Action 提交的是 mutation，而不是直接变更状态。</li><br><br><pre><code class=\"language-JavaScript\">const store = new Vuex.Store({<br>  state: {<br>    count: 0<br>  },<br>  mutations: {<br>    increment (state) {<br>      state.count++<br>    }<br>  },<br>  actions: {<br>    increment (context) {<br>      context.commit('increment')<br>    }<br>  }<br>})<br></code></pre><br><br>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。<br><br>所以，两者的不同点如下：<br><br><li>Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。</li><br><li>Mutation：必须同步执行；Action：可以异步，但不能直接操作State。</li><br><li>在视图更新时，先触发actions，actions再触发mutation</li><br><li>mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014907,
    "title": "3. Vuex 和 localStorage 的区别",
    "content": "<strong>回答：</strong><br><br>Vuex 是 Vue 应用的内存状态管理工具，数据随页面刷新丢失，支持响应式更新组件，用于管理运行时共享状态；localStorage 是浏览器的持久化本地存储 API，数据持久保存，不支持响应式<br><br><strong>解析：</strong><br><br><strong>（1）最重要的区别</strong><br><br><li>vuex存储在内存中</li><br><li>localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快</li><br><br><strong>（2）应用场景</strong><br><br><li>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。</li><br><li>localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。</li><br><li>Vuex能做到数据的响应式，localstorage不能</li><br><br><strong>（3）永久性</strong><br><br>刷新页面时vuex存储的值会丢失，localstorage不会。<br><br><strong>注意：</strong> 对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014908,
    "title": "4. Redux 和 Vuex 有什么区别，它们的共同思想",
    "content": "<strong>（1）Redux 和 Vuex区别</strong><br><br><li>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可</li><br><li>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</li><br><li>Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）</li><br><br>通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;<br><br><strong>（2）共同思想</strong><br><br><li>单—的数据源</li><br><li>变化可以预测</li><br><br>本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案;<br><br>形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014909,
    "title": "5. 为什么要用 Vuex 或者 Redux",
    "content": "<strong>回答：</strong><br><br>组件多层嵌套时传参繁琐，兄弟组件间状态传递困难；当前通过父子组件引用或事件同步状态的方式脆弱，易导致代码难以维护。<br><br>解决方案：将共享状态抽取为全局单例管理，使组件树中任何位置的组件都能获取状态或触发行为；通过明确状态管理规则，让代码更结构化、易维护。<br><br>由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。<br><br>所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的\"视图\"，不管在树的哪个位置，任何组件都能获取状态或者触发行为。<br><br>另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014910,
    "title": "6. Vuex有哪几种属性？",
    "content": "有五种，分别是 State、 Getter、Mutation 、Action、 Module<br><br><li>state => 基本数据(数据源存放地)</li><br><li>getters => 计算属性，用于派生出新的状态</li><br><li>mutations => 同步修改状态的唯一途径</li><br><li>actions => 处理异步操作，通过提交 mutation 修改状态</li><br><li>modules => 模块化Vuex</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014911,
    "title": "Vuex和单纯的全局对象有什么区别？",
    "content": "<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><br><li>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014912,
    "title": "为什么 Vuex 的 mutation 中不能做异步操作？",
    "content": "<strong>回答：</strong><br><br>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，<br><br>如果mutation支持异步操作，就没有办法知道状态是何时更新的。<br><br><li>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li><br><li>每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</li>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014913,
    "title": "Vuex的严格模式是什么,有什么作用，如何开启？",
    "content": "在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。<br><br>在Vuex.Store 构造器选项中开启,如下<br><br><pre><code class=\"language-text\">const store = new Vuex.Store({<br>    strict:true,<br>})<br></code></pre>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014914,
    "title": "如何在组件中批量使用Vuex的getter属性",
    "content": "使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中<br><br><pre><code class=\"language-JavaScript\">import {mapGetters} from 'vuex'<br>export default{<br>    computed:{<br>        ...mapGetters(['total','discountTotal'])<br>    }<br>}0<br></code></pre>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014915,
    "title": "如何在组件中重复使用Vuex的mutation",
    "content": "使用mapMutations辅助函数,在组件中这么使用<br><br><pre><code class=\"language-JavaScript\">import { mapMutations } from 'vuex'<br>methods:{<br>    ...mapMutations({<br>        setNumber:'SET_NUMBER',<br>    })<br>}<br></code></pre><br><br>然后调用<code>this.setNumber(10)</code>相当调用<code>this.$store.commit('SET_NUMBER',10)</code><br><br><h2>六、Vue 3.0</h2>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014917,
    "title": "1. Vue3.0有什么更新",
    "content": "<strong>回答：</strong><br><br>Vue3.0通过将监测机制从Object.defineProperty改为基于Proxy的observer实现，解决了Vue2中无法检测属性添加删除、数组索引长度变更以及不支持Map、Set等数据结构的限制；在模板方面，将作用域插槽改为函数方式，只影响子组件重新渲染从而提升性能；组件声明方式从选项式改为类式写法，使与TypeScript的结合更加容易；同时支持自定义渲染器、Fragment多根节点和Portal组件，并通过tree shaking优化提供更多内置功能，整体上在性能、开发体验和扩展性方面都有显著提升。<br><br><strong>（1）监测机制的改变</strong><br><br><li>3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。</li><br><li>消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</li><br><br><strong>（2）只能监测属性，不能监测对象</strong><br><br><li>检测属性的添加和删除；</li><br><li>检测数组索引和长度的变更；</li><br><li>支持 Map、Set、WeakMap 和 WeakSet。</li><br><br><strong>（3）模板</strong><br><br><li>作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</li><br><li>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</li><br><br><strong>（4）对象式的组件声明方式</strong><br><br><li>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。</li><br><li>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易</li><br><br><strong>（5）其它方面的更改</strong><br><br><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><br><li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><br><li>基于 tree shaking 优化，提供了更多的内置功能。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014918,
    "title": "2. defineProperty和proxy的区别",
    "content": "<strong>回答：</strong><br><br>Vue2通过Object.defineProperty将data属性转为getter/setter实现响应式，但无法检测对象属性增删和数组索引长度变化；Vue3改用Proxy直接代理整个对象，解决了上述限制，能监听所有属性变化包括新增删除，并支持数组变化监听，响应式能力更全面。<br><br>Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。<br><br>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。<br><br>但是这样做有以下问题：<br><br>1. 添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过<code>$set</code> 来调用<code>Object.defineProperty()</code>处理。<br>2. 无法监控到数组下标和长度的变化。<br><br>Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于<code>Object.defineProperty()</code>，其有以下特点：<br><br>1. Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。<br>2. Proxy 可以监听数组的变化。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014919,
    "title": "3. Vue3.0 为什么要用 proxy？",
    "content": "<strong>回答：</strong><br><br>Vue2的Object.defineProperty会改变原始数据，而Proxy通过创建对象的虚拟表示并提供处理器拦截属性访问和修改，实现了无需set/set/set/delete、全方位数组变化检测、支持Map/Set等数据结构；Proxy的响应式原理与Vue2相同，都是通过get收集依赖、set/delete触发依赖，对集合类型则包装方法执行依赖收集或触发逻辑。<br><br>在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶<br><br>![img](https://secure2.wostatic.cn/static/hw5ugfP3ZUmdA5uzndvFin/image.png)<br><br><li>不需用使用 <code>Vue.$set</code> 或 <code>Vue.$delete</code> 触发响应式。</li><br><li>全方位的数组变化检测，消除了Vue2 无效的边界情况。</li><br><li>支持 Map，Set，WeakMap 和 WeakSet。</li><br><br>Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶<br><br><li>get 收集依赖</li><br><li>Set、delete 等触发依赖</li><br><li>对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014920,
    "title": "Vue 3.0 中的 Vue Composition API？",
    "content": "<strong>回答：</strong><br><br>Vue2的Options API通过data、methods、computed等属性填充组件，虽然容易上手但存在代码复用困难、过度依赖this上下文、TypeScript支持不佳等问题；Vue3改用Composition API，将底层机制暴露给用户直接使用，提供了更大的灵活性和更好的TypeScript支持。<br><br>在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：<br><br>![img](https://secure2.wostatic.cn/static/7zTdmTp4bnNCSh2V4qpi6G/image.png)<br><br>1. 由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。<br>2. Vue 组件过于依赖<code>this</code>上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在<code>methods</code> 中的<code>this</code>竟然指向组件实例来不指向<code>methods</code>所在的对象。这也使得 TypeScript 在Vue2 中很不好用。<br><br>于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。<br><br>如下，是一个使用了 Vue Composition API 的 Vue3 组件：<br><br><pre><code class=\"language-JavaScript\"><template><br>  <button @click=\"increment\"><br>    Count: {{ count }}<br>  </button><br></template><br> <br><script><br>// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数<br>import { ref, computed, onMounted } from 'vue'<br> <br>export default {<br>  setup() {<br>// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数<br>    const count = ref(0)<br> <br>// Vue2中需要在methods option中声明的函数，现在直接声明<br>    function increment() {<br>      count.value++<br>    }<br> // 对应于Vue2中的mounted声明周期<br>    onMounted(() => console.log('component mounted!'))<br> <br>    return {<br>      count,<br>      increment<br>    }<br>  }<br>}<br></script><br></code></pre><br><br>显而易见，Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014921,
    "title": "Composition API与React Hook很像，区别是什么",
    "content": "从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制<br><br><li>不能在循环、条件、嵌套函数中调用Hook</li><br><li>必须确保总是在你的React函数的顶层调用Hook</li><br><li>useEffect、useMemo等函数必须手动确定依赖关系</li><br><br>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比<br><br><li>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</li><br><li>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</li><br><li>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</li><br><br>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014922,
    "title": "6、Vue2和Vue3的区别有哪些？",
    "content": "<strong>回答：</strong><br><br>![img](https://secure2.wostatic.cn/static/aTfxYqKdgZ9XkV7RwYEoLA/image.png)<br><br>1. 响应式系统<br><br>   ：<br><br>   - <strong>Vue 2</strong>：基于Object.defineProperty，无法自动检测<strong>对象属性的添加/删除</strong>和<strong>数组索引变化</strong>，需借助Vue.set/Vue.delete等特殊 API。<br>   - <strong>Vue 3</strong>：基于Proxy，<strong>原生支持</strong>对对象和数组的各种变化监听，无上述限制，性能更优。<br><br>2. API 设计<br><br>   ：<br><br>   - <strong>Vue 2 (Options API)</strong>：按选项（data,methods等）组织代码，逻辑分散。复用代码使用<strong>Mixins</strong>，容易引发命名冲突。<br>   - <strong>Vue 3 (Composition API)</strong>：按<strong>逻辑功能</strong>组织代码，相关代码集中，更利于维护和阅读。复用代码使用<strong>自定义 Hook 函数</strong>，清晰灵活，且<strong>原生 TypeScript 支持极佳</strong>。<br><br>3. 性能与编译器<br><br>   ：<br><br>   - Vue 3<br><br>     在编译阶段进行了大量优化：<br><br>     - <strong>Tree-shaking</strong>：未使用的 API 不会打包进最终产物，体积更小。<br>     - <strong>Patch Flags</strong>：编译时标记动态节点，Diff 算法时直接定位变化，大幅提升虚拟 DOM 比对效率。<br>     - <strong>静态提升</strong>：将静态节点缓存，跳过重复渲染。<br><br>   - 结果：Vue 3 在<strong>打包体积、更新性能、内存占用</strong>上均优于 Vue 2。<br><br>4. 新特性<br><br>   ：<br><br>   - <strong>Vue 3</strong>新增了<strong>Teleport</strong>（将组件渲染到指定DOM）、<strong>Fragment</strong>（支持多根节点模板）等特性，解决了常见开发痛点。",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014923,
    "title": "7、watch和watchEffect有什么区别？",
    "content": "<li>watch</li><br><br><pre><code class=\"language-TypeScript\">const todoId = ref(1)<br>const data = ref(null)<br><br>watch(<br>  todoId,<br>  async () => {<br>    const response = await fetch(<br>      <code>https://jsonplaceholder.typicode.com/todos/${todoId.value}</code><br>    )<br>    data.value = await response.json()<br>  },<br>  { immediate: true }<br>)<br></code></pre><br><br><li>watchEffect</li><br><br><pre><code class=\"language-JavaScript\">watchEffect(async () => {<br>  const response = await fetch(<br>    <code>https://jsonplaceholder.typicode.com/todos/${todoId.value}</code><br>  )<br>  data.value = await response.json()<br>})<br></code></pre><br><br><li>区别：</li><br>  - watch需要指明侦听的数据，watchEffect不需要；<br>  - 对于这种只有一个依赖项的例子来说，<code>watchEffect()</code> 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 <code>watchEffect()</code> 可以消除手动维护依赖列表的负担；<br>  - 如果你需要侦听一个嵌套数据结构中的几个属性，<code>watchEffect()</code> 可能会比深度侦听器更有效，因为它将<strong>只跟踪回调中被使用到</strong>的属性，而<strong>不是递归地跟踪所有</strong>的属性。",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014924,
    "title": "8、怎么停止侦听器",
    "content": "在 <code>setup()</code> 或 <code><script setup></code> 中用<strong>同步</strong>语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。<br><br>如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。<br><br><pre><code class=\"language-Vue\"><template><br>  <div><br>    <h3>人物描述</h3><br>    <ul><br>      <li v-for=\"(item, index) in userInfo\" :key=\"item\">{{ index }}：{{ item }}</li><br>      <li>更新时间：{{ currentTime }}</li><br>    </ul><br>    <el-button @click=\"changeInfo('age')\">改变年龄</el-button><br>    <el-button @click=\"stopWatch\">停止监听</el-button><br>  </div><br></template><br><br><script setup lang=\"ts\"><br>interface UserInfo {<br>  name: string;<br>  age: number;<br>  info: string;<br>  gender: '男' | '女';<br>}<br>const userInfo = ref<UserInfo>({ name: '昔冰', age: 27, info: '是个人', gender: '男' });<br>const changeInfo = (attr: string) => {<br>  if (attr === 'age') userInfo.value.age++;<br>};<br>const currentTime = ref<string>(new Date().toLocaleTimeString());<br><br>// 异步创建的需要手动停止监听<br>let unwatch: Function;<br>setTimeout(() => {<br>  unwatch = watchEffect(() => {<br>    if (userInfo.value.age > 27) currentTime.value = new Date().toLocaleTimeString();<br>  });<br>}, 1000);<br><br>// 按钮停止测试<br>const stopWatch = () => {<br>  unwatch();<br>};<br><br>// 卸载前停止<br>onBeforeUnmount(()=>{<br>  unwatch()<br>})<br></script><br><br><style scoped lang=\"less\"></style><br></code></pre><br><br><h2>七、虚拟DOM</h2>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014925,
    "title": "1. 对虚拟DOM的理解？",
    "content": "<strong>回答：</strong><br><br>虚拟DOM是JavaScript对象，通过对象方式表示DOM结构，实现跨平台渲染；通过事务处理机制和diff算法比较新旧虚拟DOM，只渲染变化部分，减少DOM操作次数提高性能；作为轻量级DOM抽象，无需手动操作DOM，既保证性能又提升开发效率。<br><br><strong>解析：</strong><br><br>从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。<br><br>虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。<br><br>另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014926,
    "title": "2. 虚拟DOM的解析过程",
    "content": "<strong>回答：</strong><br><br>先对将要插入的DOM树结构分析使用js对象树将其表示出来然后保存起来，最后将DOM片段插入文档，当页面状态发生改变，需要对页面的DOM结构进行调整，根据变更的状态重新构建一棵对象树，新的对象树跟旧的对象树进行对比记入差异，最后将有差异的地方应用到真正的 DOM 树中，视图就更新了<br><br>虚拟DOM的解析过程：<br><br><li>首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</li><br><li>当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</li><br><li>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014927,
    "title": "为什么要用虚拟DOM",
    "content": "<strong>回答：</strong><br><br>保证性能下限 ：通过JS层面的vNode生成和DOMDiff算法，相比真实DOM的HTML字符串重建和元素重建，JS操作成本更低，框架保证在无需手动优化情况下仍能提供良好性能。<br><br><strong>（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能</strong><br><br>看一下页面渲染的流程：<strong>解析HTML -> 生成DOM</strong> <strong>-></strong> <strong>生成 CSSOM</strong> <strong>-></strong> <strong>Layout</strong> <strong>-></strong> <strong>Paint</strong> <strong>-></strong> <strong>Compiler</strong><br><br>下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶<br><br><li>真实DOM∶ 生成HTML字符串＋重建所有的DOM元素</li><br><li>虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新</li><br><br>Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。<br><br><strong>（2）跨平台</strong><br><br>Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014928,
    "title": "4. 虚拟DOM真的比真实DOM性能好吗",
    "content": "<li>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</li><br><li>正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014929,
    "title": "5. DIFF算法的原理",
    "content": "<strong>回答：</strong><br><br>先判断节点本身是否为同一节点，不是则删除节点重新创建节点替换，相同节点就进行patchVnode，<br><br>![img](https://secure2.wostatic.cn/static/ogS55sLVtUgQardcaNhv6Z/image.png)<br><br>在新老虚拟DOM对比时：<br><br><li>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li><br><li>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li><br><li>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li><br><li>匹配时，找到相同的子节点，递归比较子节点</li><br><br>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014930,
    "title": "6. Vue中key的作用",
    "content": "<strong>回答：</strong><br><br>Vue中key值是vnode的唯一标识，在v-if场景中阻止元素复用，确保切换时重新渲染避免状态残留；在v-for场景中帮助跟踪元素身份，当数据顺序变化时正确移动DOM元素；通过key的唯一性，diff算法可以更准确地避免就地复用，更快速地通过map对象查找节点，从而实现高效的虚拟DOM更新。<br><br>vue 中 key 值的作用可以分为两种情况来考虑：<br><br><li>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</li><br><li>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</li><br><br>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速<br><br><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。</li><br><li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li>",
    "categoryId": "1768000001007",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104014932,
    "title": "为什么不建议用index作为key?",
    "content": "<strong>回答：</strong><br><br>使用index作为key会导致Vue复用错误节点增加额外工作，watch选项中immediate组件加载立即触发、deep深度监听复杂数据类型内部变化，Teleport组件通过to prop将模板片段传送到指定位置如body标签下，Vue3中v-model拆解为绑定modelValue属性和注册update:modelValue事件，响应式系统使用Proxy替代Object.defineProperty实现更高效的侦听触发机制，解决了Vue2中无法通过索引修改数组触发更新和无法自动监听对象新增属性的问题，无需像Vue2那样使用$set手动处理。<br><br>使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。<br><br><li>immediate：组件加载立即触发回调函数</li><br><li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li><br><br><code><Teleport></code> 接收一个 <code>to</code> prop 来指定传送的目标。<code>to</code> 的值可以是一个 CSS 选择器字符串，也可以是一个 DOM 元素对象。这段代码的作用就是告诉 Vue把Teleport中的模板片段<strong>传送到 </strong><strong><code>body</code></strong> 标签下。<br><br><li>Vue3中可拆解为：</li><br>  - 绑定modleValue属性<br>  - 注册update:modelValue事件<br><li>在 Vue 3 中，其中的核心概念是响应式<strong>代理对象</strong>。Vue 3 使用了 ES2015 的 <code>Proxy</code> 对象代替 <code>Object.defineProperty</code>，使得响应式系统更加灵活和高效。利用 ES6 Proxy 实现了更高效的侦听和触发机制，避免了 Vue 2 中响应式系统的一些性能瓶颈。</li><br><li>比如：Vue2中直接使用索引去修改数组的值后不会带动页面更新数据，但Vue3支持。</li><br><li>另外：在 Vue 2 中，使用 <code>Object.defineProperty</code> 实现的响应式系统对于对象的新增属性是没有监听的。因为 <code>Object.defineProperty</code> 只会在对象初始化时执行一次，后续对对象的新增属性不会被 Vue 响应式系统自动处理。如果还想要对新增的属性做响应式处理，需要使用 <code>Vue.set</code> 或 <code>this.$set</code> 方法来手动触发 Vue 的响应式系统，以便 Vue 能够追踪和响应新增属性的变化。</li>",
    "categoryId": "1768000001007",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:00:14.824Z",
    "updatedAt": "2026-01-11T04:00:14.824Z"
  },
  {
    "id": 1768104147564,
    "title": "1、小程序和vue有什么区别",
    "content": "<li>语法差异：Vue使用基于HTML的模板语法（即Vue模板），而小程序使用类似于HTML的WXML语法。</li><br><li>开发环境：Vue可以在浏览器中直接调试和运行，而小程序需要在微信开发者工具中进行预览和调试。</li><br><li>架构差异：Vue是一个完整的前端框架，可以用于构建SPA（单页应用）和MPA（多页应用），而小程序是微信提供的一种特殊的前端框架，用于构建微信小程序。</li><br><li>生态系统：Vue拥有更加成熟和庞大的生态系统，具有大量的第三方插件和库可供选择，而小程序的生态系统相对较小，但也有一些常用的插件可供使用。</li><br><li>跨平台能力：Vue可以通过使用框架如uni-app实现多端开发，可以开发Web、小程序、App等多种平台的应用；而小程序主要面向微信平台，不支持跨多个平台。</li>",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147565,
    "title": "2、uniapp和vue区别",
    "content": "<li>Uniapp是一款基于Vue.js框架的跨平台应用开发框架。它可以将同一份代码编译生成多个应用程序，包括iOS、Android、H5、小程序等；Vue是一个前端开发框架；</li><br><li>uni-app可以通过打包实现一套代码多端运行，而vue不行；</li><br><li>uni-app有自动的框架预载，加载页面的速度更快，vue没有；</li><br><li>uniapp使用小程序的标签，vue使用web端的标签；</li><br><li>uni不支持vue-router，使用自带的路由；</li>",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147566,
    "title": "3、uniapp跳转方式有哪些",
    "content": "<li>uni.navigateTo() 跳转路由或页面</li><br><li>uni.navigateBack() 方法返回原页面</li><br><li>uni.redirectTo() 关闭当前所有页面</li><br><li>uni.reLaunch() 关闭所有页面</li><br><li>uni.switchTab() 跳转到应用的底部导航栏页面</li>",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147567,
    "title": "4、如果客户需求从网页可以打开小程序，你会怎么做",
    "content": "1. 使用小程序二维码<br>    - 打开微信小程序的开发者工具，在左侧菜单中选择\"预览\"。<br>    - 在预览界面上方选择\"小程序二维码\"。<br>    - 将生成的小程序二维码保存为图片。<br>    - 在网页中将保存的小程序二维码图片插入到合适的位置<br>2. 使用小程序URL链接<br>    - 在微信小程序的开发者工具中，打开小程序，在左侧菜单中选择\"设置\"。<br>    - 在设置界面中选择\"基本设置\"。<br>    - 在基本设置中找到\"开发版\"、\"体验版\"或\"正式版\"的小程序链接。<br>    - 将链接复制到网页的合适位置，用户可以通过点击链接来启动微信小程序",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147568,
    "title": "5、uni-app和原生小程序有什么区别",
    "content": "1. 原生应用程序通常是使用平台特定的编程语言来编写的；<br>2. 因为原生应用程序是为特定平台编写的，所以它们在性能方面比uniapp要好得多；<br>3. 原生应用程序兼容性非常有限，需要编写特定平台的版本；",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147569,
    "title": "6、小程序生命周期",
    "content": "微信小程序的生命周期分为三个部分：应用级生命周期、页面级生命周期、组件的生命周期。<br><br>这里可能会问：从打开小程序到进入一个页面，应用及页面的生命周期执行顺序？<br><br>1. 应用生命周期<br>    - onLaunch: 初始化小程序完成时触发，且全局只触发一次；<br>    - onShow: 小程序初始化完成（启动）或从后台切换到前台显示时触发；<br>    - onHide: 小程序从前台切换到后台隐藏时触发（如切换到其他app中）；<br>    - onError: 小程序发生脚本错误或者api调用失败的时候，会触发 onError 并带上错误信息<br>2. 页面生命周期<br>    - onLoad : 页面加载时触发。一个页面只会调用一次，可以在 onLoad的参数中获取打开当前页面路径中的参数<br>    - onShow : 页面显示 / 切入前台时触发调用。<br>    - onReady : 页面初次渲染完成时触发,一个页面只会调用一次。<br>    - onHide : 页面隐藏 / 切入后台时触发，如 navigateTo 或底部 tab切换到其他页面，小程序切入后台<br>3. 组件的生命周期<br>    - 和 Vue 的生命周期钩子是一致",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147570,
    "title": "7、小程序有哪些传值的方法",
    "content": "1. 使用全局变量<br>    - 在 app.js 中的 this.globalData = { } 中放入要存储的数据。<br>    - 在 组件.js 中， 头部 引入 const app = getApp(); 获取到全局变量<br>    - 直接使用 app.globalData.key 来进行赋值和获取值。<br>2. 使用路由<br>    - wx.navigateTo 和 wx.redirectTo 时，可以通过在 url 后 拼接 + 变量， 然后在 目标页面 通过在 onLoad 周期中，通过参数来获取传递过来的值。<br>3. 使用本地缓存(本地存储)",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147571,
    "title": "8、wxss和css有什么区别",
    "content": "1. wxss 背景图片只能引入外链，不能使用本地图片<br>2. 小程序样式使用 @import 引入 外联样式文件，地址为相对路径。<br>3. 尺寸单位为 rpx , rpx 是响应式像素,可以根据屏幕宽度进行自适应",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147572,
    "title": "9、uniapp和原生小程序 分别使用什么方式来全局注册组件",
    "content": "1. <strong>uniapp全局注册组件</strong><br>    - 只要组件安装在项目的components目录下或<code>uni_modules</code>目录下，并符合<code>components/组件名称/组件名称.(vue|uvue)</code>目录结构（注意：当同时存在vue和uvue时，uni-app 项目优先使用 vue 文件，而uni-app x 项目优先使用 uvue 文件）。就可以不用引用、注册，直接在页面中使用。<br>    - 如果组件名称或路径不符合easycom的默认规范，可以在<code>pages.json</code>的<code>easycom</code>节点进行个性化设置。<br><br><pre><code class=\"language-JSON\">//位置 pages.json<br>{ <br>  \"easycom\": {<br>    \"autoscan\": true,<br>    \"custom\": {<br>      \"^mt-(.*)\": \"@/components/blog/mt-$1.vue\",<br>      \"GlobalComponent\": \"@/components/index.vue\"<br>    }<br>  }<br> }<br></code></pre><br>2. <strong>在app.json中注册组件</strong>: <br>    - 在<code>app.json</code>的<code>usingComponents</code>字段中指定组件的位置。<br><br><pre><code class=\"language-JavaScript\">{<br>  \"usingComponents\": {<br>    \"my-component\": \"path/to/my-component\"<br>  }<br>}<br></code></pre>",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147574,
    "title": "10、怎么解决小程序的异步请求问题（同其他项目）",
    "content": "1. 请求中返回一个Promise对象，可以使用Promise的then()方法来处理异步请求的结果；<br>2. 使用async/await：利用async/await语法糖，可以让异步请求更加简洁易读；",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147575,
    "title": "11、小程序打包上线流程",
    "content": "1. 在uni-app端完成微信小程序的打包；<br>2. 在微信开发者工具中将代码上传到微信公众平台，形成体验版；<br>3. 测试人员根据扫描体验版二维码进行最后的测试工作；<br>4. 测试通过后，点击提交审核，进入审核流程，通常24小时就能出结果；<br>5. 审核通过后，用户即可通过微信小程序搜索到我们的小程序；<br>6. 小程序存在的几个版本：开发版—>体验版—>审核版—>线上版",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147576,
    "title": "12、微信支付流程",
    "content": "1. 打开小程序，点击下单<br>2. wx.login获取用户临时登录凭证code，发送到后端服务器换取openId<br>3. 在下单时，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器<br>4. 服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息<br>5. 小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付<br>6. 接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付<br>7. 鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示<br>8. 推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147577,
    "title": "13、有用过uniapp打包过app吗",
    "content": "<li><strong>安卓</strong></li><br>    - HBuilder中菜单中依次点击【发行】-【原生App】<br>    - 填写应用信息->App名称和图标的设置方式等<br>    - 点击打包按钮，App开始编译, 随后进入排队等候状态，真正的打包工作将在DCloud的云端执行<br>    - 等待一段时间之后，打包完成，生成的APK路径在unpackage/release/apk路径下<br>    - 将这个APK文件传输至手机，就能够查看安装和运行效果了<br>    - 上述打包好的APK上传到各大电子市场，用户就可以下载使用了",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147578,
    "title": "14、小程序一键登录(小程序的微信授权流程)",
    "content": "1. 是什么<br>    - 用微信账号登录自家服务器<br>2. 具体步骤<br>    - 在小程序端wx.login()得到登录码code；<br>    - 小程序请求自家的登录接口，携带登录码code；<br>    - 自家服务器请求微信服务器，使用appid+appSecret+code换回session_key与openid；<br>    - 自家服务器将session_key与openid重新换算为自家的登录信息(如token)；<br>    - 小程序在后续请求自家服务器的过程中都携带该token，自家服务器就知道小程序端已经登录过了；",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147579,
    "title": "15、uniapp下拉刷新和上拉加载怎么做的",
    "content": "1. 下拉刷新<br>    - 通过<code><uni-scroll-view></code>组件的<code>downRefresh</code>事件来实现，当下拉触发该事件时，我们设置<code>isRefreshing</code>为true，此时显示刷新的状态。时间到达之后，我们再将<code>isRefreshing</code>设置为false，同时关闭<code>uni.stopPullDownRefresh()</code>；<br>2. 上拉加载<br>    - 通过<code><uni-scroll-view></code>组件中的<code>@scrolltolower</code>事件来实现上拉加载更多。当页面内容滑动到了底部时，我们调用<code>this.loadMore()</code>方法，该方法中我们可以加载更多的数据，让页面得到更新；",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147580,
    "title": "16、 uniapp拍照功能怎么做",
    "content": "1. 在需要使用相机拍照功能的页面中，添加一个按钮，用于触发相机拍照的动作；<br>2. 在Page配置中，引入<code>uniapp-camera</code>插件；<br>3. 在页面的methods中，添加takePhoto方法，用于触发相机拍照功能；<br>4. 添加data属性，用于保存拍照后的照片的地址；<br>5. 点击运行按钮来编译并运行这个uni-app项目；",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147581,
    "title": "17、 bindtap 和 catchtap 区别",
    "content": "1. 相同点： 都是点击事件<br>2. 不同点： <code>bindtap</code> 不会阻止冒泡， <code>catchtap</code> 可以阻止冒泡。",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147582,
    "title": "18、uniapp上传文件时用到api是什么",
    "content": "<li>uni.uploadFile</li><br><br>    https://uniapp.dcloud.net.cn/api/request/network-file.html#uploadfile<br><br><pre><code class=\"language-JavaScript\">uni.uploadFile({<br>   url: '要上传的地址',<br>   fileType:'image',<br>   filePath:'图片路径',<br>   name:'文件对应的key',<br>   success(res){<br>      console.log(res)<br>   }<br>})<br></code></pre>",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147583,
    "title": "19、⻚⾯⽣命周期的执行过程：",
    "content": "<li>⼩程序注册完成后，加载⻚⾯，触发onLoad⽅法</li><br><li>⻚⾯载⼊后触发onShow⽅法，显示⻚⾯</li><br><li>⾸次显示⻚⾯，会触发onReady⽅法，渲染⻚⾯元素和样式，⼀个⻚⾯只会调⽤⼀次</li><br><li>当⼩程序后台运⾏或跳转到其他⻚⾯时，触发onHide⽅法</li><br><li>当⼩程序有后台进⼊到前台运⾏或重新进⼊⻚⾯时，触发onShow⽅法</li><br><li>当使⽤重定向⽅法 wx.redirectTo() 或关闭当前⻚返回上⼀⻚wx.navigateBack()，触发onUnload</li>",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147584,
    "title": "20、当存在也应用生命周期和页面周期的时候执行顺序：",
    "content": "<li>打开小程序：(App)onLaunch --> (App)onShow --> (Pages)onLoad --> (Pages)onShow --> (pages)onRead</li><br><li>进入下一个页面：(Pages)onHide --> (Next)onLoad --> (Next)onShow --> (Next)onReady</li><br><li>返回上一个页面：(curr)onUnload --> (pre)onShow</li><br><li>离开小程序：(App)onHide</li><br><li>再次进入：小程序未销毁 --> (App)onShow(执行上面的顺序），小程序被销毁，（App)onLaunch重新开始执行.</li>",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147585,
    "title": "21、小程序的登录流程",
    "content": "传统的<code>web</code>开发实现登陆功能，一般的做法是输入账号密码、或者输入手机号及短信验证码进行登录<br><br>  服务端校验用户信息通过之后，下发一个代表登录态的 <code>token</code> 给客户端，以便进行后续的交互,每当<code>token</code>过期，用户都需要重新登录<br><br>  而在微信小程序中，可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系，从而实现登陆功能<br><br>  - 通过 wx.login() 获取到用户的code判断用户是否授权读取用户信息，调用wx.getUserInfo 读取用户数据；<br>  - 由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息；<br>  - 通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret 和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到；<br>  - 微信服务器返回了 openid 及本次登录的会话密钥 session_key；<br>  - 后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走；<br>  - session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输；<br>  - 然后生成 session并返回给小程序；<br>  - 小程序把 session 存到 storage 里面；<br>  - 下次请求时，先从 storage 里面读取，然后带给服务端；<br>  - 服务端对比 session 对应的记录，然后校验有效期；<br><br>![](https://secure2.wostatic.cn/static/btcDze66pJ42kRKZtgZbqV/1.png?auth_key=1768104088-9XhgonaRdkfBAmjWnZuFMM-0-44aee8d2228a83f962e6b8e14eb654bc)",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104147586,
    "title": "22、如何提高小程序的加载速度",
    "content": "1. 加载方面<br>    - 代码包的体积压缩可以通过勾选开发者工具中“上传代码时，压缩代码”选项；<br>    - 及时清理无用的代码和资源文件；<br>    - 减少资源包中的图片等资源的数量和大小（理论上除了小icon，其他图片资源从网络下载），图片资源压缩率有限；<br>    - 可以采取分包加载的操作，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载，当用户点击到子包的目录时，还是有一个代码包下载的过程，这会感觉到明显的卡顿，所以子包也不建议拆的太大，当然我们可以采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包；<br>2. 渲染方面<br>    - 请求可以在页面onLoad就加载，不需要等页面ready后在异步请求数据；<br>    - 尽量减少不必要的https请求，可使用 getStorageSync() 及 setStorageSync() 方法将数据存储在本地；<br>    - 可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据--> 详情页），没有数据的模块可以进行骨架屏的占位<br><br>    在微信小程序中，提高页面的多次渲染效率主要在于正确使用<code>setData</code>：<br><br>    - 不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用<br>    - 数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用<code>setData</code>来设置这些数据<br>    - 与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下<br><br>    除此之外，对于一些独立的模块我们尽可能抽离出来，这是因为自定义组件的更新并不会影响页面上其他元素的更新<br><br>    各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、<code>setData</code>调用",
    "categoryId": "1768000001008",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:02:27.554Z",
    "updatedAt": "2026-01-11T04:02:27.554Z"
  },
  {
    "id": 1768104268170,
    "title": "CDN的概念",
    "content": "CDN（Content Delivery Network，<strong>内容分发网络</strong>）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。<br><br>典型的CDN系统由下面三个部分组成：<br><br><li><strong>分发服务系统：</strong>最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标。</li><br><li><strong>负载均衡系统：</strong>主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。<strong>全局负载均衡</strong>主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。<strong>本地负载均衡</strong>主要负责节点内部的设备负载均衡</li><br><li><strong>运营管理系统：</strong>运营管理系统分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</li>",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268171,
    "title": "CDN的作用",
    "content": "CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。<br><br>（1）在性能方面，引入CDN的作用在于：<br><br><li>用户收到的内容来自最近的数据中心，延迟更低，内容加载更快</li><br><li>部分资源请求分配给了CDN，减少了服务器的负载</li><br><br>（2）在安全方面，CDN有助于防御DDoS、MITM等网络攻击：<br><br><li>针对DDoS：通过监控分析异常流量，限制其请求频率</li><br><li>针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信</li><br><br>除此之外，CDN作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268172,
    "title": "CDN的原理",
    "content": "CDN和DNS有着密不可分的联系，先来看一下DNS的解析域名过程，在浏览器输入 [www.test.com](http://www.test.com) 的解析过程如下：<br><br>（1） 检查浏览器缓存<br><br>（2）检查操作系统缓存，常见的如hosts文件<br><br>（3）检查路由器缓存<br><br>（4）如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询<br><br>（5）如果LDNS服务器没找到，会向根域名服务器(Root Server)请求解析，分为以下几步：<br><br><li>根服务器返回顶级域名(TLD)服务器如<code>.com</code>，<code>.cn</code>，<code>.org</code>等的地址，该例子中会返回<code>.com</code>的地址</li><br><li>接着向顶级域名服务器发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回<code>.test</code>的地址</li><br><li>接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标IP，本例子会返回<code>www.test.com</code>的地址</li><br><li>Local DNS Server会缓存结果，并返回给用户，缓存在系统中</li><br><br><strong>CDN的工作原理：</strong><br><br>（1）用户未使用CDN缓存资源的过程：<br><br>1. 浏览器通过DNS对域名进行解析（就是上面的DNS解析过程），依次得到此域名对应的IP地址<br>2. 浏览器根据得到的IP地址，向域名的服务主机发送数据请求<br>3. 服务器向浏览器返回响应数据<br><br>（2）用户使用CDN缓存资源的过程：<br><br>1. 对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。<br>2. CND专用DNS服务器将CND的全局负载均衡设备IP地址返回给用户<br>3. 用户向CDN的全局负载均衡设备发起数据请求<br>4. CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求<br>5. 区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备<br>6. 全局负载均衡设备把服务器的IP地址返回给用户<br>7. 用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。<br><br>如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。<br><br>![](https://secure2.wostatic.cn/static/iAZ7cw5xLiw56BE177Xhzk/image.png?auth_key=1768104181-aG9uaVbNJMvy6YRwDaaEjB-0-6fd7321a95a31d312fa8ba93935a7269)<br><br>CNAME（意为：别名）：在域名解析中，实际上解析出来的指定域名对应的IP地址，或者该域名的一个CNAME，然后再根据这个CNAME来查找对应的IP地址。",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268173,
    "title": "CDN的使用场景",
    "content": "<li><strong>使用第三方的CDN服务：</strong>如果想要开源一些项目，可以使用第三方的CDN服务</li><br><li><strong>使用CDN进行静态资源的缓存：</strong>将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。</li><br><li><strong>直播传送：</strong>直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。</li>",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268174,
    "title": "懒加载的概念",
    "content": "懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。<br><br>如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268175,
    "title": "懒加载的特点",
    "content": "<li><strong>减少无用资源的加载</strong>：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。</li><br><li><strong>提升用户体验</strong>: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。</li><br><li><strong>防止加载过多图片而影响其他资源文件的加载</strong> ：会影响网站应用的正常使用。</li>",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268176,
    "title": "懒加载的实现原理",
    "content": "图片的加载是由<code>src</code>引起的，当对<code>src</code>赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的<code>data-xxx</code>属性来储存图片的路径，在需要加载图片的时候，将<code>data-xxx</code>中图片的路径赋值给<code>src</code>，这样就实现了图片的按需加载，即懒加载。<br><br>注意：<code>data-xxx</code> 中的<code>xxx</code>可以自定义，这里我们使用<code>data-src</code>来定义。<br><br>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。<br><br>使用原生JavaScript实现懒加载：<br><br><strong>知识点：</strong><br><br>（1）<code>window.innerHeight</code> 是浏览器可视区的高度<br><br>（2）<code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离<br><br>（3）<code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）<br><br>（4）图片加载条件：<code>img.offsetTop < window.innerHeight + document.body.scrollTop;</code><br><br><strong>图示：</strong><br><br>![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603966605254-fe880ec0-ebd1-4f94-b662-cdd5e5396c34.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_53%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)<br><br><strong>代码实现：</strong><br><br><pre><code class=\"language-JavaScript\"><div class=\"container\"><br>     <img src=\"loading.gif\"  data-src=\"pic.png\"><br>     <img src=\"loading.gif\"  data-src=\"pic.png\"><br>     <img src=\"loading.gif\"  data-src=\"pic.png\"><br>     <img src=\"loading.gif\"  data-src=\"pic.png\"><br>     <img src=\"loading.gif\"  data-src=\"pic.png\"><br>     <img src=\"loading.gif\"  data-src=\"pic.png\"><br></div><br><script><br>var imgs = document.querySelectorAll('img');<br>function lozyLoad(){<br>    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;<br>    var winHeight= window.innerHeight;<br>    for(var i=0;i < imgs.length;i++){<br>      if(imgs[i].offsetTop < scrollTop + winHeight ){<br>        imgs[i].src = imgs[i].getAttribute('data-src');<br>      }<br>    }<br>  }<br>  window.onscroll = lozyLoad();<br></script><br></code></pre>",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268177,
    "title": "懒加载与预加载的区别",
    "content": "这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。<br><br><li><strong>懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载</strong>，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。</li><br><li><strong>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</strong>通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</li>",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268178,
    "title": "回流与重绘的概念及触发条件",
    "content": "<h4>（1）回流（重排）</h4><br><br>当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为<strong>回流</strong>。<br><br>下面这些操作会导致回流：<br><br><li>页面的首次渲染</li><br><li>浏览器的窗口大小发生变化</li><br><li>元素的内容发生变化</li><br><li>元素的尺寸或者位置发生变化</li><br><li>元素的字体大小发生变化</li><br><li>激活CSS伪类</li><br><li>查询某些属性或者调用某些方法</li><br><li>添加或者删除可见的DOM元素</li><br><br>在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：<br><br><li>全局范围：从根节点开始，对整个渲染树进行重新布局</li><br><li>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</li><br><br><h4>（2）重绘</h4><br><br>当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是<strong>重绘</strong>。<br><br>下面这些操作会导致重绘：<br><br><li>color、background 相关属性：background-color、background-image 等</li><br><li>outline 相关属性：outline-color、outline-width 、text-decoration</li><br><li>border-radius、visibility、box-shadow</li><br><br>注意： <strong>当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。</strong>",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268179,
    "title": "如何避免回流与重绘？",
    "content": "<strong>减少回流与重绘的措施：</strong><br><br><li>操作DOM时，尽量在低层级的DOM节点进行操作</li><br><li>不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</li><br><li>使用CSS的表达式</li><br><li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li><br><li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li><br><li>避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li><br><li>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><br><li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</li><br><br>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong><br><br><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong><br><br>上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268180,
    "title": "如何优化动画？",
    "content": "对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的<code>position</code>属性设置为<code>absolute</code>或者<code>fixed</code>，将动画脱离文档流，这样他的回流就不会影响到页面了。",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268181,
    "title": "documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？",
    "content": "MDN中对<code>documentFragment</code>的解释：<br><br>DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。<br><br>当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将DocumentFragment 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268182,
    "title": "对节流与防抖的理解",
    "content": "<li>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</li><br><li>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</li><br><br><strong>防抖函数的应用场景：</strong><br><br><li>按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次 </li><br><li>服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce </li><br><br>节流函数的<strong>适⽤场景：</strong> <br><br><li>拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动 </li><br><li>缩放场景：监控浏览器resize </li><br><li>动画场景：避免短时间内多次触发动画引起性能问题</li>",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268183,
    "title": "实现节流函数和防抖函数",
    "content": "<strong>函数防抖的实现：</strong><br><br><pre><code class=\"language-JavaScript\">function debounce(fn, wait) {<br>  var timer = null;<br><br>  return function() {<br>    var context = this,<br>      args = [...arguments];<br><br>    // 如果此时存在定时器的话，则取消之前的定时器重新记时<br>    if (timer) {<br>      clearTimeout(timer);<br>      timer = null;<br>    }<br><br>    // 设置定时器，使事件间隔指定事件后执行<br>    timer = setTimeout(() => {<br>      fn.apply(context, args);<br>    }, wait);<br>  };<br>}<br></code></pre><br><br><strong>函数节流的实现：</strong><br><br><pre><code class=\"language-JavaScript\">// 时间戳版<br>function throttle(fn, delay) {<br>  var preTime = Date.now();<br><br>  return function() {<br>    var context = this,<br>      args = [...arguments],<br>      nowTime = Date.now();<br><br>    // 如果两次时间间隔超过了指定时间，则执行函数。<br>    if (nowTime - preTime >= delay) {<br>      preTime = Date.now();<br>      return fn.apply(context, args);<br>    }<br>  };<br>}<br><br>// 定时器版<br>function throttle (fun, wait){<br>  let timeout = null<br>  return function(){<br>    let context = this<br>    let args = [...arguments]<br>    if(!timeout){<br>      timeout = setTimeout(() => {<br>        fun.apply(context, args)<br>        timeout = null <br>      }, wait)<br>    }<br>  }<br>}<br></code></pre>",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268184,
    "title": "如何对项目中的图片进行优化？",
    "content": "1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。<br>2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。<br>3. 小图使用 base64 格式<br>4. 将多个图标文件整合到一张图片中（雪碧图）<br>5. 选择正确的图片格式：<br><li>- 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><br>    - 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替<br>    - 照片使用 JPEG",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268185,
    "title": "常见的图片格式及使用场景",
    "content": "（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。<br><br>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。<br><br>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。<br><br>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。<br><br>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。<br><br>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制Logo、Icon等。<br><br>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。<br><br><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><br><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><br><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li>",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268186,
    "title": "如何提⾼**webpack**的打包速度**?**",
    "content": "<h4>（1）优化 Loader</h4><br><br>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，<strong>转换代码越多，效率就越低</strong>。当然了，这是可以优化的。<br><br>首先我们<strong>优化 Loader 的文件搜索范围</strong><br><br><pre><code class=\"language-JavaScript\">module.exports = {<br>  module: {<br>    rules: [<br>      {<br>        // js 文件才使用 babel<br>        test: /\\.js$/,<br>        loader: 'babel-loader',<br>        // 只在 src 文件夹下查找<br>        include: [resolve('src')],<br>        // 不会去查找的路径<br>        exclude: /node_modules/<br>      }<br>    ]<br>  }<br>}<br></code></pre><br><br>对于 Babel 来说，希望只作用在 JS 代码上的，然后 <code>node_modules</code> 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。<br><br>当然这样做还不够，还可以将 Babel 编译过的文件<strong>缓存</strong>起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间<br><br><pre><code class=\"language-JavaScript\">loader: 'babel-loader?cacheDirectory=true'<br></code></pre><br><br><h4>（2）HappyPack</h4><br><br>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。<br><br><strong>HappyPack 可以将 Loader 的同步执行转换为并行的</strong>，这样就能充分利用系统资源来加快打包效率了<br><br><pre><code class=\"language-JavaScript\">module: {<br>  loaders: [<br>    {<br>      test: /\\.js$/,<br>      include: [resolve('src')],<br>      exclude: /node_modules/,<br>      // id 后面的内容对应下面<br>      loader: 'happypack/loader?id=happybabel'<br>    }<br>  ]<br>},<br>plugins: [<br>  new HappyPack({<br>    id: 'happybabel',<br>    loaders: ['babel-loader?cacheDirectory'],<br>    // 开启 4 个线程<br>    threads: 4<br>  })<br>]<br></code></pre><br><br><h4>（3）DllPlugin</h4><br><br><strong>DllPlugin 可以将特定的类库提前打包然后引入</strong>。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。DllPlugin的使用方法如下：<br><br><pre><code class=\"language-JavaScript\">// 单独配置在一个文件中<br>// webpack.dll.conf.js<br>const path = require('path')<br>const webpack = require('webpack')<br>module.exports = {<br>  entry: {<br>    // 想统一打包的类库<br>    vendor: ['react']<br>  },<br>  output: {<br>    path: path.join(__dirname, 'dist'),<br>    filename: '[name].dll.js',<br>    library: '[name]-[hash]'<br>  },<br>  plugins: [<br>    new webpack.DllPlugin({<br>      // name 必须和 output.library 一致<br>      name: '[name]-[hash]',<br>      // 该属性需要与 DllReferencePlugin 中一致<br>      context: __dirname,<br>      path: path.join(__dirname, 'dist', '[name]-manifest.json')<br>    })<br>  ]<br>}<br></code></pre><br><br>然后需要执行这个配置文件生成依赖文件，接下来需要使用 <code>DllReferencePlugin</code> 将依赖文件引入项目中<br><br><pre><code class=\"language-JavaScript\">// webpack.conf.js<br>module.exports = {<br>  // ...省略其他配置<br>  plugins: [<br>    new webpack.DllReferencePlugin({<br>      context: __dirname,<br>      // manifest 就是之前打包出来的 json 文件<br>      manifest: require('./dist/vendor-manifest.json'),<br>    })<br>  ]<br>}<br></code></pre><br><br><h4>（4）代码压缩</h4><br><br>在 Webpack3 中，一般使用 <code>UglifyJS</code> 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 <code>webpack-parallel-uglify-plugin</code> 来并行运行 <code>UglifyJS</code>，从而提高效率。<br><br>在 Webpack4 中，不需要以上这些操作了，只需要将 <code>mode</code> 设置为 <code>production</code> 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 <code>console.log</code> 这类代码的功能。<br><br><h4>（5）其他</h4><br><br>可以通过一些小的优化点来加快打包速度<br><br><li><code>resolve.extensions</code>：用来表明文件后缀列表，默认查找顺序是 <code>['.js', '.json']</code>，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</li><br><li><code>resolve.alias</code>：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</li><br><li><code>module.noParse</code>：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</li>",
    "categoryId": "1768000001009",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268187,
    "title": "如何减少 Webpack 打包体积",
    "content": "<h4>（1）按需加载</h4><br><br>在开发 SPA 项目的时候，项目中都会存在很多路由页面。如果将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，希望首页能加载的文件体积越小越好，<strong>这时候就可以使用按需加载，将每个路由页面单独打包为一个文件</strong>。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。<br><br>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 <code>Promise</code>，当 <code>Promise</code> 成功以后去执行回调。<br><br><h4>（2）Scope Hoisting</h4><br><br><strong>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</strong><br><br>比如希望打包两个文件：<br><br><pre><code class=\"language-JavaScript\">// test.js<br>export const a = 1<br>// index.js<br>import { a } from './test.js'<br></code></pre><br><br>对于这种情况，打包出来的代码会类似这样：<br><br><pre><code class=\"language-JavaScript\">[<br>  /<em> 0 </em>/<br>  function (module, exports, require) {<br>    //...<br>  },<br>  /<em> 1 </em>/<br>  function (module, exports, require) {<br>    //...<br>  }<br>]<br></code></pre><br><br>但是如果使用 Scope Hoisting ，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码：<br><br><pre><code class=\"language-JavaScript\">[<br>  /<em> 0 </em>/<br>  function (module, exports, require) {<br>    //...<br>  }<br>]<br></code></pre><br><br>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 <code>optimization.concatenateModules</code> 就可以了：<br><br><pre><code class=\"language-JavaScript\">module.exports = {<br>  optimization: {<br>    concatenateModules: true<br>  }<br>}<br></code></pre><br><br><h4>（3）Tree Shaking</h4><br><br><strong>Tree Shaking 可以实现删除项目中未被引用的代码</strong>，比如：<br><br><pre><code class=\"language-text\">// test.js<br>export const a = 1<br>export const b = 2<br>// index.js<br>import { a } from './test.js'<br></code></pre><br><br>对于以上情况，<code>test</code> 文件中的变量 <code>b</code> 如果没有在项目中使用到的话，就不会被打包到文件中。<br><br>如果使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。",
    "categoryId": "1768000001009",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268188,
    "title": "如何⽤**webpack**来优化前端性能？",
    "content": "⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。 <br><br><li><strong>压缩代码</strong>：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css </li><br><li><strong>利⽤CDN</strong>加速: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径 </li><br><li><strong>Tree Shaking</strong>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 --optimize-minimize 来实现</li><br><li><strong>Code Splitting:</strong> 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存 </li><br><li><strong>提取公共第三⽅库</strong>: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</li>",
    "categoryId": "1768000001009",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104268189,
    "title": "如何提⾼**webpack**的构建速度？",
    "content": "1. 多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码 <br>2. 通过 externals 配置来提取常⽤库 <br>3. 利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。 <br>4. 使⽤ Happypack 实现多线程加速编译 <br>5. 使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度 <br>6. 使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码",
    "categoryId": "1768000001009",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:04:28.157Z",
    "updatedAt": "2026-01-11T04:04:28.157Z"
  },
  {
    "id": 1768104436190,
    "title": "git 和 svn 的区别",
    "content": "<li>git 和 svn 最大的区别在于 git 是分布式的，而 svn 是集中式的。因此我们不能再离线的情况下使用 svn。如果服务器出现问题，就没有办法使用 svn 来提交代码。</li><br><li>svn 中的分支是整个版本库的复制的一份完整目录，而 git 的分支是指针指向某次提交，因此 git 的分支创建更加开销更小并且分支上的变化不会影响到其他人。svn 的分支变化会影响到所有的人。</li><br><li>svn 的指令相对于 git 来说要简单一些，比 git 更容易上手。</li><br><li><strong>GIT把内容按元数据方式存储，而SVN是按文件：</strong>因为git目录是处于个人机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。</li><br><li><strong>GIT分支和SVN的分支不同：</strong>svn会发生分支遗漏的情况，而git可以同一个工作目录下快速的在几个分支间切换，很容易发现未被合并的分支，简单而快捷的合并这些文件。</li><br><li><strong>GIT没有一个全局的版本号，而SVN有</strong></li><br><li><strong>GIT的内容完整性要优于SVN：</strong>GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏</li>",
    "categoryId": "1768000001010",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436191,
    "title": "经常使用的 git 命令？",
    "content": "<pre><code class=\"language-JavaScript\">git init                     // 新建 git 代码库<br>git add                      // 添加指定文件到暂存区<br>git rm                       // 删除工作区文件，并且将这次删除放入暂存区<br>git commit -m [message]      // 提交暂存区到仓库区<br>git branch                   // 列出所有分支<br>git checkout -b [branch]     // 新建一个分支，并切换到该分支<br>git status                   // 显示有变更文件的状态<br></code></pre>",
    "categoryId": "1768000001010",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436192,
    "title": "git pull 和 git fetch 的区别",
    "content": "<li>git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。</li><br><li>git pull 会将远程仓库的变化下载下来，并和当前分支合并。</li>",
    "categoryId": "1768000001010",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436193,
    "title": "git rebase 和 git merge 的区别",
    "content": "git merge 和 git rebase 都是用于分支合并，关键<strong>在</strong> <strong>commit 记录的处理上不同</strong>：<br><br><li>git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。</li><br><li>git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记录了。</li>",
    "categoryId": "1768000001010",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436194,
    "title": "*webpack**与**grunt**、**gulp**的不同？",
    "content": "<strong>Grunt、Gulp是基于任务运⾏的⼯具</strong>： 它们会⾃动执⾏指定的任务，就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯，它们包含活跃的社区，丰富的插件，能⽅便的打造各种⼯作流。 <br><br><strong>Webpack是基于模块化打包的⼯具:</strong> ⾃动化处理模块，webpack把⼀切当成模块，当 webpack 处理应⽤程序时，它会递归地构建⼀个依赖关系图 (dependency graph)，其中包含应⽤程序需要的每个模块，然后将所有这些模块打包成⼀个或多个 bundle。 <br><br>因此这是完全不同的两类⼯具,⽽现在主流的⽅式是⽤npm script代替Grunt、Gulp，npm script同样可以打造任务流。<br><br>Webpack 是一个流行的 JavaScript 模块打包工具，它主要用于将 JavaScript 应用程序的多个模块及其依赖关系打包成一个或多个静态资源，把项目中的资源文件都当作模块，因自身对模块处理的局限性（只能处理JS）所以有loader和plugin为其打包做辅助支持，以便对多种资源文件做打包处理。<br><br><li><strong>加载器（Loader）</strong>：</li><br>    - 加载器是 Webpack 的一种<strong>转换</strong>机制，允许你处理非 JavaScript 文件（如 TypeScript、Sass、Less 等）。<br>    - 使用加载器，可以将其他类型的文件转换为有效的模块。<br>    - 常见：<code>less-loader</code>、<code>sass-loader</code>、<code>css-loader</code>、<code>style-loader</code>。<br><li><strong>插件（Plugin）</strong>：</li><br>    - 插件是用于<strong>扩展 Webpack 功能</strong>的重要机制，在构建过程中执行特定的任务。<br>    - 插件可以用来优化构建过程、管理资源、环境变量和生成 HTML 文件等。<br>    - 常见：<code>HtmlWebpackPlugin</code>、<code>MiniCssExtractPlugin</code>、<code>OptimizeCSSAssetsPlugin</code>、<code>TerserWebpackPlugin</code>。",
    "categoryId": "1768000001010",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436195,
    "title": "*webpack**、**rollup**、**parcel**优劣？",
    "content": "<li>webpack适⽤于⼤型复杂的前端站点构建: webpack有强⼤的loader和插件⽣态,打包后的⽂件实际上就是⼀个⽴即执⾏函数，这个⽴即执⾏函数接收⼀个参数，这个参数是模块对象，键为各个模块的路径，值为模块内容。⽴即执⾏函数内部则处理模块之间的引⽤，执⾏模块等,这种情况更适合⽂件依赖复杂的应⽤开发。 </li><br><li>rollup适⽤于基础库的打包，如vue、d3等: Rollup 就是将各个模块打包进⼀个⽂件中，并且通过 Tree-shaking 来删除⽆⽤的代码,可以最⼤程度上降低代码体积,但是rollup没有webpack如此多的的如代码分割、按需加载等⾼级功能，其更聚焦于库的打包，因此更适合库的开发。</li><br><li>parcel适⽤于简单的实验性项⽬: 他可以满⾜低⻔槛的快速看到效果,但是⽣态差、报错信息不够全⾯都是他的硬伤，除了⼀些玩具项⽬或者实验项⽬不建议使⽤。</li>",
    "categoryId": "1768000001010",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436196,
    "title": "有哪些常⻅的**Loader**？",
    "content": "<li>file-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件 </li><br><li>url-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去 </li><br><li>source-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试 </li><br><li>image-loader：加载并且压缩图⽚⽂件 </li><br><li>babel-loader：把 ES6 转换成 ES5 </li><br><li>css-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性 </li><br><li>style-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。 </li><br><li>eslint-loader：通过 ESLint 检查 JavaScript 代码 </li><br><br><strong>注意：在Webpack中，loader的执行顺序是</strong>从右向左执行的。因为webpack选择了<strong>compose这样的函数式编程方式</strong>，这种方式的表达式执行是从右向左的。",
    "categoryId": "1768000001010",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436197,
    "title": "有哪些常⻅的**Plugin**？",
    "content": "<li>define-plugin：定义环境变量 </li><br><li>html-webpack-plugin：简化html⽂件创建 </li><br><li>uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码 </li><br><li>webpack-parallel-uglify-plugin: 多核压缩，提⾼压缩速度 </li><br><li>webpack-bundle-analyzer: 可视化webpack输出⽂件的体积 </li><br><li>mini-css-extract-plugin: CSS提取到单独的⽂件中，⽀持按需加载</li>",
    "categoryId": "1768000001010",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436198,
    "title": "*bundle**，**chunk**，**module**是什么？",
    "content": "<li>bundle：是由webpack打包出来的⽂件； </li><br><li>chunk：代码块，⼀个chunk由多个模块组合⽽成，⽤于代码的合并和分割；</li><br><li>module：是开发中的单个模块，在webpack的世界，⼀切皆模块，⼀个模块对应⼀个⽂件，webpack会从配置的 entry中递归开始找出所有依赖的模块。</li>",
    "categoryId": "1768000001010",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436199,
    "title": "*Loader**和**Plugin**的不同？",
    "content": "不同的作⽤: <br><br><li><strong>Loader</strong>直译为\"加载器\"。Webpack将⼀切⽂件视为模块，但是webpack原⽣是只能解析js⽂件，如果想将其他⽂件也打包的话，就会⽤到 loader 。 所以Loader的作⽤是让webpack拥有了加载和解析⾮JavaScript⽂件的能⼒。 </li><br><li><strong>Plugin</strong>直译为\"插件\"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li><br><br><strong>不同的⽤法:</strong> <br><br><li><strong>Loader</strong>在 module.rules 中配置，也就是说他作为模块的解析规则⽽存在。 类型为数组，每⼀项都是⼀个 Object ，⾥⾯描述了对于什么类型的⽂件（ test ），使⽤什么加载( loader )和使⽤的参数（ options ） </li><br><li><strong>Plugin</strong>在 plugins 中单独配置。 类型为数组，每⼀项是⼀个 plugin 的实例，参数都通过构造函数传⼊。</li>",
    "categoryId": "1768000001010",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436200,
    "title": "*webpack**的构建流程**?**",
    "content": "Webpack 的运⾏流程是⼀个串⾏的过程，从启动到结束会依次执⾏以下流程： <br><br>1. 初始化参数：从配置⽂件和 Shell 语句中读取与合并参数，得出最终的参数； <br>2. 开始编译：⽤上⼀步得到的参数初始化 Compiler 对象，加载所有配置的插件，执⾏对象的 run ⽅法开始执⾏编译； <br>3. 确定⼊⼝：根据配置中的 entry 找出所有的⼊⼝⽂件； <br>4. 编译模块：从⼊⼝⽂件出发，调⽤所有配置的 Loader 对模块进⾏翻译，再找出该模块依赖的模块，再递归本步骤直到所有⼊⼝依赖的⽂件都经过了本步骤的处理； <br>5. 完成模块编译：在经过第4步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； <br>6. 输出资源：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会； <br>7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统。<br><br>在以上过程中，Webpack 会在特定的时间点⼴播出特定的事件，插件在监听到感兴趣的事件后会执⾏特定的逻辑，并且插件可以调⽤ Webpack 提供的 API 改变 Webpack 的运⾏结果。",
    "categoryId": "1768000001010",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436201,
    "title": "编写**loader**或**plugin**的思路？",
    "content": "Loader像⼀个\"翻译官\"把读到的源⽂件内容转义成新的⽂件内容，并且每个Loader通过链式操作，将源⽂件⼀步步翻译成想要的样⼦。 <br><br>编写Loader时要遵循单⼀原则，每个Loader只做⼀种\"转义\"⼯作。 每个Loader的拿到的是源⽂件内容（source），可以通过返回值的⽅式将处理后的内容输出，也可以调⽤ this.callback() ⽅法，将内容返回给webpack。 还可以通过this.async() ⽣成⼀个 callback 函数，再⽤这个callback将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发loader的⼯具函数集——loader-utils 。 <br><br>相对于Loader⽽⾔，Plugin的编写就灵活了许多。 webpack在运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。",
    "categoryId": "1768000001010",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436202,
    "title": "*webpack** 热更新的实现原理？",
    "content": "webpack的热更新⼜称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不⽤刷新浏览器⽽将新变更的模块替换掉旧的模块。 <br><br>原理： <br><br>![](https://secure2.wostatic.cn/static/joVoiXkCie3i28QzK7cja9/2.png?auth_key=1768104318-kYihZxMSnoNiUT6zkdNJHj-0-916067be1e89dc97a6659cbc20ea5eba)<br><br>⾸先要知道server端和client端都做了处理⼯作：<br><br>1. 第⼀步，在 webpack 的 watch 模式下，⽂件系统中某⼀个⽂件发⽣修改，webpack 监听到⽂件变化，根据配置⽂ <br><br>件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。 <br><br>1. 第⼆步是 webpack-dev-server 和 webpack 之间的接⼝交互，⽽在这⼀步，主要是 dev-server 的中间件 webpack- dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调⽤ webpack 暴露的 API对代码变化进⾏监 控，并且告诉 webpack，将代码打包到内存中。 <br>2. 第三步是 webpack-dev-server 对⽂件变化的⼀个监控，这⼀步不同于第⼀步，并不是监控代码变化重新打包。当我们在配置⽂件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置⽂件夹中静态⽂件的变化，变化后会通知浏览器端对应⽤进⾏ live reload。注意，这⼉是浏览器刷新，和 HMR 是两个概念。 <br>3. 第四步也是 webpack-dev-server 代码的⼯作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建⽴⼀个 websocket ⻓连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态⽂件变化的信息。浏览器端根据这些 socket 消息进⾏不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后⾯的步骤根据这⼀ hash 值来进⾏模块热替换。 <br>4. webpack-dev-server/client 端并不能够请求更新的代码，也不会执⾏热更模块操作，⽽把这些⼯作⼜交回给了webpack，webpack/hot/dev-server 的⼯作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进⾏模块热更新。当然如果仅仅是刷新浏览器，也就没有后⾯那些步骤了。 <br>5. HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上⼀步传递给他的新模块的 hash 值，它通过JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回⼀个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。 <br>6. ⽽第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进⾏对⽐，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引⽤。 <br>7. 最后⼀步，当 HMR 失败后，回退到 live reload 操作，也就是进⾏浏览器刷新来获取最新打包代码。",
    "categoryId": "1768000001010",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436203,
    "title": "如何⽤**webpack**来优化前端性能？",
    "content": "⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。 <br><br><li><strong>压缩代码</strong>：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css </li><br><li><strong>利⽤CDN</strong>加速: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径 </li><br><li><strong>Tree Shaking</strong>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 --optimize-minimize 来实现</li><br><li><strong>Code Splitting:</strong> 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存 </li><br><li><strong>提取公共第三⽅库</strong>: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</li>",
    "categoryId": "1768000001010",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436204,
    "title": "如何提⾼**webpack**的打包速度**?**",
    "content": "<li>happypack: 利⽤进程并⾏编译loader,利⽤缓存来使得 rebuild 更快,遗憾的是作者表示已经不会继续开发此项⽬,类似的替代者是thread-loader </li><br><li>外部扩展(externals): 将不怎么需要更新的第三⽅库脱离webpack打包，不被打⼊bundle中，从⽽减少打包时间，⽐如jQuery⽤script标签引⼊ </li><br><li>dll: 采⽤webpack的 DllPlugin 和 DllReferencePlugin 引⼊dll，让⼀些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间 </li><br><li>利⽤缓存: webpack.cache 、babel-loader.cacheDirectory、 HappyPack.cache 都可以利⽤缓存提⾼rebuild效率缩⼩⽂件搜索范围: ⽐如babel-loader插件,如果你的⽂件仅存在于src中,那么可以 include: path.resolve(__dirname,'src') ,当然绝⼤多数情况下这种操作的提升有限，除⾮不⼩⼼build了node_modules⽂件</li>",
    "categoryId": "1768000001010",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436205,
    "title": "如何提⾼**webpack**的构建速度？",
    "content": "1. 多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码 <br>2. 通过 externals 配置来提取常⽤库 <br>3. 利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。 <br>4. 使⽤ Happypack 实现多线程加速编译 <br>5. 使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度 <br>6. 使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码",
    "categoryId": "1768000001010",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436206,
    "title": "怎么配置单⻚应⽤？怎么配置多⻚应⽤？",
    "content": "单⻚应⽤可以理解为webpack的标准模式，直接在 entry 中指定单⻚应⽤的⼊⼝即可，这⾥不再赘述多⻚应⽤的话，可以使⽤webpack的 AutoWebPlugin 来完成简单⾃动化的构建，但是前提是项⽬的⽬录结构必须遵守他预设的规范。 多⻚应⽤中要注意的是： <br><br><li>每个⻚⾯都有公共的代码，可以将这些代码抽离出来，避免重复的加载。⽐如，每个⻚⾯都引⽤了同⼀套css样式表</li><br><li>随着业务的不断扩展，⻚⾯可能会不断的追加，所以⼀定要让⼊⼝的配置⾜够灵活，避免每次添加新⻚⾯还需要修改构建配置</li>",
    "categoryId": "1768000001010",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436207,
    "title": "*1. Babel**的原理是什么**?**",
    "content": "babel 的转译过程也分为三个阶段，这三步具体是： <br><br><li><strong>解析 Parse</strong>: 将代码解析⽣成抽象语法树（AST），即词法分析与语法分析的过程；</li><br><li><strong>转换 Transform</strong>: 对于 AST 进⾏变换⼀系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进⾏遍历，在此过程中进⾏添加、更新及移除等操作；</li><br><li><strong>⽣成 Generate</strong>: 将变换后的 AST 再转换为 JS 代码, 使⽤到的模块是 babel-generator。</li><br><br>![](https://secure2.wostatic.cn/static/w7e6xx3VKHYR4BrjoARvwF/2.png)",
    "categoryId": "1768000001010",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436208,
    "title": "封包的场景有哪些",
    "content": "<li><strong>UI 组件封装：</strong> 将页面上重复使用的 UI 组件（如按钮、表单、弹窗等）封装成独立的组件，方便重复使用，并且可以提高组件的可定制性和可复用性。</li><br><li><strong>工具函数封装：</strong> 将常用的功能模块（如日期格式化、字符串处理、网络请求等）封装成函数或工具类，方便在项目中复用，减少重复编写代码的工作量。</li><br><li><strong>服务封装：</strong> 将与后端 API 交互的逻辑封装成服务（Service），通过服务提供统一的接口和数据处理逻辑，方便管理和维护数据请求和响应。</li><br><li><strong>样式封装：</strong> 将页面样式、主题样式封装成 CSS 模块或预处理器变量，使样式的修改和管理更加便捷。</li><br><li><strong>路由管理封装：</strong> 将路由配置、权限控制等逻辑封装成路由管理器或路由组件，简化项目中路由的配置和管理。</li><br><li><strong>状态管理封装：</strong> 将组件之间共享的状态（如全局状态、页面状态等）封装成状态管理库（如 Redux、Vuex），提供统一的状态管理机制。</li><br><li><strong>数据处理封装：</strong> 将数据处理逻辑（如数据转换、过滤、排序等）封装成数据处理库，提高数据处理的效率和可维护性。</li><br><li><strong>插件封装：</strong> 将通用的功能封装成插件，方便在项目中引入和使用，如日历插件、轮播图插件等。</li>",
    "categoryId": "1768000001010",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436209,
    "title": "http缓存机制",
    "content": "<li>强缓存是指客户端在请求资源时，不需要与服务器进行通信，可以直接从本地缓存中获取资源。强缓存可以通过两种 HTTP 头来实现：</li><br>    - <strong>Expires</strong>：服务器在<strong>响应头</strong>中返回一个过期时间，表示资源过期时间点。客户端在下次请求资源时，如果当前时间小于过期时间，则直接从缓存中获取资源。<br><br>        <code>Expires: Wed, 21 Oct 2024 07:28:00 GMT</code> <br>    - <strong>Cache-Control</strong>：Cache-Control 是更现代和推荐的做法，它提供了更多的控制选项，可以指定缓存的行为。常见的指令有：<br>        - <code>public</code>：响应可以被任何缓存（包括客户端）进行缓存。<br>        - <code>private</code>：响应只能够被单个用户的浏览器缓存，不允许任何中间缓存对其进行缓存。<br>        - <code>max-age=<seconds></code>：指定资源被缓存多少秒，例如 <code>max-age=3600</code> 表示资源在缓存中可以存储 3600 秒（1 小时）。<br>        - <code>no-cache</code>：客户端必须向服务器验证资源是否过期。<br>        - <code>no-store</code>：所有的请求和响应都不应该被缓存。<br>    - 可以看个图（CSDN、B站对某些资源文件做了强缓存）：<br><br>        ![](https://secure2.wostatic.cn/static/DMDxcjViZj8VY9zcctm17/image.png)<br><br>        ![](https://secure2.wostatic.cn/static/wRrZXB25FB3zAWymKEJWHd/image.png)<br><li>协商缓存指的是，如果资源已经过期（即强缓存失效），客户端将与服务器进行通信，通过一些标头来验证资源是否仍然有效。如果资源未更改，则服务器返回 304 状态码，告知客户端可以使用本地缓存副本。主要的协商缓存标头有：</li><br>    - <strong>Last-Modified / If-Modified-Since</strong>：服务器在响应头中返回资源的最后修改时间，客户端下次请求时在请求头中带上 <code>If-Modified-Since</code> 字段，如果服务器判断资源未发生变化，就会返回 304 状态码。<br><br>        <code>Last-Modified: Wed, 21 Oct 2024 07:28:00 GMT</code><br><br>        <code>If-Modified-Since: Wed, 21 Oct 2024 07:28:00 GMT </code><br>    - <strong>ETag / If-None-Match</strong>：ETag 是资源的唯一标识符，服务器在响应头中返回。客户端下次请求时在请求头中带上 <code>If-None-Match</code> 字段，如果服务器判断资源未发生变化，就会返回 304 状态码。<br><br>        <code>ETag: \"686897696a7c876b7e\"</code><br><br>        <code>If-None-Match: \"686897696a7c876b7e\"</code><br>    - 协商缓存相对于强缓存提供了更精细的控制，允许服务器在资源未变更时减少响应数据的传输量，从而节省带宽和提高效率。<br><br>    无论哪种方式都需要靠配置响应头来完成，所以这里主要是后端人员去做。",
    "categoryId": "1768000001010",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104436210,
    "title": "跨域是怎么造成的，有什么解决方法？",
    "content": "<li>原因：</li><br>    - 服务端未开启允许跨域；<br>    - 前端服务同请求接口的协议、域名、端口号任一不同；<br>    - 浏览器做跨域拦截；<br><li>解决：</li><br>    - JSONP：实际上是一种利用 <code><script></code> 标签的可跨域特性来实现跨域请求的技术，需要前后端配合实现才能调用到准备好的函数。<br><br><pre><code class=\"language-JavaScript\">// 定义全局回调函数  <br>function handleResponse(data) {  <br>  console.log(data); // 处理从跨域服务器返回的数据  <br>}  <br><br>// 动态创建 <script> 标签  <br>var script = document.createElement('script');  <br>script.src = 'http://cross-domain-server.com/data?callback=handleResponse';  <br>document.body.appendChild(script);<br></code></pre><br>    - 后端设置跨域资源共享（CORS）：服务器返回特定的响应头以允许跨域请求；<br>    - 代理：向同域服务器发送请求，由同域服务器转发请求至目标服务器，继而避开浏览器的同源检查。<br>    <br>        ![](https://secure2.wostatic.cn/static/wjnZGQM2c9Ys6ZYQdNufbH/image.png)",
    "categoryId": "1768000001010",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:07:16.180Z",
    "updatedAt": "2026-01-11T04:07:16.180Z"
  },
  {
    "id": 1768104668143,
    "title": "手写 Object.create",
    "content": "思路：将传入的对象作为原型<br><br><pre><code class=\"language-javascript\">function create(obj) {<br>  function F() {}<br>  F.prototype = obj<br>  return new F()<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668145,
    "title": "手写 instanceof 方法",
    "content": "instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。<br><br>具体实现：<br><br><pre><code class=\"language-javascript\">function myInstanceof(left, right) {<br>  let proto = Object.getPrototypeOf(left), // 获取对象的原型<br>      prototype = right.prototype; // 获取构造函数的 prototype 对象<br><br>  // 判断构造函数的 prototype 对象是否在对象的原型链上<br>  while (true) {<br>    if (!proto) return false;<br>    if (proto === prototype) return true;<br><br>    proto = Object.getPrototypeOf(proto);<br>  }<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668146,
    "title": "手写 new 操作符",
    "content": "在调用 <code>new</code> 的过程中会发生以上四件事情：<br><br>（1）首先创建了一个新的空对象<br><br>（2）设置原型，将对象的原型设置为函数的 prototype 对象。<br><br>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br><br>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。<br><br><pre><code class=\"language-javascript\">function objectFactory() {<br>  let newObject = null;<br>  let constructor = Array.prototype.shift.call(arguments);<br>  let result = null;<br>  // 判断参数是否是一个函数<br>  if (typeof constructor !== \"function\") {<br>    console.error(\"type error\");<br>    return;<br>  }<br>  // 新建一个空对象，对象的原型为构造函数的 prototype 对象<br>  newObject = Object.create(constructor.prototype);<br>  // 将 this 指向新建对象，并执行函数<br>  result = constructor.apply(newObject, arguments);<br>  // 判断返回对象<br>  let flag = result && (typeof result === \"object\" || typeof result === \"function\");<br>  // 判断返回结果<br>  return flag ? result : newObject;<br>}<br>// 使用方法<br>objectFactory(构造函数, 初始化参数);<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668147,
    "title": "手写 Promise",
    "content": "<pre><code class=\"language-javascript\">const PENDING = \"pending\";<br>const RESOLVED = \"resolved\";<br>const REJECTED = \"rejected\";<br><br>function MyPromise(fn) {<br>  // 保存初始化状态<br>  var self = this;<br><br>  // 初始化状态<br>  this.state = PENDING;<br><br>  // 用于保存 resolve 或者 rejected 传入的值<br>  this.value = null;<br><br>  // 用于保存 resolve 的回调函数<br>  this.resolvedCallbacks = [];<br><br>  // 用于保存 reject 的回调函数<br>  this.rejectedCallbacks = [];<br><br>  // 状态转变为 resolved 方法<br>  function resolve(value) {<br>    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变<br>    if (value instanceof MyPromise) {<br>      return value.then(resolve, reject);<br>    }<br><br>    // 保证代码的执行顺序为本轮事件循环的末尾<br>    setTimeout(() => {<br>      // 只有状态为 pending 时才能转变，<br>      if (self.state === PENDING) {<br>        // 修改状态<br>        self.state = RESOLVED;<br><br>        // 设置传入的值<br>        self.value = value;<br><br>        // 执行回调函数<br>        self.resolvedCallbacks.forEach(callback => {<br>          callback(value);<br>        });<br>      }<br>    }, 0);<br>  }<br><br>  // 状态转变为 rejected 方法<br>  function reject(value) {<br>    // 保证代码的执行顺序为本轮事件循环的末尾<br>    setTimeout(() => {<br>      // 只有状态为 pending 时才能转变<br>      if (self.state === PENDING) {<br>        // 修改状态<br>        self.state = REJECTED;<br><br>        // 设置传入的值<br>        self.value = value;<br><br>        // 执行回调函数<br>        self.rejectedCallbacks.forEach(callback => {<br>          callback(value);<br>        });<br>      }<br>    }, 0);<br>  }<br><br>  // 将两个方法传入函数执行<br>  try {<br>    fn(resolve, reject);<br>  } catch (e) {<br>    // 遇到错误时，捕获错误，执行 reject 函数<br>    reject(e);<br>  }<br>}<br><br>MyPromise.prototype.then = function(onResolved, onRejected) {<br>  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数<br>  onResolved =<br>    typeof onResolved === \"function\"<br>      ? onResolved<br>      : function(value) {<br>          return value;<br>        };<br><br>  onRejected =<br>    typeof onRejected === \"function\"<br>      ? onRejected<br>      : function(error) {<br>          throw error;<br>        };<br><br>  // 如果是等待状态，则将函数加入对应列表中<br>  if (this.state === PENDING) {<br>    this.resolvedCallbacks.push(onResolved);<br>    this.rejectedCallbacks.push(onRejected);<br>  }<br><br>  // 如果状态已经凝固，则直接执行对应状态的函数<br><br>  if (this.state === RESOLVED) {<br>    onResolved(this.value);<br>  }<br><br>  if (this.state === REJECTED) {<br>    onRejected(this.value);<br>  }<br>};<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668148,
    "title": "手写 Promise.then",
    "content": "<code>then</code> 方法返回一个新的 <code>promise</code> 实例，为了在 <code>promise</code> 状态发生变化时（<code>resolve</code> / <code>reject</code> 被调用时）再执行 <code>then</code> 里的函数，我们使用一个 <code>callbacks</code> 数组先把传给then的函数暂存起来，等状态改变时再调用。<br><br><strong>那么，怎么保证后一个</strong> <code><strong>then</strong></code> <strong>里的方法在前一个</strong> <code><strong>then</strong></code><strong>（可能是异步）结束之后再执行呢？</strong><br><br>我们可以将传给 <code>then</code> 的函数和新 <code>promise</code> 的 <code>resolve</code> 一起 <code>push</code> 到前一个 <code>promise</code> 的 <code>callbacks</code> 数组中，达到承前启后的效果：<br><br><li>承前：当前一个 <code>promise</code> 完成后，调用其 <code>resolve</code> 变更状态，在这个 <code>resolve</code> 里会依次调用 <code>callbacks</code> 里的回调，这样就执行了 <code>then</code> 里的方法了</li><br><li>启后：上一步中，当 <code>then</code> 里的方法执行完成后，返回一个结果，如果这个结果是个简单的值，就直接调用新 <code>promise</code> 的 <code>resolve</code>，让其状态变更，这又会依次调用新 <code>promise</code> 的 <code>callbacks</code> 数组里的方法，循环往复。。如果返回的结果是个 <code>promise</code>，则需要等它完成之后再触发新 <code>promise</code> 的 <code>resolve</code>，所以可以在其结果的 <code>then</code> 里调用新 <code>promise</code> 的 <code>resolve</code></li><br><br><pre><code class=\"language-javascript\">then(onFulfilled, onReject){<br>    // 保存前一个promise的this<br>    const self = this; <br>    return new MyPromise((resolve, reject) => {<br>      // 封装前一个promise成功时执行的函数<br>      let fulfilled = () => {<br>        try{<br>          const result = onFulfilled(self.value); // 承前<br>          return result instanceof MyPromise? result.then(resolve, reject) : resolve(result); //启后<br>        }catch(err){<br>          reject(err)<br>        }<br>      }<br>      // 封装前一个promise失败时执行的函数<br>      let rejected = () => {<br>        try{<br>          const result = onReject(self.reason);<br>          return result instanceof MyPromise? result.then(resolve, reject) : reject(result);<br>        }catch(err){<br>          reject(err)<br>        }<br>      }<br>      switch(self.status){<br>        case PENDING: <br>          self.onFulfilledCallbacks.push(fulfilled);<br>          self.onRejectedCallbacks.push(rejected);<br>          break;<br>        case FULFILLED:<br>          fulfilled();<br>          break;<br>        case REJECT:<br>          rejected();<br>          break;<br>      }<br>    })<br>   }<br></code></pre><br><br><strong>注意：</strong><br><br><li>连续多个 <code>then</code> 里的回调方法是同步注册的，但注册到了不同的 <code>callbacks</code> 数组中，因为每次 <code>then</code> 都返回新的 <code>promise</code> 实例（参考上面的例子和图）</li><br><li>注册完成后开始执行构造函数中的异步事件，异步完成之后依次调用 <code>callbacks</code> 数组中提前注册的回调</li>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668149,
    "title": "手写 Promise.all",
    "content": "<strong>1) 核心思路</strong><br><br>1. 接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数<br>2. 这个方法返回一个新的 promise 对象，<br>3. 遍历传入的参数，用Promise.resolve()将参数\"包一层\"，使其变成一个promise对象<br>4. 参数所有回调成功才是成功，返回值数组与参数顺序一致<br>5. 参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。<br><br><strong>2）实现代码</strong><br><br>一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了<br><br><pre><code class=\"language-javascript\">function promiseAll(promises) {<br>  return new Promise(function(resolve, reject) {<br>    if(!Array.isArray(promises)){<br>        throw new TypeError(<code>argument must be a array</code>)<br>    }<br>    var resolvedCounter = 0;<br>    var promiseNum = promises.length;<br>    var resolvedResult = [];<br>    for (let i = 0; i < promiseNum; i++) {<br>      Promise.resolve(promises[i]).then(value=>{<br>        resolvedCounter++;<br>        resolvedResult[i] = value;<br>        if (resolvedCounter == promiseNum) {<br>            return resolve(resolvedResult)<br>          }<br>      },error=>{<br>        return reject(error)<br>      })<br>    }<br>  })<br>}<br>// test<br>let p1 = new Promise(function (resolve, reject) {<br>    setTimeout(function () {<br>        resolve(1)<br>    }, 1000)<br>})<br>let p2 = new Promise(function (resolve, reject) {<br>    setTimeout(function () {<br>        resolve(2)<br>    }, 2000)<br>})<br>let p3 = new Promise(function (resolve, reject) {<br>    setTimeout(function () {<br>        resolve(3)<br>    }, 3000)<br>})<br>promiseAll([p3, p1, p2]).then(res => {<br>    console.log(res) // [3, 1, 2]<br>})<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668150,
    "title": "手写 Promise.race",
    "content": "该方法的参数是 Promise 实例数组, 然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行. 因为 Promise 的状态<strong>只能改变一次</strong>, 那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法, 注入到数组中的每一个 Promise 实例中的回调函数中即可.<br><br><pre><code class=\"language-javascript\">Promise.race = function (args) {<br>  return new Promise((resolve, reject) => {<br>    for (let i = 0, len = args.length; i < len; i++) {<br>      args[i].then(resolve, reject)<br>    }<br>  })<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668151,
    "title": "手写防抖函数",
    "content": "函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。<br><br><pre><code class=\"language-javascript\">// 函数防抖的实现<br>function debounce(fn, wait) {<br>  let timer = null;<br><br>  return function() {<br>    let context = this,<br>        args = arguments;<br><br>    // 如果此时存在定时器的话，则取消之前的定时器重新记时<br>    if (timer) {<br>      clearTimeout(timer);<br>      timer = null;<br>    }<br><br>    // 设置定时器，使事件间隔指定事件后执行<br>    timer = setTimeout(() => {<br>      fn.apply(context, args);<br>    }, wait);<br>  };<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668152,
    "title": "手写节流函数",
    "content": "函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。<br><br><pre><code class=\"language-javascript\">// 函数节流的实现;<br>function throttle(fn, delay) {<br>  let curTime = Date.now();<br><br>  return function() {<br>    let context = this,<br>        args = arguments,<br>        nowTime = Date.now();<br><br>    // 如果两次时间间隔超过了指定时间，则执行函数。<br>    if (nowTime - curTime >= delay) {<br>      curTime = Date.now();<br>      return fn.apply(context, args);<br>    }<br>  };<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668153,
    "title": "手写类型判断函数",
    "content": "<pre><code class=\"language-javascript\">function getType(value) {<br>  // 判断数据是 null 的情况<br>  if (value === null) {<br>    return value + \"\";<br>  }<br>  // 判断数据是引用类型的情况<br>  if (typeof value === \"object\") {<br>    let valueClass = Object.prototype.toString.call(value),<br>      type = valueClass.split(\" \")[1].split(\"\");<br>    type.pop();<br>    return type.join(\"\").toLowerCase();<br>  } else {<br>    // 判断数据是基本数据类型的情况和函数的情况<br>    return typeof value;<br>  }<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668154,
    "title": "手写 call 函数",
    "content": "call 函数的实现步骤：<br><br>1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。<br>2. 判断传入上下文对象是否存在，如果不存在，则设置为 window 。<br>3. 处理传入的参数，截取第一个参数后的所有参数。<br>4. 将函数作为上下文对象的一个属性。<br>5. 使用上下文对象来调用这个方法，并保存返回结果。<br>6. 删除刚才新增的属性。<br>7. 返回结果。<br><br><pre><code class=\"language-javascript\">// call函数实现<br>Function.prototype.myCall = function(context) {<br>  // 判断调用对象<br>  if (typeof this !== \"function\") {<br>    console.error(\"type error\");<br>  }<br>  // 获取参数<br>  let args = [...arguments].slice(1),<br>      result = null;<br>  // 判断 context 是否传入，如果未传入则设置为 window<br>  context = context || window;<br>  // 将调用函数设为对象的方法<br>  context.fn = this;<br>  // 调用函数<br>  result = context.fn(...args);<br>  // 将属性删除<br>  delete context.fn;<br>  return result;<br>};<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668155,
    "title": "手写 apply 函数",
    "content": "apply 函数的实现步骤：<br><br>1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。<br>2. 判断传入上下文对象是否存在，如果不存在，则设置为 window 。<br>3. 将函数作为上下文对象的一个属性。<br>4. 判断参数值是否传入<br>5. 使用上下文对象来调用这个方法，并保存返回结果。<br>6. 删除刚才新增的属性<br>7. 返回结果<br><br><pre><code class=\"language-javascript\">// apply 函数实现<br>Function.prototype.myApply = function(context) {<br>  // 判断调用对象是否为函数<br>  if (typeof this !== \"function\") {<br>    throw new TypeError(\"Error\");<br>  }<br>  let result = null;<br>  // 判断 context 是否存在，如果未传入则为 window<br>  context = context || window;<br>  // 将函数设为对象的方法<br>  context.fn = this;<br>  // 调用方法<br>  if (arguments[1]) {<br>    result = context.fn(...arguments[1]);<br>  } else {<br>    result = context.fn();<br>  }<br>  // 将属性删除<br>  delete context.fn;<br>  return result;<br>};<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668156,
    "title": "手写 bind 函数",
    "content": "bind 函数的实现步骤：<br><br>1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。<br>2. 保存当前函数的引用，获取其余传入参数值。<br>3. 创建一个函数返回<br>4. 函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。<br><br><pre><code class=\"language-javascript\">// bind 函数实现<br>Function.prototype.myBind = function(context) {<br>  // 判断调用对象是否为函数<br>  if (typeof this !== \"function\") {<br>    throw new TypeError(\"Error\");<br>  }<br>  // 获取参数<br>  var args = [...arguments].slice(1),<br>      fn = this;<br>  return function Fn() {<br>    // 根据调用方式，传入不同绑定值<br>    return fn.apply(<br>      this instanceof Fn ? this : context,<br>      args.concat(...arguments)<br>    );<br>  };<br>};<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668157,
    "title": "函数柯里化的实现",
    "content": "函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。<br><br><pre><code class=\"language-javascript\">function curry(fn, args) {<br>  // 获取函数需要的参数长度<br>  let length = fn.length;<br><br>  args = args || [];<br><br>  return function() {<br>    let subArgs = args.slice(0);<br><br>    // 拼接得到现有的所有参数<br>    for (let i = 0; i < arguments.length; i++) {<br>      subArgs.push(arguments[i]);<br>    }<br><br>    // 判断参数的长度是否已经满足函数所需参数的长度<br>    if (subArgs.length >= length) {<br>      // 如果满足，执行函数<br>      return fn.apply(this, subArgs);<br>    } else {<br>      // 如果不满足，递归返回科里化的函数，等待参数的传入<br>      return curry.call(this, fn, subArgs);<br>    }<br>  };<br>}<br><br>// es6 实现<br>function curry(fn, ...args) {<br>  return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668158,
    "title": "实现AJAX请求",
    "content": "AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。<br><br>创建AJAX请求的步骤：<br><br><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><br><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><br><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><br><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li><br><br><pre><code class=\"language-javascript\">const SERVER_URL = \"/server\";<br>let xhr = new XMLHttpRequest();<br>// 创建 Http 请求<br>xhr.open(\"GET\", SERVER_URL, true);<br>// 设置状态监听函数<br>xhr.onreadystatechange = function() {<br>  if (this.readyState !== 4) return;<br>  // 当请求成功时<br>  if (this.status === 200) {<br>    handle(this.response);<br>  } else {<br>    console.error(this.statusText);<br>  }<br>};<br>// 设置请求失败时的监听函数<br>xhr.onerror = function() {<br>  console.error(this.statusText);<br>};<br>// 设置请求头信息<br>xhr.responseType = \"json\";<br>xhr.setRequestHeader(\"Accept\", \"application/json\");<br>// 发送 Http 请求<br>xhr.send(null);<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668159,
    "title": "使用Promise封装AJAX请求",
    "content": "<pre><code class=\"language-javascript\">// promise 封装实现：<br>function getJSON(url) {<br>  // 创建一个 promise 对象<br>  let promise = new Promise(function(resolve, reject) {<br>    let xhr = new XMLHttpRequest();<br>    // 新建一个 http 请求<br>    xhr.open(\"GET\", url, true);<br>    // 设置状态的监听函数<br>    xhr.onreadystatechange = function() {<br>      if (this.readyState !== 4) return;<br>      // 当请求成功或失败时，改变 promise 的状态<br>      if (this.status === 200) {<br>        resolve(this.response);<br>      } else {<br>        reject(new Error(this.statusText));<br>      }<br>    };<br>    // 设置错误监听函数<br>    xhr.onerror = function() {<br>      reject(new Error(this.statusText));<br>    };<br>    // 设置响应的数据类型<br>    xhr.responseType = \"json\";<br>    // 设置请求头信息<br>    xhr.setRequestHeader(\"Accept\", \"application/json\");<br>    // 发送 http 请求<br>    xhr.send(null);<br>  });<br>  return promise;<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668160,
    "title": "实现浅拷贝",
    "content": "浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。<br><br><h4>（1）Object.assign()</h4><br><br><code>Object.assign()</code>是ES6中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法：<code>Object.assign(target, source_1, ···)</code>，该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。<br><br><strong>注意：</strong><br><br><li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li><br><li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li><br><li>因为<code>null</code> 和 <code>undefined</code> 不能转化为对象，所以第一个参数不能为<code>null</code>或 <code>undefined</code>，会报错。</li><br><br><pre><code class=\"language-javascript\">let target = {a: 1};<br>let object2 = {b: 2};<br>let object3 = {c: 3};<br>Object.assign(target,object2,object3);  <br>console.log(target);  // {a: 1, b: 2, c: 3}<br></code></pre><br><br><h4>（2）扩展运算符</h4><br><br>使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：<code>let cloneObj = { ...obj };</code><br><br><pre><code class=\"language-javascript\">let obj1 = {a:1,b:{c:1}}<br>let obj2 = {...obj1};<br>obj1.a = 2;<br>console.log(obj1); //{a:2,b:{c:1}}<br>console.log(obj2); //{a:1,b:{c:1}}<br>obj1.b.c = 2;<br>console.log(obj1); //{a:2,b:{c:2}}<br>console.log(obj2); //{a:1,b:{c:2}}<br></code></pre><br><br><h4>（3）数组方法实现数组浅拷贝</h4><br><br>###### <strong>1）Array.prototype.slice</strong><br><br><li><code>slice()</code>方法是JavaScript数组的一个方法，这个方法可以从已有数组中返回选定的元素：用法：<code>array.slice(start, end)</code>，该方法不会改变原始数组。</li><br><li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li><br><br><pre><code class=\"language-javascript\">let arr = [1,2,3,4];<br>console.log(arr.slice()); // [1,2,3,4]<br>console.log(arr.slice() === arr); //false<br></code></pre><br><br>###### <strong>2）Array.prototype.concat</strong><br><br><li><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</li><br><li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li><br><br><pre><code class=\"language-javascript\">let arr = [1,2,3,4];<br>console.log(arr.concat()); // [1,2,3,4]<br>console.log(arr.concat() === arr); //false<br></code></pre><br><br><h4>（4）手写实现浅拷贝</h4><br><br><pre><code class=\"language-javascript\">// 浅拷贝的实现;<br><br>function shallowCopy(object) {<br>  // 只拷贝对象<br>  if (!object || typeof object !== \"object\") return;<br><br>  // 根据 object 的类型判断是新建一个数组还是对象<br>  let newObject = Array.isArray(object) ? [] : {};<br><br>  // 遍历 object，并且判断是 object 的属性才拷贝<br>  for (let key in object) {<br>    if (object.hasOwnProperty(key)) {<br>      newObject[key] = object[key];<br>    }<br>  }<br><br>  return newObject;<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668161,
    "title": "实现深拷贝",
    "content": "<li><strong>浅拷贝：</strong> 浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</li><br><li><strong>深拷贝：</strong> 深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败</li><br><br><h4>（1）JSON.stringify()</h4><br><br><li><code>JSON.parse(JSON.stringify(obj))</code>是目前比较常用的深拷贝方法之一，它的原理就是利用<code>JSON.stringify</code> 将<code>js</code>对象序列化（JSON字符串），再使用<code>JSON.parse</code>来反序列化(还原)<code>js</code>对象。</li><br><li>这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过<code>JSON.stringify()</code>进行处理之后，都会消失。</li><br><br><pre><code class=\"language-javascript\">let obj1 = {  a: 0,<br>              b: {<br>                 c: 0<br>                 }<br>            };<br>let obj2 = JSON.parse(JSON.stringify(obj1));<br>obj1.a = 1;<br>obj1.b.c = 1;<br>console.log(obj1); // {a: 1, b: {c: 1}}<br>console.log(obj2); // {a: 0, b: {c: 0}}<br></code></pre><br><br><h4>（2）函数库lodash的 _.cloneDeep方法</h4><br><br>该函数库也有提供 _.cloneDeep用来做 Deep Copy<br><br><pre><code class=\"language-javascript\">var _ = require('lodash');<br>var obj1 = {<br>    a: 1,<br>    b: { f: { g: 1 } },<br>    c: [1, 2, 3]<br>};<br>var obj2 = _.cloneDeep(obj1);<br>console.log(obj1.b.f === obj2.b.f);// false<br></code></pre><br><br><h4>（3）手写实现深拷贝函数</h4><br><br><pre><code class=\"language-javascript\">// 深拷贝的实现<br>function deepCopy(object) {<br>  if (!object || typeof object !== \"object\") return;<br><br>  let newObject = Array.isArray(object) ? [] : {};<br><br>  for (let key in object) {<br>    if (object.hasOwnProperty(key)) {<br>      newObject[key] =<br>        typeof object[key] === \"object\" ? deepCopy(object[key]) : object[key];<br>    }<br>  }<br><br>  return newObject;<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668162,
    "title": "实现sleep函数（使用Promise封装setTimeout）",
    "content": "<pre><code class=\"language-css\">function timeout(delay) {<br>  return new Promise(resolve => {<br>    setTimeout(resolve, delay)<br>  })<br>};<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668163,
    "title": "实现Object.assign",
    "content": "<pre><code class=\"language-javascript\">Object.myAssign = function(target, ...source) {<br>    if (target == null) {<br>        throw new TypeError('Cannot convert undefined or null to object')<br>    }<br>    let ret = Object(target) <br>    source.forEach(function(obj) {<br>        if (obj != null) {<br>            for (let key in obj) {<br>                if (obj.hasOwnProperty(key)) {<br>                    ret[key] = obj[key]<br>                }<br>            }<br>        }<br>    })<br>    return ret<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668164,
    "title": "实现日期格式化函数",
    "content": "输入：<br><br><pre><code class=\"language-javascript\">dateFormat(new Date('2020-12-01'), 'yyyy/MM/dd') // 2020/12/01<br>dateFormat(new Date('2020-04-01'), 'yyyy/MM/dd') // 2020/04/01<br>dateFormat(new Date('2020-04-01'), 'yyyy年MM月dd日') // 2020年04月01日<br>const dateFormat = (dateInput, format)=>{<br>    var day = dateInput.getDate() <br>    var month = dateInput.getMonth() + 1  <br>    var year = dateInput.getFullYear()   <br>    format = format.replace(/yyyy/, year)<br>    format = format.replace(/MM/,month)<br>    format = format.replace(/dd/,day)<br>    return format<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668165,
    "title": "交换a,b的值，不能用临时变量",
    "content": "巧妙的利用两个数的和、差：<br><br><pre><code class=\"language-javascript\">a = a + b<br>b = a - b<br>a = a - b<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668166,
    "title": "实现数组的乱序输出",
    "content": "主要的实现思路就是：<br><br><li>取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。</li><br><li>第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换</li><br><li>按照上面的规律执行，直到遍历完成</li><br><br><pre><code class=\"language-javascript\">var arr = [1,2,3,4,5,6,7,8,9,10];<br>for (var i = 0; i < arr.length; i++) {<br>  const randomIndex = Math.round(Math.random() <em> (arr.length - 1 - i)) + i;<br>  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];<br>}<br>console.log(arr)<br></code></pre><br><br>还有一方法就是倒序遍历：<br><br><pre><code class=\"language-javascript\">var arr = [1,2,3,4,5,6,7,8,9,10];<br>let length = arr.length,<br>    randomIndex,<br>    temp;<br>  while (length) {<br>    randomIndex = Math.floor(Math.random() </em> length--);<br>    temp = arr[length];<br>    arr[length] = arr[randomIndex];<br>    arr[randomIndex] = temp;<br>  }<br>console.log(arr)<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668167,
    "title": "实现数组元素求和",
    "content": "<li>arr=[1,2,3,4,5,6,7,8,9,10]，求和</li><br><br><pre><code class=\"language-javascript\">let arr=[1,2,3,4,5,6,7,8,9,10]<br>let sum = arr.reduce( (total,i) => total += i,0);<br>console.log(sum);<br></code></pre><br><li>arr=[1,2,3,[[4,5],6],7,8,9]，求和</li><br><br><pre><code class=\"language-javascript\">var = arr=[1,2,3,[[4,5],6],7,8,9]<br>let arr= arr.toString().split(',').reduce( (total,i) => total += Number(i),0);<br>console.log(arr);<br></code></pre><br><br>递归实现：<br><br><pre><code class=\"language-javascript\">let arr = [1, 2, 3, 4, 5, 6] <br><br>function add(arr) {<br>    if (arr.length == 1) return arr[0] <br>    return arr[0] + add(arr.slice(1)) <br>}<br>console.log(add(arr)) // 21<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668168,
    "title": "实现数组的扁平化",
    "content": "<strong>（1）递归实现</strong><br><br>普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：<br><br><pre><code class=\"language-javascript\">let arr = [1, [2, [3, 4, 5]]];<br>function flatten(arr) {<br>  let result = [];<br><br>  for(let i = 0; i < arr.length; i++) {<br>    if(Array.isArray(arr[i])) {<br>      result = result.concat(flatten(arr[i]));<br>    } else {<br>      result.push(arr[i]);<br>    }<br>  }<br>  return result;<br>}<br>flatten(arr);  //  [1, 2, 3, 4，5]<br></code></pre><br><br><strong>（2）reduce 函数迭代</strong><br><br>从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么其实也可以用reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示：<br><br><pre><code class=\"language-javascript\">let arr = [1, [2, [3, 4]]];<br>function flatten(arr) {<br>    return arr.reduce(function(prev, next){<br>        return prev.concat(Array.isArray(next) ? flatten(next) : next)<br>    }, [])<br>}<br>console.log(flatten(arr));//  [1, 2, 3, 4，5]<br></code></pre><br><br><strong>（3）扩展运算符实现</strong><br><br>这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：<br><br><pre><code class=\"language-javascript\">let arr = [1, [2, [3, 4]]];<br>function flatten(arr) {<br>    while (arr.some(item => Array.isArray(item))) {<br>        arr = [].concat(...arr);<br>    }<br>    return arr;<br>}<br>console.log(flatten(arr)); //  [1, 2, 3, 4，5]<br></code></pre><br><br><strong>（4）split 和 toString</strong><br><br>可以通过 split 和 toString 两个方法来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：<br><br><pre><code class=\"language-javascript\">let arr = [1, [2, [3, 4]]];<br>function flatten(arr) {<br>    return arr.toString().split(',');<br>}<br>console.log(flatten(arr)); //  [1, 2, 3, 4，5]<br></code></pre><br><br>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。<br><br><strong>（5）</strong> <strong>ES6 中的 flat</strong><br><br>我们还可以直接调用 ES6 中的 flat 方法来实现数组扁平化。flat 方法的语法：<code>arr.flat([depth])</code><br><br>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 Infinity，代表不论多少层都要展开：<br><br><pre><code class=\"language-javascript\">let arr = [1, [2, [3, 4]]];<br>function flatten(arr) {<br>  return arr.flat(Infinity);<br>}<br>console.log(flatten(arr)); //  [1, 2, 3, 4，5]<br></code></pre><br><br>可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 Infinity，可以达到扁平化。<br><br><strong>（6）正则和 JSON 方法</strong><br><br>在第4种方法中已经使用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组：<br><br><pre><code class=\"language-javascript\">let arr = [1, [2, [3, [4, 5]]], 6];<br>function flatten(arr) {<br>  let str = JSON.stringify(arr);<br>  str = str.replace(/(\\[|\\])/g, '');<br>  str = '[' + str + ']';<br>  return JSON.parse(str); <br>}<br>console.log(flatten(arr)); //  [1, 2, 3, 4，5]<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668169,
    "title": "实现数组去重",
    "content": "给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。<br><br>ES6方法（使用数据结构集合）：<br><br><pre><code class=\"language-javascript\">const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];<br><br>Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]<br></code></pre><br><br>ES5方法：使用map存储不重复的数字<br><br><pre><code class=\"language-javascript\">const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];<br><br>uniqueArray(array); // [1, 2, 3, 5, 9, 8]<br><br>function uniqueArray(array) {<br>  let map = {};<br>  let res = [];<br>  for(var i = 0; i < array.length; i++) {<br>    if(!map.hasOwnProperty([array[i]])) {<br>      map[array[i]] = 1;<br>      res.push(array[i]);<br>    }<br>  }<br>  return res;<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668170,
    "title": "实现数组的flat方法",
    "content": "<pre><code class=\"language-javascript\">function _flat(arr, depth) {<br>  if(!Array.isArray(arr) || depth <= 0) {<br>    return arr;<br>  }<br>  return arr.reduce((prev, cur) => {<br>    if (Array.isArray(cur)) {<br>      return prev.concat(_flat(cur, depth - 1))<br>    } else {<br>      return prev.concat(cur);<br>    }<br>  }, []);<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668171,
    "title": "实现数组的push方法",
    "content": "<pre><code class=\"language-javascript\">let arr = [];<br>Array.prototype.push = function() {<br>  for( let i = 0 ; i < arguments.length ; i++){<br>    this[this.length] = arguments[i] ;<br>  }<br>  return this.length;<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668172,
    "title": "实现数组的filter方法",
    "content": "<pre><code class=\"language-javascript\">Array.prototype._filter = function(fn) {<br>    if (typeof fn !== \"function\") {<br>        throw Error('参数必须是一个函数');<br>    }<br>    const res = [];<br>    for (let i = 0, len = this.length; i < len; i++) {<br>        fn(this[i]) && res.push(this[i]);<br>    }<br>    return res;<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668173,
    "title": "实现数组的map方法",
    "content": "<pre><code class=\"language-javascript\">Array.prototype._map = function(fn) {<br>   if (typeof fn !== \"function\") {<br>        throw Error('参数必须是一个函数');<br>    }<br>    const res = [];<br>    for (let i = 0, len = this.length; i < len; i++) {<br>        res.push(fn(this[i]));<br>    }<br>    return res;<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668174,
    "title": "实现字符串的repeat方法",
    "content": "输入字符串s，以及其重复的次数，输出重复的结果，例如输入abc，2，输出abcabc。<br><br><pre><code class=\"language-javascript\">function repeat(s, n) {<br>    return (new Array(n + 1)).join(s);<br>}<br></code></pre><br><br>递归：<br><br><pre><code class=\"language-javascript\">function repeat(s, n) {<br>    return (n > 0) ? s.concat(repeat(s, --n)) : \"\";<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668175,
    "title": "实现字符串翻转",
    "content": "在字符串的原型链上添加一个方法，实现字符串翻转：<br><br><pre><code class=\"language-javascript\">String.prototype._reverse = function(a){<br>    return a.split(\"\").reverse().join(\"\");<br>}<br>var obj = new String();<br>var res = obj._reverse ('hello');<br>console.log(res);    // olleh<br></code></pre><br><br>需要注意的是，必须通过实例化对象之后再去调用定义的方法，不然找不到该方法。",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668176,
    "title": "将数字每千分位用逗号隔开",
    "content": "<strong>数字有小数版本：</strong><br><br><pre><code class=\"language-javascript\">let format = n => {<br>    let num = n.toString() // 转成字符串<br>    let decimals = ''<br>        // 判断是否有小数<br>    num.indexOf('.') > -1 ? decimals = num.split('.')[1] : decimals<br>    let len = num.length<br>    if (len <= 3) {<br>        return num<br>    } else {<br>        let temp = ''<br>        let remainder = len % 3<br>        decimals ? temp = '.' + decimals : temp<br>        if (remainder > 0) { // 不是3的整数倍<br>            return num.slice(0, remainder) + ',' + num.slice(remainder, len).match(/\\d{3}/g).join(',') + temp<br>        } else { // 是3的整数倍<br>            return num.slice(0, len).match(/\\d{3}/g).join(',') + temp <br>        }<br>    }<br>}<br>format(12323.33)  // '12,323.33'<br></code></pre><br><br><strong>数字无小数版本：</strong><br><br><pre><code class=\"language-javascript\">let format = n => {<br>    let num = n.toString() <br>    let len = num.length<br>    if (len <= 3) {<br>        return num<br>    } else {<br>        let remainder = len % 3<br>        if (remainder > 0) { // 不是3的整数倍<br>            return num.slice(0, remainder) + ',' + num.slice(remainder, len).match(/\\d{3}/g).join(',') <br>        } else { // 是3的整数倍<br>            return num.slice(0, len).match(/\\d{3}/g).join(',') <br>        }<br>    }<br>}<br>format(1232323)  // '1,232,323'<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668177,
    "title": "实现非负大整数相加和相乘",
    "content": "JavaScript对数值有范围的限制，限制如下：<br><br><pre><code class=\"language-javascript\">Number.MAX_VALUE // 1.7976931348623157e+308<br>Number.MAX_SAFE_INTEGER // 9007199254740991<br>Number.MIN_VALUE // 5e-324<br>Number.MIN_SAFE_INTEGER // -9007199254740991<br></code></pre><br><br><h4>（1）大数相加</h4><br><br>如果想要对一个超大的整数(<code>> Number.MAX_SAFE_INTEGER</code>)进行加法运算，但是又想输出一般形式，那么使用 + 是无法达到的，一旦数字超过 <code>Number.MAX_SAFE_INTEGER</code> 数字会被立即转换为科学计数法，并且数字精度相比以前将会有误差。<br><br>实现一个算法进行大数的相加：<br><br><pre><code class=\"language-javascript\">function sumBigNumber(a, b) {<br>  let res = '';<br>  let temp = 0;<br>  <br>  a = a.split('');<br>  b = b.split('');<br>  <br>  while (a.length || b.length || temp) {<br>    temp += ~~a.pop() + ~~b.pop();<br>    res = (temp % 10) + res;<br>    temp  = temp > 9<br>  }<br>  return res.replace(/^0+/, '');<br>}<br></code></pre><br><br>其主要的思路如下：<br><br><li>首先用字符串的方式来保存大数，这样数字在数学表示上就不会发生变化</li><br><li>初始化res，temp来保存中间的计算结果，并将两个字符串转化为数组，以便进行每一位的加法运算</li><br><li>将两个数组的对应的位进行相加，两个数相加的结果可能大于10，所以可能要仅为，对10进行取余操作，将结果保存在当前位</li><br><li>判断当前位是否大于9，也就是是否会进位，若是则将temp赋值为true，因为在加法运算中，true会自动隐式转化为1，以便于下一次相加</li><br><li>重复上述操作，直至计算结束</li><br><br><h4>（2）大数相乘</h4><br><br><pre><code class=\"language-javascript\">function multiplyBigNum(num1, num2) {<br>    //判断输入是不是数字<br>    if (isNaN(num1) || isNaN(num2)) return \"\";<br>    num1 = num1 + \"\"<br>    num2 = num2 + \"\"<br>    let len1 = num1.length,<br>        len2 = num2.length;<br>    let pos = [];<br><br>    //j放外面，先固定被乘数的一位，分别去乘乘数的每一位，更符合竖式演算法<br>    for (let j = len2 - 1; j >= 0; j--) {<br>        for (let i = len1 - 1; i >= 0; i--) {<br>            //两个个位数相乘，最多产生两位数，index1代表十位，index2代表个位<br>            let index1 = i + j,<br>                index2 = i + j + 1;<br>            //两个个位数乘积加上当前位置个位已累积的数字，会产生进位，比如08 + 7 = 15，产生了进位1<br>            let mul = num1[i] * num2[j] + (pos[index2] || 0);<br>            //mul包含新计算的十位，加上原有的十位就是最新的十位<br>            pos[index1] = Math.floor(mul / 10) + (pos[index1] || 0);<br>            //mul的个位就是最新的个位<br>            pos[index2] = mul % 10;<br>        }<br>    }<br><br>    //去掉前置0<br>    let result = pos.join(\"\").replace(/^0+/, \"\");<br><br>    return result - 0 || '0';<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668178,
    "title": "实现 add(1)(2)(3)",
    "content": "函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。<br><br>1）粗暴版<br><br><pre><code class=\"language-javascript\">function add (a) {<br>return function (b) {<br>   return function (c) {<br>      return a + b + c;<br>   }<br>}<br>}<br>console.log(add(1)(2)(3)); // 6<br></code></pre><br><br>2）柯里化解决方案<br><br><li>参数长度固定</li><br><br><pre><code class=\"language-javascript\">var add = function (m) {<br>  var temp = function (n) {<br>    return add(m + n);<br>  }<br>  temp.toString = function () {<br>    return m;<br>  }<br>  return temp;<br>};<br>console.log(add(3)(4)(5)); // 12<br>console.log(add(3)(6)(9)(25)); // 43<br></code></pre><br><br>对于add(3)(4)(5)，其执行过程如下：<br><br>1. 先执行add(3)，此时m=3，并且返回temp函数；<br>2. 执行temp(4)，这个函数内执行add(m+n)，n是此次传进来的数值4，m值还是上一步中的3，所以add(m+n)=add(3+4)=add(7)，此时m=7，并且返回temp函数<br>3. 执行temp(5)，这个函数内执行add(m+n)，n是此次传进来的数值5，m值还是上一步中的7，所以add(m+n)=add(7+5)=add(12)，此时m=12，并且返回temp函数<br>4. 由于后面没有传入参数，等于返回的temp函数不被执行而是打印，了解JS的朋友都知道对象的toString是修改对象转换字符串的方法，因此代码中temp函数的toString函数return m值，而m值是最后一步执行函数时的值m=12，所以返回值是12。<br><li>参数长度不固定</li><br><br><pre><code class=\"language-javascript\">function add (...args) {<br>    //求和<br>    return args.reduce((a, b) => a + b)<br>}<br>function currying (fn) {<br>    let args = []<br>    return function temp (...newArgs) {<br>        if (newArgs.length) {<br>            args = [<br>                ...args,<br>                ...newArgs<br>            ]<br>            return temp<br>        } else {<br>            let val = fn.apply(this, args)<br>            args = [] //保证再次调用时清空<br>            return val<br>        }<br>    }<br>}<br>let addCurry = currying(add)<br>console.log(addCurry(1)(2)(3)(4, 5)())  //15<br>console.log(addCurry(1)(2)(3, 4, 5)())  //15<br>console.log(addCurry(1)(2, 3, 4, 5)())  //15<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668179,
    "title": "实现类数组转化为数组",
    "content": "类数组转换为数组的方法有这样几种：<br><br><li>通过 call 调用数组的 slice 方法来实现转换</li><br><br><pre><code class=\"language-javascript\">Array.prototype.slice.call(arrayLike);<br></code></pre><br><li>通过 call 调用数组的 splice 方法来实现转换</li><br><br><pre><code class=\"language-javascript\">Array.prototype.splice.call(arrayLike, 0);<br></code></pre><br><li>通过 apply 调用数组的 concat 方法来实现转换</li><br><br><pre><code class=\"language-javascript\">Array.prototype.concat.apply([], arrayLike);<br></code></pre><br><li>通过 Array.from 方法来实现转换</li><br><br><pre><code class=\"language-javascript\">Array.from(arrayLike);<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668180,
    "title": "使用 reduce 求和",
    "content": "arr = [1,2,3,4,5,6,7,8,9,10]，求和<br><br><pre><code class=\"language-javascript\">let arr = [1,2,3,4,5,6,7,8,9,10]<br>arr.reduce((prev, cur) => { return prev + cur }, 0)<br></code></pre><br><br>arr = [1,2,3,[[4,5],6],7,8,9]，求和<br><br><pre><code class=\"language-javascript\">let arr = [1,2,3,4,5,6,7,8,9,10]<br>arr.flat(Infinity).reduce((prev, cur) => { return prev + cur }, 0)<br></code></pre><br><br>arr = [{a:1, b:3}, {a:2, b:3, c:4}, {a:3}]，求和<br><br><pre><code class=\"language-javascript\">let arr = [{a:9, b:3, c:4}, {a:1, b:3}, {a:3}] <br><br>arr.reduce((prev, cur) => {<br>    return prev + cur[\"a\"];<br>}, 0)<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668181,
    "title": "将js对象转化为树形结构",
    "content": "<pre><code class=\"language-javascript\">// 转换前：<br>source = [{<br>            id: 1,<br>            pid: 0,<br>            name: 'body'<br>          }, {<br>            id: 2,<br>            pid: 1,<br>            name: 'title'<br>          }, {<br>            id: 3,<br>            pid: 2,<br>            name: 'div'<br>          }]<br>// 转换为: <br>tree = [{<br>          id: 1,<br>          pid: 0,<br>          name: 'body',<br>          children: [{<br>            id: 2,<br>            pid: 1,<br>            name: 'title',<br>            children: [{<br>              id: 3,<br>              pid: 1,<br>              name: 'div'<br>            }]<br>          }<br>        }]<br></code></pre><br><br>代码实现：<br><br><pre><code class=\"language-javascript\">function jsonToTree(data) {<br>  // 初始化结果数组，并判断输入数据的格式<br>  let result = []<br>  if(!Array.isArray(data)) {<br>    return result<br>  }<br>  // 使用map，将当前对象的id与当前对象对应存储起来<br>  let map = {};<br>  data.forEach(item => {<br>    map[item.id] = item;<br>  });<br>  // <br>  data.forEach(item => {<br>    let parent = map[item.pid];<br>    if(parent) {<br>      (parent.children || (parent.children = [])).push(item);<br>    } else {<br>      result.push(item);<br>    }<br>  });<br>  return result;<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668182,
    "title": "使用ES5和ES6求函数参数的和",
    "content": "ES5：<br><br><pre><code class=\"language-javascript\">function sum() {<br>    let sum = 0<br>    Array.prototype.forEach.call(arguments, function(item) {<br>        sum += item <em> 1<br>    })<br>    return sum<br>}<br></code></pre><br><br>ES6：<br><br><pre><code class=\"language-javascript\">function sum(...nums) {<br>    let sum = 0<br>    nums.forEach(function(item) {<br>        sum += item </em> 1<br>    })<br>    return sum<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668183,
    "title": "解析 URL Params 为对象",
    "content": "<pre><code class=\"language-javascript\">let url = 'http://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&enabled';<br>parseParam(url)<br>/<em> 结果<br>{ user: 'anonymous',<br>  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型<br>  city: '北京', // 中文需解码<br>  enabled: true, // 未指定值得 key 约定为 true<br>}<br></em>/<br>function parseParam(url) {<br>  const paramsStr = /.+\\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来<br>  const paramsArr = paramsStr.split('&'); // 将字符串以 & 分割后存到数组中<br>  let paramsObj = {};<br>  // 将 params 存到对象中<br>  paramsArr.forEach(param => {<br>    if (/=/.test(param)) { // 处理有 value 的参数<br>      let [key, val] = param.split('='); // 分割 key 和 value<br>      val = decodeURIComponent(val); // 解码<br>      val = /^\\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字<br>      if (paramsObj.hasOwnProperty(key)) { // 如果对象有 key，则添加一个值<br>        paramsObj[key] = [].concat(paramsObj[key], val);<br>      } else { // 如果对象没有这个 key，创建 key 并设置值<br>        paramsObj[key] = val;<br>      }<br>    } else { // 处理没有 value 的参数<br>      paramsObj[param] = true;<br>    }<br>  })<br>  return paramsObj;<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668184,
    "title": "有序二维数组查找目标值",
    "content": "<pre><code class=\"language-javascript\">var findNumberIn2DArray = function(matrix, target) {<br>    if (matrix == null || matrix.length == 0) {<br>        return false;<br>    }<br>    let row = 0;<br>    let column = matrix[0].length - 1;<br>    while (row < matrix.length && column >= 0) {<br>        if (matrix[row][column] == target) {<br>            return true;<br>        } else if (matrix[row][column] > target) {<br>            column--;<br>        } else {<br>            row++;<br>        }<br>    }<br>    return false;<br>};<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668185,
    "title": "二维数组斜向打印",
    "content": "<pre><code class=\"language-javascript\">function printMatrix(arr){<br>  let m = arr.length, n = arr[0].length<br>  let res = []<br>  <br>  // 左上角，从0 到 n - 1 列进行打印<br>  for (let k = 0; k < n; k++) {<br>    for (let i = 0, j = k; i < m && j >= 0; i++, j--) {<br>      res.push(arr[i][j]);<br>    }<br>  }<br><br>  // 右下角，从1 到 n - 1 行进行打印<br>  for (let k = 1; k < m; k++) {<br>    for (let i = k, j = n - 1; i < m && j >= 0; i++, j--) {<br>      res.push(arr[i][j]);<br>    }<br>  }<br>  return res<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668186,
    "title": "找出Element元素的全部Input子元素",
    "content": "<pre><code class=\"language-javascript\">function findAllInputElement(element) {<br>  const rec = function (element, arr) {<br>    if (element.nodeName.toUpperCase() === \"INPUT\") {<br>      arr.push(element)<br>    }<br>    let children = element.childNodes<br>    children.forEach(element => {<br>      rec(element, arr)<br>    });<br>    return arr<br>  }<br>  return rec(element, [])<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668187,
    "title": "将手机号中间四位变成*",
    "content": "（1）利用数组splice，split，join方法<br><br><pre><code class=\"language-javascript\">const tel = 18877776666; <br>tel = \"\" + tel; <br>var ary = tel.split(\"\"); <br>ary.splice(3,4,\"*<em><strong>\"); <br>var tel1 = ary.join(\"\"); <br>console.log(tel1);<br></code></pre><br><br>（2）利用字符串的substr方法<br><br><pre><code class=\"language-javascript\">const tel = 18877776666; <br>tel = \"\" + tel; <br>var tel1 = tel.substr(0,3) + \"</strong><strong>\" + tel.substr(7) <br>console.log(tel1);<br></code></pre><br><br>（3）利用字符串substring方法<br><br><pre><code class=\"language-javascript\">const tel = 18877776666;  <br>tel = \"\" + tel; <br>var tel1 =tel.replace(tel.substring(3,7), \"</strong><strong>\") <br>console.log(tel1);<br></code></pre><br><br>（4）利用正则<br><br><pre><code class=\"language-javascript\">const tel = 18877776666;  <br>tel = \"\" + tel; <br>var reg=/(\\d{3})\\d{4}(\\d{4})/; <br>var tel1 = tel.replace(reg, \"$1</strong></em>*$2\") <br>console.log(tel1);<br></code></pre><br><br>##",
    "categoryId": "1768000001011",
    "isFrequent": true,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668188,
    "title": "循环打印红黄绿",
    "content": "下面来看一道比较典型的问题，通过这个问题来对比几种异步编程方法：<strong>红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？</strong><br><br>三个亮灯函数：<br><br><pre><code class=\"language-javascript\">function red() {<br>    console.log('red');<br>}<br>function green() {<br>    console.log('green');<br>}<br>function yellow() {<br>    console.log('yellow');<br>}<br></code></pre><br><br>这道题复杂的地方在于<strong>需要“交替重复”亮灯</strong>，而不是“亮完一次”就结束了。<br><br><h4>（1）用 callback 实现</h4><br><br><pre><code class=\"language-javascript\">const task = (timer, light, callback) => {<br>    setTimeout(() => {<br>        if (light === 'red') {<br>            red()<br>        }<br>        else if (light === 'green') {<br>            green()<br>        }<br>        else if (light === 'yellow') {<br>            yellow()<br>        }<br>        callback()<br>    }, timer)<br>}<br>task(3000, 'red', () => {<br>    task(2000, 'green', () => {<br>        task(1000, 'yellow', Function.prototype)<br>    })<br>})<br></code></pre><br><br>这里存在一个 bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？<br><br>上面提到过递归，可以递归亮灯的一个周期：<br><br><pre><code class=\"language-javascript\">const step = () => {<br>    task(3000, 'red', () => {<br>        task(2000, 'green', () => {<br>            task(1000, 'yellow', step)<br>        })<br>    })<br>}<br>step()<br></code></pre><br><br><strong>注意看黄灯亮的回调里又再次调用了 step 方法</strong> 以完成循环亮灯。<br><br><h4>（2）用 promise 实现</h4><br><br><pre><code class=\"language-javascript\">const task = (timer, light) => <br>    new Promise((resolve, reject) => {<br>        setTimeout(() => {<br>            if (light === 'red') {<br>                red()<br>            }<br>            else if (light === 'green') {<br>                green()<br>            }<br>            else if (light === 'yellow') {<br>                yellow()<br>            }<br>            resolve()<br>        }, timer)<br>    })<br>const step = () => {<br>    task(3000, 'red')<br>        .then(() => task(2000, 'green'))<br>        .then(() => task(2100, 'yellow'))<br>        .then(step)<br>}<br>step()<br></code></pre><br><br>这里将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。<br><br><h4>（3）用 async/await 实现</h4><br><br><pre><code class=\"language-javascript\">const taskRunner =  async () => {<br>    await task(3000, 'red')<br>    await task(2000, 'green')<br>    await task(2100, 'yellow')<br>    taskRunner()<br>}<br>taskRunner()<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668189,
    "title": "实现每隔一秒打印 1,2,3,4",
    "content": "<pre><code class=\"language-javascript\">// 使用闭包实现<br>for (var i = 0; i < 5; i++) {<br>  (function(i) {<br>    setTimeout(function() {<br>      console.log(i);<br>    }, i <em> 1000);<br>  })(i);<br>}<br>// 使用 let 块级作用域<br>for (let i = 0; i < 5; i++) {<br>  setTimeout(function() {<br>    console.log(i);<br>  }, i </em> 1000);<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668190,
    "title": "小孩报数问题",
    "content": "有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?<br><br><pre><code class=\"language-javascript\">function childNum(num, count){<br>    let allplayer = [];    <br>    for(let i = 0; i < num; i++){<br>        allplayer[i] = i + 1;<br>    }<br>    <br>    let exitCount = 0;    // 离开人数<br>    let counter = 0;      // 记录报数<br>    let curIndex = 0;     // 当前下标<br>    <br>    while(exitCount < num - 1){<br>        if(allplayer[curIndex] !== 0) counter++;    <br>        <br>        if(counter == count){<br>            allplayer[curIndex] = 0;                 <br>            counter = 0;<br>            exitCount++;  <br>        }<br>        curIndex++;<br>        if(curIndex == num){<br>            curIndex = 0               <br>        };           <br>    }    <br>    for(i = 0; i < num; i++){<br>        if(allplayer[i] !== 0){<br>            return allplayer[i]<br>        }      <br>    }<br>}<br>childNum(30, 3)<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668192,
    "title": "用Promise实现图片的异步加载",
    "content": "<pre><code class=\"language-javascript\">let imageAsync=(url)=>{<br>            return new Promise((resolve,reject)=>{<br>                let img = new Image();<br>                img.src = url;<br>                img.οnlοad=()=>{<br>                    console.log(<code>图片请求成功，此处进行通用操作</code>);<br>                    resolve(image);<br>                }<br>                img.οnerrοr=(err)=>{<br>                    console.log(<code>失败，此处进行失败的通用操作</code>);<br>                    reject(err);<br>                }<br>            })<br>        }<br>        <br>imageAsync(\"url\").then(()=>{<br>    console.log(\"加载成功\");<br>}).catch((error)=>{<br>    console.log(\"加载失败\");<br>})<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668193,
    "title": "实现发布-订阅模式",
    "content": "<pre><code class=\"language-javascript\">class EventCenter{<br>  // 1. 定义事件容器，用来装事件数组<br>  let handlers = {}<br><br>  // 2. 添加事件方法，参数：事件名 事件方法<br>  addEventListener(type, handler) {<br>    // 创建新数组容器<br>    if (!this.handlers[type]) {<br>      this.handlers[type] = []<br>    }<br>    // 存入事件<br>    this.handlers[type].push(handler)<br>  }<br><br>  // 3. 触发事件，参数：事件名 事件参数<br>  dispatchEvent(type, params) {<br>    // 若没有注册该事件则抛出错误<br>    if (!this.handlers[type]) {<br>      return new Error('该事件未注册')<br>    }<br>    // 触发事件<br>    this.handlers[type].forEach(handler => {<br>      handler(...params)<br>    })<br>  }<br><br>  // 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布<br>  removeEventListener(type, handler) {<br>    if (!this.handlers[type]) {<br>      return new Error('事件无效')<br>    }<br>    if (!handler) {<br>      // 移除事件<br>      delete this.handlers[type]<br>    } else {<br>      const index = this.handlers[type].findIndex(el => el === handler)<br>      if (index === -1) {<br>        return new Error('无该绑定事件')<br>      }<br>      // 移除事件<br>      this.handlers[type].splice(index, 1)<br>      if (this.handlers[type].length === 0) {<br>        delete this.handlers[type]<br>      }<br>    }<br>  }<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668194,
    "title": "查找文章中出现频率最高的单词",
    "content": "<pre><code class=\"language-javascript\">function findMostWord(article) {<br>  // 合法性判断<br>  if (!article) return;<br>  // 参数处理<br>  article = article.trim().toLowerCase();<br>  let wordList = article.match(/[a-z]+/g),<br>    visited = [],<br>    maxNum = 0,<br>    maxWord = \"\";<br>  article = \" \" + wordList.join(\"  \") + \" \";<br>  // 遍历判断单词出现次数<br>  wordList.forEach(function(item) {<br>    if (visited.indexOf(item) < 0) {<br>      // 加入 visited <br>      visited.push(item);<br>      let word = new RegExp(\" \" + item + \" \", \"g\"),<br>        num = article.match(word).length;<br>      if (num > maxNum) {<br>        maxNum = num;<br>        maxWord = item;<br>      }<br>    }<br>  });<br>  return maxWord + \"  \" + maxNum;<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668195,
    "title": "封装异步的fetch，使用async await方式来使用",
    "content": "<pre><code class=\"language-javascript\">(async () => {<br>    class HttpRequestUtil {<br>        async get(url) {<br>            const res = await fetch(url);<br>            const data = await res.json();<br>            return data;<br>        }<br>        async post(url, data) {<br>            const res = await fetch(url, {<br>                method: 'POST',<br>                headers: {<br>                    'Content-Type': 'application/json'<br>                },<br>                body: JSON.stringify(data)<br>            });<br>            const result = await res.json();<br>            return result;<br>        }<br>        async put(url, data) {<br>            const res = await fetch(url, {<br>                method: 'PUT',<br>                headers: {<br>                    'Content-Type': 'application/json'<br>                },<br>                data: JSON.stringify(data)<br>            });<br>            const result = await res.json();<br>            return result;<br>        }<br>        async delete(url, data) {<br>            const res = await fetch(url, {<br>                method: 'DELETE',<br>                headers: {<br>                    'Content-Type': 'application/json'<br>                },<br>                data: JSON.stringify(data)<br>            });<br>            const result = await res.json();<br>            return result;<br>        }<br>    }<br>    const httpRequestUtil = new HttpRequestUtil();<br>    const res = await httpRequestUtil.get('http://golderbrother.cn/');<br>    console.log(res);<br>})();<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668196,
    "title": "实现prototype继承",
    "content": "所谓的原型链继承就是让新实例的原型等于父类的实例：<br><br><pre><code class=\"language-javascript\">//父方法<br>function SupperFunction(flag1){<br>    this.flag1 = flag1;<br>}<br><br>//子方法<br>function SubFunction(flag2){<br>    this.flag2 = flag2;<br>}<br><br>//父实例<br>var superInstance = new SupperFunction(true);<br><br>//子继承父<br>SubFunction.prototype = superInstance;<br><br>//子实例<br>var subInstance = new SubFunction(false);<br>//子调用自己和父的属性<br>subInstance.flag1;   // true<br>subInstance.flag2;   // false<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668197,
    "title": "实现双向数据绑定",
    "content": "<pre><code class=\"language-javascript\">let obj = {}<br>let input = document.getElementById('input')<br>let span = document.getElementById('span')<br>// 数据劫持<br>Object.defineProperty(obj, 'text', {<br>  configurable: true,<br>  enumerable: true,<br>  get() {<br>    console.log('获取数据了')<br>  },<br>  set(newVal) {<br>    console.log('数据更新了')<br>    input.value = newVal<br>    span.innerHTML = newVal<br>  }<br>})<br>// 输入监听<br>input.addEventListener('keyup', function(e) {<br>  obj.text = e.target.value<br>})<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668198,
    "title": "实现简单路由",
    "content": "<pre><code class=\"language-javascript\">// hash路由<br>class Route{<br>  constructor(){<br>    // 路由存储对象<br>    this.routes = {}<br>    // 当前hash<br>    this.currentHash = ''<br>    // 绑定this，避免监听时this指向改变<br>    this.freshRoute = this.freshRoute.bind(this)<br>    // 监听<br>    window.addEventListener('load', this.freshRoute, false)<br>    window.addEventListener('hashchange', this.freshRoute, false)<br>  }<br>  // 存储<br>  storeRoute (path, cb) {<br>    this.routes[path] = cb || function () {}<br>  }<br>  // 更新<br>  freshRoute () {<br>    this.currentHash = location.hash.slice(1) || '/'<br>    this.routes[this.currentHash]()<br>  }<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668199,
    "title": "实现斐波那契数列",
    "content": "<pre><code class=\"language-javascript\">// 递归<br>function fn (n){<br>    if(n==0) return 0<br>    if(n==1) return 1<br>    return fn(n-2)+fn(n-1)<br>}<br>// 优化<br>function fibonacci2(n) {<br>    const arr = [1, 1, 2];<br>    const arrLen = arr.length;<br><br>    if (n <= arrLen) {<br>        return arr[n];<br>    }<br><br>    for (let i = arrLen; i < n; i++) {<br>        arr.push(arr[i - 1] + arr[ i - 2]);<br>    }<br><br>    return arr[arr.length - 1];<br>}<br>// 非递归<br>function fn(n) {<br>    let pre1 = 1;<br>    let pre2 = 1;<br>    let current = 2;<br><br>    if (n <= 2) {<br>        return current;<br>    }<br><br>    for (let i = 2; i < n; i++) {<br>        pre1 = pre2;<br>        pre2 = current;<br>        current = pre1 + pre2;<br>    }<br><br>    return current;<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668200,
    "title": "字符串出现的不重复最长长度",
    "content": "用一个滑动窗口装没有重复的字符，枚举字符记录最大值即可。用 map 维护字符的索引，遇到相同的字符，把左边界移动过去即可。挪动的过程中记录最大长度：<br><br><pre><code class=\"language-javascript\">var lengthOfLongestSubstring = function (s) {<br>    let map = new Map();<br>    let i = -1<br>    let res = 0<br>    let n = s.length<br>    for (let j = 0; j < n; j++) {<br>        if (map.has(s[j])) {<br>            i = Math.max(i, map.get(s[j]))<br>        }<br>        res = Math.max(res, j - i)<br>        map.set(s[j], j)<br>    }<br>    return res<br>};<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668201,
    "title": "使用 setTimeout 实现 setInterval",
    "content": "setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。<br><br>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。<br><br>实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果<br><br><pre><code class=\"language-javascript\">function mySetInterval(fn, timeout) {<br>  // 控制器，控制定时器是否继续执行<br>  var timer = {<br>    flag: true<br>  };<br>  // 设置递归函数，模拟定时器执行。<br>  function interval() {<br>    if (timer.flag) {<br>      fn();<br>      setTimeout(interval, timeout);<br>    }<br>  }<br>  // 启动定时器<br>  setTimeout(interval, timeout);<br>  // 返回控制器<br>  return timer;<br>}<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668202,
    "title": "实现 jsonp",
    "content": "<pre><code class=\"language-javascript\">// 动态的加载js文件<br>function addScript(src) {<br>  const script = document.createElement('script');<br>  script.src = src;<br>  script.type = \"text/javascript\";<br>  document.body.appendChild(script);<br>}<br>addScript(\"http://xxx.xxx.com/xxx.js?callback=handleRes\");<br>// 设置一个全局的callback函数来接收回调结果<br>function handleRes(res) {<br>  console.log(res);<br>}<br>// 接口返回的数据格式<br>handleRes({a: 1, b: 2});<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  },
  {
    "id": 1768104668203,
    "title": "判断对象是否存在循环引用",
    "content": "循环引用对象本来没有什么问题，但是序列化的时候就会发生问题，比如调用<code>JSON.stringify()</code>对该类对象进行序列化，就会报错: <code>Converting circular structure to JSON.</code><br><br>下面方法可以用来判断一个对象中是否已存在循环引用：<br><br><pre><code class=\"language-javascript\">const isCycleObject = (obj,parent) => {<br>    const parentArr = parent || [obj];<br>    for(let i in obj) {<br>        if(typeof obj[i] === 'object') {<br>            let flag = false;<br>            parentArr.forEach((pObj) => {<br>                if(pObj === obj[i]){<br>                    flag = true;<br>                }<br>            })<br>            if(flag) return true;<br>            flag = isCycleObject(obj[i],[...parentArr,obj[i]]);<br>            if(flag) return true;<br>        }<br>    }<br>    return false;<br>}<br><br>const a = 1;<br>const b = {a};<br>const c = {b};<br>const o = {d:{a:3},c}<br>o.c.b.aa = a;<br><br>console.log(isCycleObject(o))<br></code></pre>",
    "categoryId": "1768000001011",
    "isFrequent": false,
    "createdAt": "2026-01-11T04:11:08.133Z",
    "updatedAt": "2026-01-11T04:11:08.133Z"
  }
]